#0
tools/framework/src/main/java/org/apache/bookkeeper/tools/framework/CliCommandGroup.java:47: error: Null Dereference
  object returned by `newSpec.commands()` could be null and is dereferenced at line 47.
  45.           String path = newSpec.parent() + " " + newSpec.name();
  46.   
  47. >         for (Command<GlobalFlagsT> cmd : newSpec.commands()) {
  48.               if (cmd instanceof CliCommand) {
  49.                   CliCommand<GlobalFlagsT, GlobalFlagsT> cliCmd = (CliCommand<GlobalFlagsT, GlobalFlagsT>) cmd;

#1
circe-checksum/src/main/java/com/scurrilous/circe/utils/NativeUtils.java:36: error: Null Dereference
  object returned by `getProperty("os.name")` could be null and is dereferenced at line 36.
  34.   public class NativeUtils {
  35.   
  36. >     public static final String OS_NAME = System.getProperty("os.name").toLowerCase(Locale.US);
  37.   
  38.       /**

#2
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Shell.java:51: error: Null Dereference
  object returned by `getProperty("os.name")` could be null and is dereferenced at line 51.
  49.        */
  50.       public static final boolean WINDOWS = /* borrowed from Path.WINDOWS */
  51. >             System.getProperty("os.name").startsWith("Windows");
  52.   
  53.       private long interval; // refresh interval in msec

#3
stream/distributedlog/core/src/main/java/org/apache/distributedlog/feature/AbstractFeatureProvider.java:54: error: Null Dereference
  object `featureProviderClass` last assigned on line 47 could be null and is dereferenced at line 54.
  52.           Constructor<? extends FeatureProvider> constructor;
  53.           try {
  54. >             constructor = featureProviderClass.getDeclaredConstructor(
  55.                       String.class,
  56.                       DistributedLogConfiguration.class,

#4
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/KVCommandProcessor.java:57: error: Null Dereference
  object returned by `command.getReqCase()` could be null and is dereferenced at line 57.
  55.           }
  56.   
  57. >         switch (command.getReqCase()) {
  58.               case NOP_REQ:
  59.                   break;

#5
cpu-affinity/src/main/java/org/apache/bookkeeper/common/util/affinity/impl/NativeUtils.java:67: error: Resource Leak
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 68 is not released after line 67.
**Note**: potential exception at line 73
  65.           int read;
  66.   
  67. >         try (InputStream input = NativeUtils.class.getResourceAsStream(path);
  68.                   OutputStream out = new FileOutputStream(temp)) {
  69.               if (input == null) {

#6
native-io/src/main/java/org/apache/bookkeeper/common/util/nativeio/NativeUtils.java:66: error: Resource Leak
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 67 is not released after line 66.
**Note**: potential exception at line 72
  64.           int read;
  65.   
  66. >         try (InputStream input = NativeUtils.class.getResourceAsStream(path);
  67.                OutputStream out = new FileOutputStream(temp)) {
  68.               if (input == null) {

#7
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/LedgersIndexCheckOp.java:89: error: Resource Leak
  resource of type `org.rocksdb.WriteOptions` acquired by call to `KeyValueStorageRocksDB(...)` at line 61 is not released after line 89.
  87.                   }
  88.               } finally {
  89. >                 iterator.close();
  90.               }
  91.   

#8
bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/cli/commands/autorecovery/TriggerAuditCommand.java:59: error: Null Dereference
  object `admin.mFactory` last assigned on line 56 could be null and is dereferenced by call to `triggerAudit()` at line 59.
  57.   
  58.           try {
  59. >             admin.triggerAudit();
  60.           } finally {
  61.               if (admin != null) {

#9
cpu-affinity/src/main/java/org/apache/bookkeeper/common/util/affinity/impl/IsolatedProcessors.java:57: error: Null Dereference
  object returned by `trim(range)` could be null and is dereferenced at line 57.
  55.           SortedSet<Integer> processors = new TreeSet<>();
  56.   
  57. >         for (String part : StringUtils.trim(range).split(",")) {
  58.               if (part.contains("-")) {
  59.                   // This is a range, eg: 1-5 with both edges included

#10
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/utils/GrpcChannels.java:61: error: Null Dereference
  object returned by `uri.getServiceInfos()` could be null and is dereferenced at line 61.
  59.   
  60.           ManagedChannelBuilder builder;
  61. >         if (uri.getServiceInfos().length > 0 && uri.getServiceInfos()[0].equals(BACKEND_INPROCESS)) {
  62.               // this is an inprocess service, so build an inprocess channel.
  63.               String serviceName = uri.getServiceHosts()[0];

#11
cpu-affinity/src/main/java/org/apache/bookkeeper/common/util/affinity/impl/ProcessorsInfo.java:72: error: Null Dereference
  object `key` last assigned on line 69 could be null and is dereferenced at line 72.
  70.                   String value = StringUtils.trim(parts[1]);
  71.   
  72. >                 if (key.equals("core id")) {
  73.                       coreId = Integer.parseInt(value);
  74.                   } else if (key.equals("processor")) {

#12
bookkeeper-server/src/main/java/org/apache/bookkeeper/sasl/SASLClientProviderFactory.java:69: error: Null Dereference
  object `SASLClientProviderFactory.login` last assigned on line 68 could be null and is dereferenced at line 69.
  67.   
  68.               this.login = loginClient();
  69. >             this.subject = login.getSubject();
  70.               this.isKrbTicket = !subject.getPrivateCredentials(KerberosTicket.class).isEmpty();
  71.               boolean systemRole = CLIENT_ROLE_SYSTEM.equals(clientConfiguration.getClientRole());

#13
bookkeeper-server/src/main/java/org/apache/bookkeeper/sasl/SASLBookieAuthProviderFactory.java:85: error: Null Dereference
  object `SASLBookieAuthProviderFactory.login` last assigned on line 84 could be null and is dereferenced at line 85.
  83.   
  84.               this.login = loginServer();
  85. >             this.subject = login.getSubject();
  86.               this.isKrbTicket = !subject.getPrivateCredentials(KerberosTicket.class).isEmpty();
  87.               if (isKrbTicket) {

#14
bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/cli/commands/autorecovery/WhoIsAuditorCommand.java:80: error: Null Dereference
  object `bka.mFactory` last assigned on line 79 could be null and is dereferenced by call to `getCurrentAuditor()` at line 80.
  78.               @Cleanup
  79.               BookKeeperAdmin bka = new BookKeeperAdmin(clientConfiguration);
  80. >             bookieId = bka.getCurrentAuditor();
  81.           }
  82.           if (bookieId == null) {

#15
stream/common/src/main/java/org/apache/bookkeeper/common/resolver/ServiceNameResolverProvider.java:88: error: Null Dereference
  object `hosts` last assigned on line 87 could be null and is dereferenced at line 88.
  86.   
  87.               String[] hosts = serviceURI.getServiceHosts();
  88. >             if (hosts.length == 0) {
  89.                   // no host is find, so return null to let grpc choose other resolver.
  90.                   return null;

#16
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/utils/NetUtils.java:79: error: Null Dereference
  object `endpointParts` last assigned on line 78 could be null and is dereferenced at line 79.
  77.       public static List<Endpoint> parseEndpoints(String endpointStr) {
  78.           String[] endpointParts = StringUtils.split(endpointStr, ',');
  79. >         checkArgument(endpointParts.length > 0,
  80.               "Invalid endpoint strings %s", endpointStr);
  81.           List<Endpoint> endpoints = Lists.newArrayListWithExpectedSize(endpointParts.length);

#17
tools/ledger/src/main/java/org/apache/bookkeeper/tools/cli/commands/bookieid/SearchReplaceBookieIdCommand.java:82: error: Resource Leak
  resource of type `org.apache.bookkeeper.client.BookKeeperAdmin` acquired to `admin` by call to `new()` at line 82 is not released after line 82.
**Note**: potential exception at line 86
  80.       @Override
  81.       protected void run(BookKeeper bk, Flags flags) throws Exception {
  82. >         try (BookKeeperAdmin admin = new BookKeeperAdmin((org.apache.bookkeeper.client.BookKeeper) bk)) {
  83.               LedgerManager ledgerManager = ((org.apache.bookkeeper.client.BookKeeper) bk).getLedgerManager();
  84.               long i = 0;

#18
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdUtils.java:84: error: Null Dereference
  object `keyParts` last assigned on line 83 could be null and is dereferenced at line 84.
  82.       static UUID parseLedgerKey(String ledgerKey) {
  83.           String[] keyParts = StringUtils.split(ledgerKey, '/');
  84. >         return UUID.fromString(keyParts[keyParts.length - 1]);
  85.       }
  86.   

#19
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BookKeeperClient.java:111: error: Null Dereference
  object `dnsResolverCls` last assigned on line 105 could be null and is dereferenced by call to `getDNSResolver(...)` at line 111.
  109.           }
  110.           final DNSToSwitchMapping dnsResolver =
  111. >                 NetUtils.getDNSResolver(dnsResolverCls, conf.getBkDNSResolverOverrides());
  112.   
  113.           try {

#20
bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/cli/commands/autorecovery/LostBookieRecoveryDelayCommand.java:104: error: Null Dereference
  object `admin.mFactory` last assigned on line 101 could be null and is dereferenced by call to `getLostBookieRecoveryDelay()` at line 104.
  102.           try {
  103.               if (getter) {
  104. >                 int lostBookieRecoveryDelay = admin.getLostBookieRecoveryDelay();
  105.                   LOG.info("LostBookieRecoveryDelay value in ZK: {}", String.valueOf(lostBookieRecoveryDelay));
  106.               } else {

#21
bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/cli/commands/autorecovery/LostBookieRecoveryDelayCommand.java:108: error: Null Dereference
  object `admin.mFactory` last assigned on line 101 could be null and is dereferenced by call to `setLostBookieRecoveryDelay(...)` at line 108.
  106.               } else {
  107.                   int lostBookieRecoveryDelay = flags.set;
  108. >                 admin.setLostBookieRecoveryDelay(lostBookieRecoveryDelay);
  109.                   LOG.info("Successfully set LostBookieRecoveryDelay value in ZK: {}",
  110.                            String.valueOf(lostBookieRecoveryDelay));

#22
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/HardLink.java:89: error: Null Dereference
  object `osName` last assigned on line 88 could be null and is dereferenced at line 89.
  87.     private static OSType getOSType() {
  88.       String osName = System.getProperty("os.name");
  89. >     if (osName.contains("Windows") && (osName.contains("XP")
  90.               || osName.contains("2003")
  91.               || osName.contains("Vista")

#23
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java:95: error: Null Dereference
  object `metadataClientDriver` last assigned on line 94 could be null and is dereferenced at line 95.
  93.           this.bkc = Auditor.createBookKeeperClient(conf, statsLogger.scope(BookKeeperClientStats.CLIENT_SCOPE));
  94.           MetadataClientDriver metadataClientDriver = bkc.getMetadataClientDriver();
  95. >         metadataClientDriver.setSessionStateListener(() -> {
  96.               LOG.error("Client connection to the Metadata server has expired, so shutting down AutoRecoveryMain!");
  97.               // do not run "shutdown" in the main ZooKeeper client thread

#24
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/utils/NetUtils.java:96: error: Null Dereference
  object `endpointParts` last assigned on line 95 could be null and is dereferenced at line 96.
  94.       public static Endpoint parseEndpoint(String endpointStr) {
  95.           String[] endpointParts = StringUtils.split(endpointStr, ':');
  96. >         checkArgument(2 == endpointParts.length,
  97.               "Invalid endpoint string %s - It should be 'host:port'.", endpointStr);
  98.           String host = endpointParts[0];

#25
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataDriverBase.java:103: error: Null Dereference
  object `schemeParts` last assigned on line 102 could be null and is dereferenced at line 103.
  101.           checkNotNull(scheme, "Invalid metadata service : " + metadataServiceUri);
  102.           String[] schemeParts = StringUtils.split(scheme.toLowerCase(), '+');
  103. >         checkArgument(SCHEME.equals(schemeParts[0]), "Unknown metadata service scheme found : "
  104.               + schemeParts[0]);
  105.           Class<? extends LedgerManagerFactory> ledgerManagerFactoryClass;

#26
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/http/service/ClusterInfoService.java:103: error: Null Dereference
  object returned by `ClusterInfoService.bka.getAllBookies()` could be null and is dereferenced at line 103.
  101.       @SneakyThrows
  102.       private void fillBookiesInfo(ClusterInfo info) {
  103. >         int totalBookiesCount = bka.getAllBookies().size();
  104.           int writableBookiesCount = bka.getAvailableBookies().size();
  105.           int readonlyBookiesCount = bka.getReadOnlyBookies().size();

#27
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/http/service/ClusterInfoService.java:104: error: Null Dereference
  object returned by `ClusterInfoService.bka.getAvailableBookies()` could be null and is dereferenced at line 104.
  102.       private void fillBookiesInfo(ClusterInfo info) {
  103.           int totalBookiesCount = bka.getAllBookies().size();
  104. >         int writableBookiesCount = bka.getAvailableBookies().size();
  105.           int readonlyBookiesCount = bka.getReadOnlyBookies().size();
  106.           int unavailableBookiesCount = totalBookiesCount - writableBookiesCount - readonlyBookiesCount;

#28
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/http/service/ClusterInfoService.java:105: error: Null Dereference
  object returned by `ClusterInfoService.bka.getReadOnlyBookies()` could be null and is dereferenced at line 105.
  103.           int totalBookiesCount = bka.getAllBookies().size();
  104.           int writableBookiesCount = bka.getAvailableBookies().size();
  105. >         int readonlyBookiesCount = bka.getReadOnlyBookies().size();
  106.           int unavailableBookiesCount = totalBookiesCount - writableBookiesCount - readonlyBookiesCount;
  107.   

#29
stream/common/src/main/java/org/apache/bookkeeper/common/grpc/stats/ClientStats.java:115: error: Null Dereference
  object `serviceName` last assigned on line 114 could be null and is dereferenced at line 115.
  113.               String fullMethodName = methodDescriptor.getFullMethodName();
  114.               String serviceName = MethodDescriptor.extractFullServiceName(fullMethodName);
  115. >             String methodName = fullMethodName.substring(serviceName.length() + 1);
  116.   
  117.               MethodType type = methodDescriptor.getType();

#30
stream/common/src/main/java/org/apache/bookkeeper/common/grpc/stats/ServerStats.java:115: error: Null Dereference
  object `serviceName` last assigned on line 114 could be null and is dereferenced at line 115.
  113.               String fullMethodName = methodDescriptor.getFullMethodName();
  114.               String serviceName = MethodDescriptor.extractFullServiceName(fullMethodName);
  115. >             String methodName = fullMethodName.substring(serviceName.length() + 1);
  116.   
  117.               MethodType type = methodDescriptor.getType();

#31
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/subscription/ZKSubscriptionsStore.java:118: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `getLastCommitPositionFromZK()` at line 118 is not released after line 118.
  116.               CompletableFuture<Pair<String, DLSN>> future =
  117.                   // Get the last commit position from zookeeper
  118. >                 getSubscriber(subscriber).getLastCommitPositionFromZK().thenApply(
  119.                       dlsn -> Pair.of(subscriber, dlsn));
  120.               futures.add(future);

#32
tools/stream/src/main/java/org/apache/bookkeeper/stream/cli/commands/cluster/InitClusterCommand.java:156: error: Null Dereference
  object `uri` last assigned on line 154 could be null and is dereferenced at line 156.
  154.               URI uri = serviceURI.getUri();
  155.               URI rootUri = new URI(
  156. >                 uri.getScheme(),
  157.                   uri.getAuthority(),
  158.                   "",

#33
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java:116: error: Null Dereference
  object returned by `PacketProcessorBaseV3.request.getHeader().getVersion()` could be null and is dereferenced at line 116.
  114.   
  115.       protected boolean isVersionCompatible() {
  116. >         return this.request.getHeader().getVersion().equals(ProtocolVersion.VERSION_THREE);
  117.       }
  118.   

#34
stream/clients/java/all/src/main/java/org/apache/bookkeeper/clients/StorageClientImpl.java:138: error: Resource Leak
  resource of type `org.apache.bookkeeper.clients.impl.kv.PByteBufTableImpl` acquired by call to `PByteBufTableImpl(...)` at line 137 is not released after line 138.
  136.                       scheduler.chooseThread(props.getStreamId()),
  137.                       settings.backoffPolicy()
  138. >                 ).initialize();
  139.               }),
  140.               future

#35
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java:132: error: Null Dereference
  object `bk` last assigned on line 128 could be null and is dereferenced at line 132.
  130.               return FutureUtils.exception(e);
  131.           }
  132. >         bk.asyncDeleteLedger(segment.getLogSegmentId(), this, request);
  133.           return request.deletePromise;
  134.       }

#36
tests/integration-tests-utils/src/main/java/org/apache/bookkeeper/tests/integration/utils/DockerUtils.java:135: error: Resource Leak
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 141 is not released after line 135.
**Note**: potential exception at line 145
  133.           final int readBlockSize = 10000;
  134.   
  135. >         try (InputStream dockerStream = docker.copyArchiveFromContainerCmd(containerId, path).exec();
  136.                TarArchiveInputStream stream = new TarArchiveInputStream(dockerStream)) {
  137.               TarArchiveEntry entry = stream.getNextTarEntry();

#37
tests/integration-tests-utils/src/main/java/org/apache/bookkeeper/tests/integration/utils/DockerUtils.java:152: error: Resource Leak
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 141 is not released after line 152.
**Note**: potential exception at line 145
  150.                   entry = stream.getNextTarEntry();
  151.               }
  152. >         } catch (RuntimeException | IOException e) {
  153.               LOG.error("Error reading bk logs from container {}", containerId, e);
  154.           }

#38
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCCommandProcessor.java:144: error: Null Dereference
  object returned by `command.getReqCase()` could be null and is dereferenced at line 144.
  142.       public void applyCommand(long txid, ByteBuf cmdBuf, MVCCStoreImpl<byte[], byte[]> store) {
  143.           Command command = MVCCUtils.newCommand(cmdBuf);
  144. >         switch (command.getReqCase()) {
  145.               case NOP_REQ:
  146.                   return;

#39
stream/distributedlog/core/src/main/java/org/apache/bookkeeper/client/LedgerReader.java:149: error: Null Dereference
  object returned by `future(op)` could be null and is dereferenced at line 149.
  147.               private void readNext(long entryId) {
  148.                   PendingReadOp op = new PendingReadOp(lh, clientCtx, entryId, entryId, false);
  149. >                 op.future().whenComplete(this);
  150.                   op.submit();
  151.               }

#40
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCUtils.java:151: error: Null Dereference
  object returned by `protoOp.getRequestCase()` could be null and is dereferenced at line 151.
  149.   
  150.       public static Op<byte[], byte[]> toApiOp(RequestOp protoOp) {
  151. >         switch (protoOp.getRequestCase()) {
  152.               case REQUEST_PUT:
  153.                   return ProtoPutOpImpl.newPutOp(protoOp.getRequestPut());

#41
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerMetadataSerDe.java:190: error: Null Dereference
  object returned by `metadata.getDigestType()` could be null and is dereferenced by call to `apiToProtoDigestType(...)` at line 190.
  188.   
  189.   
  190. >             builder.setDigestType(apiToProtoDigestType(metadata.getDigestType()));
  191.   
  192.               serializePassword(metadata.getPassword(), builder);

#42
stream/distributedlog/core/src/main/java/org/apache/distributedlog/namespace/NamespaceDriverManager.java:168: error: Null Dereference
  object `schemeParts` last assigned on line 167 could be null and is dereferenced at line 168.
  166.           scheme = scheme.toLowerCase();
  167.           String[] schemeParts = StringUtils.split(scheme, '-');
  168. >         checkArgument(schemeParts.length > 0,
  169.                   "Invalid distributedlog scheme found : " + uri);
  170.           checkArgument(Objects.equal(DistributedLogConstants.SCHEME_PREFIX, schemeParts[0].toLowerCase()),

#43
stream/distributedlog/core/src/main/java/org/apache/distributedlog/auditor/DLAuditor.java:172: error: Null Dereference
  object returned by `bkc.get()` could be null and is dereferenced by call to `getLedgerManager(...)` at line 172.
  170.                                              final ExecutorService executorService)
  171.               throws IOException {
  172. >         LedgerManager lm = BookKeeperAccessor.getLedgerManager(bkc.get());
  173.   
  174.           final Set<Long> ledgers = new HashSet<Long>();

#44
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RegionAwareEnsemblePlacementPolicy.java:182: error: Null Dereference
  object returned by `newNode.getNetworkLocation()` could be null and is dereferenced at line 182.
  180.                           // refresh the rack info if its a known bookie
  181.                           BookieNode newNode = createBookieNode(bookieAddress);
  182. >                         if (!newNode.getNetworkLocation().equals(node.getNetworkLocation())) {
  183.                               topology.remove(node);
  184.                               topology.add(newNode);

#45
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/storage/GetStreamRequest.java:193: error: Null Dereference
  object returned by `getIdCase()` could be null and is dereferenced at line 193.
  191.       org.apache.bookkeeper.stream.proto.storage.GetStreamRequest other = (org.apache.bookkeeper.stream.proto.storage.GetStreamRequest) obj;
  192.   
  193. >     if (!getIdCase().equals(other.getIdCase())) return false;
  194.       switch (idCase_) {
  195.         case 1:

#46
stream/distributedlog/core/src/main/java/org/apache/bookkeeper/client/LedgerReader.java:199: error: Null Dereference
  object returned by `future(op)` could be null and is dereferenced at line 199.
  197.               long entryId = recoveryData.getLastAddConfirmed();
  198.               PendingReadOp op = new PendingReadOp(lh, clientCtx, entryId, entryId, false);
  199. >             op.future().whenComplete(readListener);
  200.               op.submit();
  201.           };

#47
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java:210: error: Null Dereference
  object `bk` last assigned on line 204 could be null and is dereferenced at line 210.
  208.           OpenReaderRequest request = new OpenReaderRequest(segment, startEntryId);
  209.           if (segment.isInProgress()) {
  210. >             bk.asyncOpenLedgerNoRecovery(
  211.                       segment.getLogSegmentId(),
  212.                       BookKeeper.DigestType.CRC32,

#48
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java:217: error: Null Dereference
  object `bk` last assigned on line 204 could be null and is dereferenced at line 217.
  215.                       request);
  216.           } else {
  217. >             bk.asyncOpenLedger(
  218.                       segment.getLogSegmentId(),
  219.                       BookKeeper.DigestType.CRC32,

#49
stream/server/src/main/java/org/apache/bookkeeper/stream/server/StorageServer.java:303: error: Resource Leak
  resource of type `org.apache.bookkeeper.stream.server.service.CuratorProviderService` acquired by call to `CuratorProviderService(...)` at line 303 is not released after line 303.
**Note**: potential exception at line 303
  301.           // Create the curator provider service
  302.           CuratorProviderService curatorProviderService = new CuratorProviderService(
  303. >             bkServerConf, dlConf, rootStatsLogger.scope("curator"));
  304.   
  305.           // Create the distributedlog namespace service

#50
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/SplitPolicy.java:229: error: Null Dereference
  object returned by `getPolicyCase()` could be null and is dereferenced at line 229.
  227.   
  228.       if (type_ != other.type_) return false;
  229. >     if (!getPolicyCase().equals(other.getPolicyCase())) return false;
  230.       switch (policyCase_) {
  231.         case 2:

#51
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BookKeeperClient.java:239: error: Null Dereference
  object `bk` last assigned on line 234 could be null and is dereferenced at line 239.
  237.           }
  238.           final CompletableFuture<Void> promise = new CompletableFuture<Void>();
  239. >         bk.asyncDeleteLedger(lid, new AsyncCallback.DeleteCallback() {
  240.               @Override
  241.               public void deleteComplete(int rc, Object ctx) {

#52
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java:251: error: Resource Leak
  resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 239 is not released after line 251.
**Note**: potential exception at line 240
  249.                           curMark.setLogMark(mark.getLogFileId(), mark.getLogFileOffset());
  250.                       }
  251. >                 } catch (IOException e) {
  252.                       LOG.error("Problems reading from " + file + " (this is okay if it is the first time starting this "
  253.                               + "bookie");

#53
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/RequestOp.java:241: error: Null Dereference
  object returned by `getRequestCase()` could be null and is dereferenced at line 241.
  239.       org.apache.bookkeeper.stream.proto.kv.rpc.RequestOp other = (org.apache.bookkeeper.stream.proto.kv.rpc.RequestOp) obj;
  240.   
  241. >     if (!getRequestCase().equals(other.getRequestCase())) return false;
  242.       switch (requestCase_) {
  243.         case 1:

#54
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/ResponseOp.java:241: error: Null Dereference
  object returned by `getResponseCase()` could be null and is dereferenced at line 241.
  239.       org.apache.bookkeeper.stream.proto.kv.rpc.ResponseOp other = (org.apache.bookkeeper.stream.proto.kv.rpc.ResponseOp) obj;
  240.   
  241. >     if (!getResponseCase().equals(other.getResponseCase())) return false;
  242.       switch (responseCase_) {
  243.         case 1:

#55
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MetadataDrivers.java:257: error: Null Dereference
  object `schemeParts` last assigned on line 256 could be null and is dereferenced at line 257.
  255.           scheme = scheme.toLowerCase();
  256.           String[] schemeParts = StringUtils.split(scheme, '+');
  257. >         checkArgument(schemeParts.length > 0,
  258.                   "Invalid metadata service scheme found : " + uri);
  259.           return getClientDriver(schemeParts[0]);

#56
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java:282: error: Null Dereference
  object `bk` last assigned on line 259 could be null and is dereferenced at line 282.
  280.           };
  281.           if (segment.isInProgress() && !fence) {
  282. >             bk.asyncOpenLedgerNoRecovery(
  283.                       segment.getLogSegmentId(),
  284.                       BookKeeper.DigestType.CRC32,

#57
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java:289: error: Null Dereference
  object `bk` last assigned on line 259 could be null and is dereferenced at line 289.
  287.                       null);
  288.           } else {
  289. >             bk.asyncOpenLedger(
  290.                       segment.getLogSegmentId(),
  291.                       BookKeeper.DigestType.CRC32,

#58
tests/integration-tests-utils/src/main/java/org/apache/bookkeeper/tests/integration/utils/MavenClassLoader.java:269: error: Resource Leak
  resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 269 is not released after line 269.
  267.   
  268.       private static File deCompressGZipFile(File gZippedFile, File tarFile) throws IOException {
  269. >         try (GZIPInputStream gZIPInputStream = new GZIPInputStream(new FileInputStream(gZippedFile));
  270.                FileOutputStream fos = new FileOutputStream(tarFile)) {
  271.               byte[] buffer = new byte[1024];

#59
tests/integration-tests-utils/src/main/java/org/apache/bookkeeper/tests/integration/utils/MavenClassLoader.java:269: error: Resource Leak
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 270 is not released after line 269.
**Note**: potential exception at line 274
  267.   
  268.       private static File deCompressGZipFile(File gZippedFile, File tarFile) throws IOException {
  269. >         try (GZIPInputStream gZIPInputStream = new GZIPInputStream(new FileInputStream(gZippedFile));
  270.                FileOutputStream fos = new FileOutputStream(tarFile)) {
  271.               byte[] buffer = new byte[1024];

#60
tests/integration-tests-utils/src/main/java/org/apache/bookkeeper/tests/integration/utils/MavenClassLoader.java:269: error: Resource Leak
  resource of type `java.util.zip.GZIPInputStream` acquired to `gZIPInputStream` by call to `GZIPInputStream(...)` at line 269 is not released after line 269.
**Note**: potential exception at line 270
  267.   
  268.       private static File deCompressGZipFile(File gZippedFile, File tarFile) throws IOException {
  269. >         try (GZIPInputStream gZIPInputStream = new GZIPInputStream(new FileInputStream(gZippedFile));
  270.                FileOutputStream fos = new FileOutputStream(tarFile)) {
  271.               byte[] buffer = new byte[1024];

#61
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:278: error: Null Dereference
  object `parts` last assigned on line 277 could be null and is dereferenced at line 278.
  276.   
  277.           String[] parts = StringUtils.split(NodeBase.normalize(defaultFaultDomain), NodeBase.PATH_SEPARATOR);
  278. >         if (parts.length != 2) {
  279.               LOG.error("provided defaultFaultDomain: {} is not valid", defaultFaultDomain);
  280.               throw new IllegalArgumentException("invalid defaultFaultDomain");

#62
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/KvUtils.java:282: error: Null Dereference
  object returned by `op.getResponseCase()` could be null and is dereferenced at line 282.
  280.           result.isSuccess(txnResponse.getSucceeded());
  281.           result.results(Lists.transform(txnResponse.getResponsesList(), op -> {
  282. >             switch (op.getResponseCase()) {
  283.                   case RESPONSE_PUT:
  284.                       return newPutResult(

#63
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MetadataDrivers.java:294: error: Null Dereference
  object `schemeParts` last assigned on line 293 could be null and is dereferenced at line 294.
  292.           scheme = scheme.toLowerCase();
  293.           String[] schemeParts = StringUtils.split(scheme, '+');
  294. >         checkArgument(schemeParts.length > 0,
  295.                   "Invalid metadata service scheme found : " + uri);
  296.           return getBookieDriver(schemeParts[0]);

#64
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java:314: error: Resource Leak
  resource of type `org.apache.bookkeeper.util.LocalBookKeeper` acquired by call to `new()` at line 306 is not released after line 314.
  312.                   if (zkDataDirFile.exists() && zkDataDirFile.isFile()) {
  313.                       throw new IOException("Unable to create zkDataDir, since there is a file at "
  314. >                             + zkDataDirFile.getAbsolutePath());
  315.                   }
  316.                   if (!zkDataDirFile.exists() && !zkDataDirFile.mkdirs()) {

#65
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java:317: error: Resource Leak
  resource of type `org.apache.bookkeeper.util.LocalBookKeeper` acquired by call to `new()` at line 306 is not released after line 317.
  315.                   }
  316.                   if (!zkDataDirFile.exists() && !zkDataDirFile.mkdirs()) {
  317. >                     throw new IOException("Unable to create zkDataDir - " + zkDataDirFile.getAbsolutePath());
  318.                   }
  319.               }

#66
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java:324: error: Resource Leak
  resource of type `org.apache.bookkeeper.util.LocalBookKeeper` acquired to `lb` by call to `new()` at line 306 is not released after line 324.
**Note**: potential exception at line 320
  322.           }
  323.   
  324. >         return lb;
  325.       }
  326.   

#67
stream/distributedlog/core/src/main/java/org/apache/distributedlog/auditor/DLAuditor.java:300: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `get()` at line 300 is not released after line 300.
  298.               String rootPath = uri.getPath() + "/" + allocationPath;
  299.               try {
  300. >                 List<String> pools = getZooKeeperClient(namespace).get().getChildren(rootPath, false);
  301.                   for (String pool : pools) {
  302.                       poolQueue.add(rootPath + "/" + pool);

#68
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java:304: error: Resource Leak
  resource of type `org.apache.bookkeeper.client.BookKeeper` acquired by call to `createBookKeeperClientThrowUnavailableException(...)` at line 307 is not released after line 304.
  302.                      StatsLogger statsLogger)
  303.           throws UnavailableException {
  304. >         this(
  305.               bookieIdentifier,
  306.               conf,

#69
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java:314: error: Null Dereference
  object returned by `header.getOperation()` could be null and is dereferenced at line 314.
  312.               try {
  313.                   BookkeeperProtocol.BKPacketHeader header = r.getHeader();
  314. >                 switch (header.getOperation()) {
  315.                       case ADD_ENTRY:
  316.                           processAddRequestV3(r, c);

#70
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MSLedgerManagerFactory.java:310: error: Null Dereference
  object returned by `key2LedgerId(e.getKey())` could be null and is dereferenced at line 310.
  308.           @Override
  309.           public void process(MSWatchedEvent e){
  310. >             long ledgerId = key2LedgerId(e.getKey());
  311.               switch(e.getType()) {
  312.               case CHANGED:

#71
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/kv/TableStoreImpl.java:310: error: Null Dereference
  object returned by `reqOp.getRequestCase()` could be null and is dereferenced at line 310.
  308.   
  309.       private Op<byte[], byte[]> buildTxnOp(RoutingHeader header, RequestOp reqOp) {
  310. >         switch (reqOp.getRequestCase()) {
  311.               case REQUEST_PUT:
  312.                   return buildPutOp(header, reqOp.getRequestPut());

#72
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/store/Command.java:321: error: Null Dereference
  object returned by `getReqCase()` could be null and is dereferenced at line 321.
  319.       org.apache.bookkeeper.stream.proto.kv.store.Command other = (org.apache.bookkeeper.stream.proto.kv.store.Command) obj;
  320.   
  321. >     if (!getReqCase().equals(other.getReqCase())) return false;
  322.       switch (reqCase_) {
  323.         case 1:

#73
stream/distributedlog/core/src/main/java/org/apache/distributedlog/auditor/DLAuditor.java:332: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `get()` at line 331 is not released after line 332.
  330.                       throws InterruptedException, ZooKeeperClient.ZooKeeperConnectionException, KeeperException {
  331.                   List<String> allocators = getZooKeeperClient(namespace).get()
  332. >                                         .getChildren(poolPath, false);
  333.                   for (String allocator : allocators) {
  334.                       String allocatorPath = poolPath + "/" + allocator;

#74
stream/distributedlog/core/src/main/java/org/apache/distributedlog/auditor/DLAuditor.java:335: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `get()` at line 335 is not released after line 335.
  333.                   for (String allocator : allocators) {
  334.                       String allocatorPath = poolPath + "/" + allocator;
  335. >                     byte[] data = getZooKeeperClient(namespace).get().getData(allocatorPath, false, new Stat());
  336.                       if (null != data && data.length > 0) {
  337.                           try {

#75
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/Main.java:343: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.StatsProviderService` acquired by call to `StatsProviderService(...)` at line 343 is not released after line 343.
**Note**: potential exception at line 343
  341.   
  342.           // 1. build stats provider
  343. >         StatsProviderService statsProviderService =
  344.               new StatsProviderService(conf);
  345.           StatsLogger rootStatsLogger = statsProviderService.getStatsProvider().getStatsLogger("");

#76
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/Main.java:512: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.StatsProviderService` acquired to `statsProviderService` by call to `StatsProviderService(...)` at line 343 is not released after line 512.
**Note**: potential exception at line 350
  510.           }
  511.   
  512. >         return serverBuilder.build();
  513.       }
  514.   

#77
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java:370: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.AutoRecoveryService` acquired by call to `AutoRecoveryService(...)` at line 370 is not released after line 370.
**Note**: potential exception at line 370
  368.   
  369.           // 2. build AutoRecovery server
  370. >         AutoRecoveryService autoRecoveryService = new AutoRecoveryService(conf, rootStatsLogger);
  371.   
  372.           serverBuilder.addComponent(autoRecoveryService);

#78
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java:363: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.StatsProviderService` acquired by call to `StatsProviderService(...)` at line 363 is not released after line 363.
**Note**: potential exception at line 363
  361.   
  362.           // 1. build stats provider
  363. >         StatsProviderService statsProviderService = new StatsProviderService(conf);
  364.           StatsLogger rootStatsLogger = statsProviderService.getStatsProvider().getStatsLogger("");
  365.   

#79
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java:387: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.StatsProviderService` acquired to `statsProviderService` by call to `StatsProviderService(...)` at line 363 is not released after line 387.
**Note**: potential exception at line 370
  385.           }
  386.   
  387. >         return serverBuilder.build();
  388.       }
  389.   }

#80
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java:383: error: Null Dereference
  object `fragments` last assigned on line 375 could be null and is dereferenced at line 383.
  381.               boolean foundOpenFragments = false;
  382.               long numFragsReplicated = 0;
  383. >             for (LedgerFragment ledgerFragment : fragments) {
  384.                   if (!ledgerFragment.isClosed()) {
  385.                       foundOpenFragments = true;

#81
stream/server/src/main/java/org/apache/bookkeeper/stream/server/StorageServer.java:399: error: Resource Leak
  resource of type `org.apache.bookkeeper.stream.storage.impl.cluster.ZkClusterMetadataStore` acquired by call to `new()` at line 395 is not released after line 399.
  397.                   regService.get(),
  398.                   new DefaultStorageContainerController(),
  399. >                 new ZkClusterControllerLeaderSelector(curatorProviderService.get(), ZK_METADATA_ROOT_PATH),
  400.                   storageConf),
  401.               rootStatsLogger.scope("cluster_controller"));

#82
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java:411: error: Null Dereference
  object `bookies` last assigned on line 410 could be null and is dereferenced at line 411.
  409.           Collection<BookieId> bookies;
  410.           bookies = bk.bookieWatcher.getBookies();
  411. >         bookies.addAll(bk.bookieWatcher.getReadOnlyBookies());
  412.           if (bookies.isEmpty()) {
  413.               return map;

#83
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:456: error: Null Dereference
  object `candidateNode` last assigned on line 455 could be null and is dereferenced at line 456.
  454.           for (int i = 0; i < ensembleSize; i++) {
  455.               BookieNode candidateNode = selectCandidateNode(bookiesToConsider);
  456. >             newEnsemble.set(i, candidateNode.getAddr());
  457.               bookiesToConsider.remove(candidateNode);
  458.           }

#84
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/storage/GetStreamRequest.java:448: error: Null Dereference
  object returned by `other.getIdCase()` could be null and is dereferenced at line 448.
  446.       public Builder mergeFrom(org.apache.bookkeeper.stream.proto.storage.GetStreamRequest other) {
  447.         if (other == org.apache.bookkeeper.stream.proto.storage.GetStreamRequest.getDefaultInstance()) return this;
  448. >       switch (other.getIdCase()) {
  449.           case STREAM_NAME: {
  450.             mergeStreamName(other.getStreamName());

#85
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:475: error: Null Dereference
  object returned by `selectCandidateNode(bookiesToConsider)` could be null and is dereferenced at line 475.
  473.               throw new BKNotEnoughBookiesException();
  474.           }
  475. >         BookieId candidateAddr = (selectCandidateNode(bookiesToConsider)).getAddr();
  476.           newEnsemble.set(bookieToReplaceIndex, candidateAddr);
  477.           return PlacementResult.of(candidateAddr,

#86
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexInMemPageMgr.java:512: error: Resource Leak
  resource of type `org.apache.bookkeeper.bookie.LedgerEntryPage` acquired to `lep` by call to `new()` at line 499 is not released after line 512.
**Note**: potential exception at line 500
  510.                       ledger, entry);
  511.               flushOneOrMoreLedgers(false);
  512. >         }
  513.       }
  514.   

#87
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java:503: error: Null Dereference
  object `available` last assigned on line 501 could be null and is dereferenced at line 503.
  501.           Collection<BookieId> available = admin.getAvailableBookies();
  502.           for (BookieId b : finalEnsemble) {
  503. >             if (!available.contains(b)) {
  504.                   if (LOG.isDebugEnabled()) {
  505.                       LOG.debug("Bookie {} is missing from the list of Available Bookies. ledger {}:ensemble {}.",

#88
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/SplitPolicy.java:498: error: Null Dereference
  object returned by `other.getPolicyCase()` could be null and is dereferenced at line 498.
  496.           setTypeValue(other.getTypeValue());
  497.         }
  498. >       switch (other.getPolicyCase()) {
  499.           case FIXED_RANGE_POLICY: {
  500.             mergeFixedRangePolicy(other.getFixedRangePolicy());

#89
stream/distributedlog/core/src/main/java/org/apache/distributedlog/auditor/DLAuditor.java:510: error: Null Dereference
  object returned by `bkc.get()` could be null and is dereferenced by call to `getLedgerManager(...)` at line 510.
  508.           final AtomicLong numLedgers = new AtomicLong(0);
  509.   
  510. >         LedgerManager lm = BookKeeperAccessor.getLedgerManager(bkc.get());
  511.   
  512.           final CompletableFuture<Void> doneFuture = FutureUtils.createFuture();

#90
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java:536: error: Resource Leak
  resource of type `java.io.RandomAccessFile` acquired by call to `RandomAccessFile(...)` at line 521 is not released after line 536.
  534.           } finally {
  535.               newFc.force(true);
  536. >             newFc.close();
  537.           }
  538.           // delete old.idx

#91
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/RequestOp.java:520: error: Null Dereference
  object returned by `other.getRequestCase()` could be null and is dereferenced at line 520.
  518.       public Builder mergeFrom(org.apache.bookkeeper.stream.proto.kv.rpc.RequestOp other) {
  519.         if (other == org.apache.bookkeeper.stream.proto.kv.rpc.RequestOp.getDefaultInstance()) return this;
  520. >       switch (other.getRequestCase()) {
  521.           case REQUEST_RANGE: {
  522.             mergeRequestRange(other.getRequestRange());

#92
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/ResponseOp.java:520: error: Null Dereference
  object returned by `other.getResponseCase()` could be null and is dereferenced at line 520.
  518.       public Builder mergeFrom(org.apache.bookkeeper.stream.proto.kv.rpc.ResponseOp other) {
  519.         if (other == org.apache.bookkeeper.stream.proto.kv.rpc.ResponseOp.getDefaultInstance()) return this;
  520. >       switch (other.getResponseCase()) {
  521.           case RESPONSE_RANGE: {
  522.             mergeResponseRange(other.getResponseRange());

#93
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java:554: error: Null Dereference
  object `fragments` last assigned on line 553 could be null and is dereferenced at line 554.
  552.                           Set<LedgerFragment> fragments =
  553.                               getUnderreplicatedFragments(lh, conf.getAuditorLedgerVerificationPercentage());
  554. >                         for (LedgerFragment fragment : fragments) {
  555.                               if (!fragment.isClosed()) {
  556.                                   // Need recovery open, close the old ledger handle.

#94
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:560: error: Null Dereference
  object `bookiesToConsiderAfterExcludingZonesAndUDs` last assigned on line 549 could be null and is dereferenced at line 560.
  558.               }
  559.           }
  560. >         if (bookiesToConsiderAfterExcludingZonesAndUDs.isEmpty()) {
  561.               zonesToExclude = getZonesToExcludeToMaintainMinZones(currentEnsemble, bookieToReplaceIndex,
  562.                       writeQuorumSize);

#95
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:572: error: Null Dereference
  object returned by `selectCandidateNode(bookiesToConsiderAfterExcludingZonesAndUDs)` could be null and is dereferenced at line 572.
  570.           }
  571.   
  572. >         BookieId candidateAddr = selectCandidateNode(bookiesToConsiderAfterExcludingZonesAndUDs).getAddr();
  573.           newEnsemble.set(bookieToReplaceIndex, candidateAddr);
  574.           return candidateAddr;

#96
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/Compare.java:630: error: Null Dereference
  object returned by `getTargetUnionCase()` could be null and is dereferenced at line 630.
  628.       if (!getKey()
  629.           .equals(other.getKey())) return false;
  630. >     if (!getTargetUnionCase().equals(other.getTargetUnionCase())) return false;
  631.       switch (targetUnionCase_) {
  632.         case 4:

#97
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/store/Command.java:636: error: Null Dereference
  object returned by `other.getReqCase()` could be null and is dereferenced at line 636.
  634.       public Builder mergeFrom(org.apache.bookkeeper.stream.proto.kv.store.Command other) {
  635.         if (other == org.apache.bookkeeper.stream.proto.kv.store.Command.getDefaultInstance()) return this;
  636. >       switch (other.getReqCase()) {
  637.           case NOP_REQ: {
  638.             mergeNopReq(other.getNopReq());

#98
stream/statelib/target/generated-sources/protobuf/java/org/apache/bookkeeper/proto/statestore/kv/Command.java:636: error: Null Dereference
  object returned by `other.getReqCase()` could be null and is dereferenced at line 636.
  634.       public Builder mergeFrom(org.apache.bookkeeper.proto.statestore.kv.Command other) {
  635.         if (other == org.apache.bookkeeper.proto.statestore.kv.Command.getDefaultInstance()) return this;
  636. >       switch (other.getReqCase()) {
  637.           case NOP_REQ: {
  638.             mergeNopReq(other.getNopReq());

#99
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:652: error: Null Dereference
  object `realRange` last assigned on line 651 could be null and is dereferenced at line 652.
  650.               } else {
  651.                   Pair<byte[], byte[]> realRange = getRealRange(key, endKey);
  652. >                 endKey = realRange.getRight();
  653.                   ++endKey[endKey.length - 1];
  654.                   batch.deleteRange(realRange.getLeft(), endKey);

#100
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/HardLink.java:653: error: Null Dereference
  object returned by `getProperty("os.name")` could be null and is dereferenced at line 653.
  651.     public static String makeShellPath(File file) throws IOException {
  652.       String filename = file.getCanonicalPath();
  653. >     if (System.getProperty("os.name").startsWith("Windows")) {
  654.         BufferedReader r = null;
  655.         try {

#101
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:687: error: Null Dereference
  object `realRange` last assigned on line 686 could be null and is dereferenced at line 687.
  685.           } else {
  686.               Pair<byte[], byte[]> realRange = getRealRange(rawKey, rawEndKey);
  687. >             rawKey = realRange.getLeft();
  688.               rawEndKey = realRange.getRight();
  689.   

#102
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:709: error: Null Dereference
  object returned by `excludingUDsOfZonesToConsider.get(nodeLocation.getZone())` could be null and is dereferenced at line 709.
  707.           for (BookieNode bookieToConsider : bookiesToConsider) {
  708.               ZoneAwareNodeLocation nodeLocation = getZoneAwareNodeLocation(bookieToConsider);
  709. >             if (excludingUDsOfZonesToConsider.get(nodeLocation.getZone()).contains(nodeLocation.getUpgradeDomain())) {
  710.                   continue;
  711.               }

#103
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:758: error: Resource Leak
  resource of type `org.rocksdb.WriteBatch` acquired by call to `new()` at line 744 is not released after line 758.
**Note**: potential exception at line 746
  756.   
  757.               return txnResult;
  758. >         } catch (StateStoreRuntimeException e) {
  759.               results.forEach(Result::close);
  760.               throw e;

#104
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:752: error: Null Dereference
  object returned by `newNode.getNetworkLocation()` could be null and is dereferenced at line 752.
  750.                           // refresh the rack info if its a known bookie
  751.                           BookieNode newNode = createBookieNode(bookieAddress);
  752. >                         if (!newNode.getNetworkLocation().equals(node.getNetworkLocation())) {
  753.                               topology.remove(node);
  754.                               topology.add(newNode);

#105
stream/distributedlog/core/src/main/java/org/apache/distributedlog/admin/DistributedLogAdmin.java:787: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `delete(...)` at line 787 is not released after line 787.
  785.               }
  786.               String zkPath = getUri() + "/" + bkdlConfig.getACLRootPath() + "/" + stream;
  787. >             ZKAccessControl.delete(getZooKeeperClient(), zkPath);
  788.               return 0;
  789.           }

#106
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:790: error: Null Dereference
  object `record` could be null and is dereferenced at line 790.
  788.           switch (op.target()) {
  789.               case MOD:
  790. >                 cmp = record.compareModRev(op.revision());
  791.                   break;
  792.               case CREATE:

#107
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:793: error: Null Dereference
  object `record` could be null and is dereferenced at line 793.
  791.                   break;
  792.               case CREATE:
  793. >                 cmp = record.compareCreateRev(op.revision());
  794.                   break;
  795.               case VERSION:

#108
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:796: error: Null Dereference
  object `record` could be null and is dereferenced at line 796.
  794.                   break;
  795.               case VERSION:
  796. >                 cmp = record.compareVersion(op.revision());
  797.                   break;
  798.               case VALUE:

#109
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:806: error: Null Dereference
  object returned by `readEntriesInternalAsync(firstEntry,lastEntry,isRecoveryRead)` could be null and is dereferenced at line 806.
  804.           if (!clientCtx.isClientClosed()) {
  805.               readEntriesInternalAsync(firstEntry, lastEntry, isRecoveryRead)
  806. >                 .whenCompleteAsync(new FutureEventListener<LedgerEntries>() {
  807.                       @Override
  808.                       public void onSuccess(LedgerEntries entries) {

#110
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:922: error: Null Dereference
  object `numOfNodesInAZone` last assigned on line 921 could be null and is dereferenced at line 922.
  920.                           udsOfThisZoneInThisWriteSet.add(upgradeDomain);
  921.                           Integer numOfNodesInAZone = numOfBookiesInZones.get(zone);
  922. >                         numOfBookiesInZones.put(zone, (numOfNodesInAZone + 1));
  923.                       }
  924.                   }

#111
stream/distributedlog/core/src/main/java/org/apache/distributedlog/admin/DistributedLogAdmin.java:900: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `getZKAccessControl(...)` at line 900 is not released after line 900.
  898.               }
  899.               String zkPath = getZKPath(getUri().getPath() + "/" + bkdlConfig.getACLRootPath());
  900. >             ZKAccessControl accessControl = getZKAccessControl(getZooKeeperClient(), zkPath);
  901.               AccessControlEntry acl = accessControl.getAccessControlEntry();
  902.               acl.setDenyWrite(denyWrite);

#112
stream/distributedlog/core/src/main/java/org/apache/distributedlog/admin/DistributedLogAdmin.java:907: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `setZKAccessControl(...)` at line 907 is not released after line 907.
  905.               acl.setDenyAcquire(denyAcquire);
  906.               acl.setDenyRelease(denyRelease);
  907. >             setZKAccessControl(getZooKeeperClient(), accessControl);
  908.               return 0;
  909.           }

#113
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/Compare.java:926: error: Null Dereference
  object returned by `other.getTargetUnionCase()` could be null and is dereferenced at line 926.
  924.           setKey(other.getKey());
  925.         }
  926. >       switch (other.getTargetUnionCase()) {
  927.           case VERSION: {
  928.             setVersion(other.getVersion());

#114
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:968: error: Null Dereference
  object `udsOfThisZone` last assigned on line 967 could be null and is dereferenced at line 968.
  966.               if (numOfNodesInThisZone > 1) {
  967.                   Set<String> udsOfThisZone = nodesLocationInWriteSet.get(zone);
  968. >                 if (udsOfThisZone.size() < 2) {
  969.                       return false;
  970.                   }

#115
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:1006: error: Null Dereference
  object `realRange` last assigned on line 1005 could be null and is dereferenced at line 1006.
  1004.           }
  1005.           Pair<byte[], byte[]> realRange = getRealRange(rawKey, rawEndKey);
  1006. >         rawKey = realRange.getLeft();
  1007.           rawEndKey = realRange.getRight();
  1008.   

#116
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java:1088: error: Null Dereference
  object `availableBkAddresses` last assigned on line 1086 could be null and is dereferenced at line 1088.
  1086.           Collection<BookieId> availableBkAddresses = admin.getAvailableBookies();
  1087.           Collection<BookieId> readOnlyBkAddresses = admin.getReadOnlyBookies();
  1088. >         availableBkAddresses.addAll(readOnlyBkAddresses);
  1089.   
  1090.           List<String> availableBookies = new ArrayList<String>();

#117
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BKLogWriteHandler.java:1119: error: Null Dereference
  object `partialTruncate` last assigned on line 1093 could be null and is dereferenced by call to `setLogSegmentTruncationStatus(...)` at line 1119.
  1117.               }
  1118.           }
  1119. >         return setLogSegmentTruncationStatus(truncateList, partialTruncate, dlsn);
  1120.       }
  1121.   

#118
stream/distributedlog/core/src/main/java/org/apache/distributedlog/tools/DistributedLogTool.java:1275: error: Null Dereference
  object returned by `DistributedLogTool$DeleteLedgersCommand$1.this$0.getBookKeeperClient().get()` could be null and is dereferenced at line 1275.
  1273.                                   }
  1274.                                   try {
  1275. >                                     getBookKeeperClient().get().deleteLedger(ledger);
  1276.                                       int numLedgersDeleted = numLedgers.incrementAndGet();
  1277.                                       if (numLedgersDeleted % 1000 == 0) {

#119
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java:1462: error: Null Dereference
  object `cmd.bka` last assigned on line 1461 could be null and is dereferenced by call to `apply(...)` at line 1462.
  1460.               CliFlags flags = new CliFlags();
  1461.               WhoIsAuditorCommand cmd = new WhoIsAuditorCommand();
  1462. >             boolean result = cmd.apply(bkConf, flags);
  1463.               return result ? 0 : -1;
  1464.           }

#120
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1598: error: Resource Leak
  resource of type `org.apache.bookkeeper.client.ReadLastConfirmedAndEntryOp$ParallelReadRequest` acquired by call to `initiate()` at line 1598 is not released after line 1598.
  1596.           new ReadLastConfirmedAndEntryOp(this, clientCtx, getCurrentEnsemble(), innercb, entryId - 1, timeOutInMillis)
  1597.               .parallelRead(parallel)
  1598. >             .initiate();
  1599.       }
  1600.   

#121
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1598: error: Resource Leak
  resource of type `org.apache.bookkeeper.client.ReadLastConfirmedAndEntryOp$SequenceReadRequest` acquired by call to `initiate()` at line 1598 is not released after line 1598.
  1596.           new ReadLastConfirmedAndEntryOp(this, clientCtx, getCurrentEnsemble(), innercb, entryId - 1, timeOutInMillis)
  1597.               .parallelRead(parallel)
  1598. >             .initiate();
  1599.       }
  1600.   

#122
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java:1574: error: Null Dereference
  object returned by `getAvailableBookies()` could be null and is dereferenced at line 1574.
  1572.               throws CompatibilityException, UnavailableException, KeeperException, InterruptedException, IOException,
  1573.               BKAuditException, TimeoutException, BKException {
  1574. >         if (getAvailableBookies().contains(bookieAddress) || getReadOnlyBookies().contains(bookieAddress)) {
  1575.               LOG.error("Bookie: {} is not shutdown yet", bookieAddress);
  1576.               throw BKException.create(BKException.Code.IllegalOpException);

#123
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java:1574: error: Null Dereference
  object returned by `getReadOnlyBookies()` could be null and is dereferenced at line 1574.
  1572.               throws CompatibilityException, UnavailableException, KeeperException, InterruptedException, IOException,
  1573.               BKAuditException, TimeoutException, BKException {
  1574. >         if (getAvailableBookies().contains(bookieAddress) || getReadOnlyBookies().contains(bookieAddress)) {
  1575.               LOG.error("Bookie: {} is not shutdown yet", bookieAddress);
  1576.               throw BKException.create(BKException.Code.IllegalOpException);

#124
stream/distributedlog/core/src/main/java/org/apache/distributedlog/tools/DistributedLogTool.java:1690: error: Null Dereference
  object returned by `bkc.get()` could be null and is dereferenced by call to `BookKeeperAdmin(...)` at line 1690.
  1688.                                            BookKeeperClient bkc,
  1689.                                            List<LogSegmentMetadata> segments) throws Exception {
  1690. >             BookKeeperAdmin bkAdmin = new BookKeeperAdmin(bkc.get());
  1691.               try {
  1692.                   MetadataUpdater metadataUpdater = LogSegmentMetadataStoreUpdater.createMetadataUpdater(

#125
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClientImpl.java:122: warning: Thread Safety Violation
  Unprotected write. Non-private method `BookieClientImpl(...)` indirectly mutates container `util.ReflectionUtils.constructorCache` via call to `Map.put(...)` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  120.           this.bookieAddressResolver = bookieAddressResolver;
  121.           this.registry = ExtensionRegistry.newInstance();
  122. >         this.authProviderFactory = AuthProviderFactoryFactory.newClientAuthProviderFactory(conf);
  123.   
  124.           this.statsLogger = statsLogger;

#126
bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopologyImpl.java:410: warning: Thread Safety Violation
  Read/Write race. Non-private method `NetworkTopologyImpl.add(...)` indirectly reads without synchronization from `this.numOfRacks`. Potentially races with write in method `NetworkTopologyImpl.remove(...)`.
 Reporting because this access may occur on a background thread.
  408.               return;
  409.           }
  410. >         String oldTopoStr = this.toString();
  411.           if (node instanceof InnerNode) {
  412.               throw new IllegalArgumentException("Not allow to add an inner node: " + NodeBase.getPath(node));

#127
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BKLogSegmentWriter.java:1189: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKLogSegmentWriter.addComplete(...)` reads without synchronization from `this.lastEntryId`. Potentially races with write in method `BKLogSegmentWriter.addComplete(...)`.
 Reporting because this access may occur on a background thread.
  1187.   
  1188.           // Sanity check to make sure we're receiving these callbacks in order.
  1189. >         if (entryId > -1 && lastEntryId >= entryId) {
  1190.               LOG.error("Log segment {} saw out of order entry {} lastEntryId {}",
  1191.                   fullyQualifiedLogSegment, entryId, lastEntryId);

#128
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BKLogSegmentWriter.java:1193: warning: Thread Safety Violation
  Unprotected write. Non-private method `BKLogSegmentWriter.addComplete(...)` writes to field `this.lastEntryId` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1191.                   fullyQualifiedLogSegment, entryId, lastEntryId);
  1192.           }
  1193. >         lastEntryId = entryId;
  1194.   
  1195.           assert (ctx instanceof BKTransmitPacket);

#129
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:920: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.addEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  918.        */
  919.       public long addEntry(byte[] data) throws InterruptedException, BKException {
  920. >         return addEntry(data, 0, data.length);
  921.       }
  922.   

#130
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:970: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.addEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  968.   
  969.           SyncAddCallback callback = new SyncAddCallback();
  970. >         asyncAddEntry(data, offset, length, callback, null);
  971.   
  972.           return SyncCallbackUtils.waitForResult(callback);

#131
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:929: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.appendAsync(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  927.       public CompletableFuture<Long> appendAsync(ByteBuf data) {
  928.           SyncAddCallback callback = new SyncAddCallback();
  929. >         asyncAddEntry(data, callback, null);
  930.           return callback;
  931.       }

#132
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicyImpl.java:1077: warning: Thread Safety Violation
  Read/Write race. Non-private method `RackawareEnsemblePlacementPolicyImpl.areAckedBookiesAdheringToPlacementPolicy(...)` reads without synchronization from `this.minNumRacksPerWriteQuorum`. Potentially races with write in method `RackawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  1075.                                                               int ackQuorumSize) {
  1076.           HashSet<String> rackCounter = new HashSet<>();
  1077. >         int minWriteQuorumNumRacksPerWriteQuorum = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);
  1078.   
  1079.           ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();

#133
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:980: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZoneawareEnsemblePlacementPolicyImpl.areAckedBookiesAdheringToPlacementPolicy(...)` reads without synchronization from `this.minNumZonesPerWriteQuorum`. Potentially races with write in method `ZoneawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  978.               int ackQuorumSize) {
  979.           HashSet<String> zonesOfAckedBookies = new HashSet<>();
  980. >         int minNumZonesPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumZonesPerWriteQuorum);
  981.           boolean areAckedBookiesAdheringToPlacementPolicy = false;
  982.           ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();

#134
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1062: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncAddEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1060.   
  1061.       public void asyncAddEntry(ByteBuf data, final AddCallback cb, final Object ctx) {
  1062. >         PendingAddOp op = PendingAddOp.create(this, clientCtx, getCurrentEnsemble(), data, writeFlags, cb, ctx);
  1063.           doAsyncAddEntry(op);
  1064.       }

#135
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1058: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncAddEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1056.           }
  1057.   
  1058. >         asyncAddEntry(Unpooled.wrappedBuffer(data, offset, length), cb, ctx);
  1059.       }
  1060.   

#136
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1010: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncAddEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1008.       public void asyncAddEntry(final byte[] data, final AddCallback cb,
  1009.                                 final Object ctx) {
  1010. >         asyncAddEntry(data, 0, data.length, cb, ctx);
  1011.       }
  1012.   

#137
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:699: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadEntries(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  697.           }
  698.   
  699. >         asyncReadEntriesInternal(firstEntry, lastEntry, cb, ctx, false);
  700.       }
  701.   

#138
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:805: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadEntriesInternal(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  803.                                     Object ctx, boolean isRecoveryRead) {
  804.           if (!clientCtx.isClientClosed()) {
  805. >             readEntriesInternalAsync(firstEntry, lastEntry, isRecoveryRead)
  806.                   .whenCompleteAsync(new FutureEventListener<LedgerEntries>() {
  807.                       @Override

#139
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1739: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadExplicitLastConfirmed(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1737.               }
  1738.           };
  1739. >         new PendingReadLacOp(this, clientCtx.getBookieClient(), getCurrentEnsemble(), innercb).initiate();
  1740.       }
  1741.   

#140
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1403: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadLastConfirmed(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1401.           if (clientCtx.getConf().useV2WireProtocol) {
  1402.               // in v2 protocol we don't support readLAC RPC
  1403. >             asyncReadPiggybackLastConfirmed(cb, ctx);
  1404.           } else {
  1405.               asyncReadExplicitLastConfirmed(cb, ctx);

#141
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1563: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadLastConfirmedAndEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1561.           }
  1562.           if (entryId <= lac) {
  1563. >             asyncReadEntries(entryId, entryId, new ReadCallback() {
  1564.                   @Override
  1565.                   public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {

#142
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:850: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadLastEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  848.               cb.readComplete(BKException.Code.NoSuchEntryException, this, null, ctx);
  849.           } else {
  850. >             asyncReadEntriesInternal(lastEntryId, lastEntryId, cb, ctx, false);
  851.           }
  852.       }

#143
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:738: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadUnconfirmedEntries(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  736.           }
  737.   
  738. >         asyncReadEntriesInternal(firstEntry, lastEntry, cb, ctx, false);
  739.       }
  740.   

#144
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1215: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncRecoveryAddEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1213.       void asyncRecoveryAddEntry(final byte[] data, final int offset, final int length,
  1214.                                  final AddCallback cb, final Object ctx) {
  1215. >         PendingAddOp op = PendingAddOp.create(this, clientCtx, getCurrentEnsemble(),
  1216.                                                 Unpooled.wrappedBuffer(data, offset, length),
  1217.                                                 writeFlags, cb, ctx)

#145
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1486: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncTryReadLastConfirmed(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1484.               }
  1485.           };
  1486. >         new TryReadLastConfirmedOp(this, clientCtx.getBookieClient(), getCurrentEnsemble(),
  1487.                                      innercb, getLastAddConfirmed()).initiate();
  1488.       }

#146
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:155: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.checkStoreOpen()` reads without synchronization from `this.name`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  153.       protected void checkStoreOpen() {
  154.           if (closed) {
  155. >             throw new InvalidStateStoreException("State store " + name + " is already closed");
  156.           }
  157.           if (!isInitialized) {

#147
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/SingleDirectoryDbLedgerStorage.java:701: warning: Thread Safety Violation
  Read/Write race. Non-private method `SingleDirectoryDbLedgerStorage.checkpoint(...)` reads without synchronization from `this.checkpointSource`. Potentially races with write in method `SingleDirectoryDbLedgerStorage.setCheckpointSource(...)`.
 Reporting because this access may occur on a background thread.
  699.       @Override
  700.       public void checkpoint(Checkpoint checkpoint) throws IOException {
  701. >         Checkpoint thisCheckpoint = checkpointSource.newCheckpoint();
  702.           if (lastCheckpoint.compareTo(checkpoint) > 0) {
  703.               return;

#148
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/SingleDirectoryDbLedgerStorage.java:702: warning: Thread Safety Violation
  Read/Write race. Non-private method `SingleDirectoryDbLedgerStorage.checkpoint(...)` reads without synchronization from `this.lastCheckpoint`. Potentially races with write in method `SingleDirectoryDbLedgerStorage.checkpoint(...)`.
 Reporting because this access may occur on a background thread.
  700.       public void checkpoint(Checkpoint checkpoint) throws IOException {
  701.           Checkpoint thisCheckpoint = checkpointSource.newCheckpoint();
  702. >         if (lastCheckpoint.compareTo(checkpoint) > 0) {
  703.               return;
  704.           }

#149
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:385: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.close()` indirectly reads without synchronization from `this.allocator`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  383.               return;
  384.           }
  385. >         doClose();
  386.       }
  387.   

#150
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/store/MVCCStoreFactoryImpl.java:284: warning: Thread Safety Violation
  Read/Write race. Non-private method `MVCCStoreFactoryImpl.close()` reads without synchronization from `this.checkpointStore`. Potentially races with write in method `MVCCStoreFactoryImpl.newStore(...)`.
 Reporting because this access may occur on a background thread.
  282.               log.info("Encountered issue on closing all the range stores opened by this range factory");
  283.           }
  284. >         if (null != checkpointStore) {
  285.               checkpointStore.close();
  286.               checkpointStore = null;

#151
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/store/MVCCStoreFactoryImpl.java:286: warning: Thread Safety Violation
  Unprotected write. Non-private method `MVCCStoreFactoryImpl.close()` writes to field `this.checkpointStore` outside of synchronization.
 Reporting because this access may occur on a background thread.
  284.           if (null != checkpointStore) {
  285.               checkpointStore.close();
  286. >             checkpointStore = null;
  287.           }
  288.   

#152
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataBookieDriver.java:73: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKMetadataBookieDriver.close()` indirectly reads without synchronization from `this.ownZKHandle`. Potentially races with write in method `ZKMetadataBookieDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  71.       @Override
  72.       public void close() {
  73. >         super.close();
  74.       }
  75.   }

#153
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataDriverBase.java:331: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKMetadataDriverBase.close()` reads without synchronization from `this.lmFactory`. Potentially races with write in method `ZKMetadataDriverBase.getLedgerManagerFactory()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  329.       @Override
  330.       public void close() {
  331. >         if (null != lmFactory) {
  332.               try {
  333.                   lmFactory.close();

#154
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataDriverBase.java:337: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKMetadataDriverBase.close()` writes to field `this.lmFactory` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  335.                   log.warn("Failed to close zookeeper based ledger manager", e);
  336.               }
  337. >             lmFactory = null;
  338.           }
  339.           if (ownZKHandle && null != zk) {

#155
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/journal/AbstractStateStoreWithJournal.java:461: warning: Thread Safety Violation
  Read/Write race. Non-private method `AbstractStateStoreWithJournal.closeAsync()` indirectly reads without synchronization from `this.name`. Potentially races with write in method `AbstractStateStoreWithJournal.init(...)`.
 Reporting because this access may occur on a background thread.
  459.           if (null != checkpointTask) {
  460.               if (!checkpointTask.cancel(true)) {
  461. >                 log.warn("Fail to cancel checkpoint task of state store {}", name());
  462.               }
  463.           }

#156
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/journal/AbstractStateStoreWithJournal.java:465: warning: Thread Safety Violation
  Read/Write race. Non-private method `AbstractStateStoreWithJournal.closeAsync()` reads without synchronization from `this.writeIOScheduler`. Potentially races with write in method `AbstractStateStoreWithJournal.init(...)`.
 Reporting because this access may occur on a background thread.
  463.           }
  464.           // wait until last checkpoint task completed
  465. >         writeIOScheduler.submit(() -> {
  466.               log.info("closing async state store {}", name);
  467.               FutureUtils.ensure(

#157
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:481: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.closeLocalDB()` reads without synchronization from `this.dataCfHandle`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  479.   
  480.           RocksUtils.close(metaCfHandle);
  481. >         RocksUtils.close(dataCfHandle);
  482.           RocksUtils.close(db);
  483.       }

#158
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:480: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.closeLocalDB()` reads without synchronization from `this.metaCfHandle`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  478.           }
  479.   
  480. >         RocksUtils.close(metaCfHandle);
  481.           RocksUtils.close(dataCfHandle);
  482.           RocksUtils.close(db);

#159
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:482: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.closeLocalDB()` reads without synchronization from `this.db`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  480.           RocksUtils.close(metaCfHandle);
  481.           RocksUtils.close(dataCfHandle);
  482. >         RocksUtils.close(db);
  483.       }
  484.   

#160
bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java:69: warning: Thread Safety Violation
  Read/Write race. Non-private method `InMemoryMetastoreTable$MetadataVersion.compare(...)` reads without synchronization from `this.version`. Potentially races with write in method `InMemoryMetastoreTable$MetadataVersion.incrementVersion()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  67.               }
  68.               MetadataVersion mv = (MetadataVersion) v;
  69. >             int res = version - mv.version;
  70.               if (res == 0) {
  71.                   return Occurred.CONCURRENTLY;

#161
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java:446: warning: Thread Safety Violation
  Unprotected write. Non-private method `PendingReadOp$SequenceReadRequest.complete(...)` indirectly writes to field `this.rc` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  444.           @Override
  445.           boolean complete(int bookieIndex, BookieId host, ByteBuf buffer) {
  446. >             boolean completed = super.complete(bookieIndex, host, buffer);
  447.               if (completed) {
  448.                   int numReplicasTried = getNextReplicaIndexToReadFrom();

#162
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedAndEntryOp.java:416: warning: Thread Safety Violation
  Unprotected write. Non-private method `ReadLastConfirmedAndEntryOp$SequenceReadRequest.complete(...)` indirectly writes to field `this.rc` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  414.           @Override
  415.           boolean complete(int bookieIndex, BookieId host, ByteBuf buffer, long entryId) {
  416. >             boolean completed = super.complete(bookieIndex, host, buffer, entryId);
  417.               if (completed) {
  418.                   int numReplicasTried = getNextReplicaIndexToReadFrom();

#163
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:820: warning: Thread Safety Violation
  Read/Write race. Non-private method `TopologyAwareEnsemblePlacementPolicy.convertBookiesToNodes(...)` reads without synchronization from container `this.knownBookies` via call to `Map.get(...)`. Potentially races with write in method `TopologyAwareEnsemblePlacementPolicy.onClusterChanged(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  818.           Set<Node> nodes = new HashSet<Node>();
  819.           for (BookieId addr : excludeBookies) {
  820. >             BookieNode bn = knownBookies.get(addr);
  821.               if (null == bn) {
  822.                   bn = createBookieNode(addr);

#164
stream/distributedlog/protocol/src/main/java/org/apache/distributedlog/EnvelopedRecordSetWriter.java:149: warning: Thread Safety Violation
  Read/Write race. Non-private method `EnvelopedRecordSetWriter.createBuffer()` reads without synchronization from `this.count`. Potentially races with write in method `EnvelopedRecordSetWriter.writeRecord(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  147.           compressedBuf.setInt(METADATA_OFFSET, metadata);
  148.           // update count
  149. >         compressedBuf.setInt(COUNT_OFFSET, count);
  150.           // update data len
  151.           compressedBuf.setInt(DECOMPRESSED_SIZE_OFFSET, dataLen);

#165
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:190: warning: Interface Not Thread Safe
  Unprotected call to method `DeleteOption.endKey()` of un-annotated interface `org.apache.bookkeeper.api.kv.options.DeleteOption`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  188.           pKey.retain();
  189.           lKey.retain();
  190. >         if (null != option.endKey()) {
  191.               option.endKey().retain();
  192.           }

#166
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:75: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  73.    * A {@link PTable} implementation using simple grpc calls.
  74.    */
  75. > @Slf4j
  76.   public class PByteBufSimpleTableImpl
  77.       extends AbstractStub<PByteBufSimpleTableImpl>

#167
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:164: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.minLatency`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  162.               OpStats diff = new OpStats();
  163.               diff.maxLatency = this.maxLatency > base.maxLatency ? this.maxLatency : base.maxLatency;
  164. >             diff.minLatency = this.minLatency > base.minLatency ? base.minLatency : this.minLatency;
  165.               diff.totalLatency = this.totalLatency - base.totalLatency;
  166.               diff.numSuccessOps = this.numSuccessOps - base.numSuccessOps;

#168
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:169: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.latencyBuckets.[_]`. Potentially races with write in method `BKStats$OpStats.updateLatency(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  167.               diff.numFailedOps = this.numFailedOps - base.numFailedOps;
  168.               for (int i = 0; i < NUM_BUCKETS; i++) {
  169. >                 diff.latencyBuckets[i] = this.latencyBuckets[i] - base.latencyBuckets[i];
  170.               }
  171.               return diff;

#169
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:163: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.maxLatency`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  161.           public OpStats diff(OpStats base) {
  162.               OpStats diff = new OpStats();
  163. >             diff.maxLatency = this.maxLatency > base.maxLatency ? this.maxLatency : base.maxLatency;
  164.               diff.minLatency = this.minLatency > base.minLatency ? base.minLatency : this.minLatency;
  165.               diff.totalLatency = this.totalLatency - base.totalLatency;

#170
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:167: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.numFailedOps`. Potentially races with write in method `BKStats$OpStats.incrementFailedOps()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  165.               diff.totalLatency = this.totalLatency - base.totalLatency;
  166.               diff.numSuccessOps = this.numSuccessOps - base.numSuccessOps;
  167. >             diff.numFailedOps = this.numFailedOps - base.numFailedOps;
  168.               for (int i = 0; i < NUM_BUCKETS; i++) {
  169.                   diff.latencyBuckets[i] = this.latencyBuckets[i] - base.latencyBuckets[i];

#171
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:166: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.numSuccessOps`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  164.               diff.minLatency = this.minLatency > base.minLatency ? base.minLatency : this.minLatency;
  165.               diff.totalLatency = this.totalLatency - base.totalLatency;
  166. >             diff.numSuccessOps = this.numSuccessOps - base.numSuccessOps;
  167.               diff.numFailedOps = this.numFailedOps - base.numFailedOps;
  168.               for (int i = 0; i < NUM_BUCKETS; i++) {

#172
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:165: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.totalLatency`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  163.               diff.maxLatency = this.maxLatency > base.maxLatency ? this.maxLatency : base.maxLatency;
  164.               diff.minLatency = this.minLatency > base.minLatency ? base.minLatency : this.minLatency;
  165. >             diff.totalLatency = this.totalLatency - base.totalLatency;
  166.               diff.numSuccessOps = this.numSuccessOps - base.numSuccessOps;
  167.               diff.numFailedOps = this.numFailedOps - base.numFailedOps;

#173
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1358: warning: Thread Safety Violation
  Unprotected write. Non-private method `LedgerHandle.doAsyncAddEntry(...)` indirectly writes to field `op.allowFailFast` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1356.               try {
  1357.                   if (!waitForWritable(ws, 0, clientCtx.getConf().waitForWriteSetMs)) {
  1358. >                     op.allowFailFastOnUnwritableChannel();
  1359.                   }
  1360.               } finally {

#174
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1355: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.doAsyncAddEntry(...)` indirectly reads without synchronization from `op.entryId`. Potentially races with write in method `LedgerHandle.doAsyncAddEntry(...)`.
 Reporting because this access may occur on a background thread.
  1353.   
  1354.           if (clientCtx.getConf().waitForWriteSetMs >= 0) {
  1355. >             DistributionSchedule.WriteSet ws = distributionSchedule.getWriteSet(op.getEntryId());
  1356.               try {
  1357.                   if (!waitForWritable(ws, 0, clientCtx.getConf().waitForWriteSetMs)) {

#175
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1357: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.doAsyncAddEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1355.               DistributionSchedule.WriteSet ws = distributionSchedule.getWriteSet(op.getEntryId());
  1356.               try {
  1357. >                 if (!waitForWritable(ws, 0, clientCtx.getConf().waitForWriteSetMs)) {
  1358.                       op.allowFailFastOnUnwritableChannel();
  1359.                   }

#176
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandleAdv.java:272: warning: Thread Safety Violation
  Unprotected write. Non-private method `LedgerHandleAdv.doAsyncAddEntry(...)` indirectly writes to field `op.allowFailFast` outside of synchronization.
 Reporting because this access may occur on a background thread.
  270.               try {
  271.                   if (!waitForWritable(ws, 0, clientCtx.getConf().waitForWriteSetMs)) {
  272. >                     op.allowFailFastOnUnwritableChannel();
  273.                   }
  274.               } finally {

#177
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1930: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.ensembleChangeLoop(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1928.               LOG.info("{} reaches max allowed ensemble change number {}",
  1929.                        logContext, clientCtx.getConf().maxAllowedEnsembleChanges);
  1930. >             handleUnrecoverableErrorDuringAdd(WriteException);
  1931.               return;
  1932.           }

#178
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:535: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.enumerateLogsWithMetadataInNamespace()` reads without synchronization from `this.writerZKC`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  533.           String namespaceRootPath = namespace.getPath();
  534.           HashMap<String, byte[]> result = new HashMap<String, byte[]>();
  535. >         ZooKeeperClient zkc = writerZKC;
  536.           try {
  537.               ZooKeeper zk = Utils.sync(zkc, namespaceRootPath);

#179
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:533: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.enumerateLogsWithMetadataInNamespace()` reads without synchronization from `this.namespace`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  531.       public Map<String, byte[]> enumerateLogsWithMetadataInNamespace()
  532.           throws IOException, IllegalArgumentException {
  533. >         String namespaceRootPath = namespace.getPath();
  534.           HashMap<String, byte[]> result = new HashMap<String, byte[]>();
  535.           ZooKeeperClient zkc = writerZKC;

#180
bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java:85: warning: Thread Safety Violation
  Read/Write race. Non-private method `InMemoryMetastoreTable$MetadataVersion.equals(...)` reads without synchronization from `this.version`. Potentially races with write in method `InMemoryMetastoreTable$MetadataVersion.incrementVersion()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  83.               }
  84.               MetadataVersion v = (MetadataVersion) obj;
  85. >             return 0 == (version - v.version);
  86.           }
  87.   

#181
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/SingleDirectoryDbLedgerStorage.java:825: warning: Thread Safety Violation
  Read/Write race. Non-private method `SingleDirectoryDbLedgerStorage.flush()` indirectly reads without synchronization from `this.lastCheckpoint`. Potentially races with write in method `SingleDirectoryDbLedgerStorage.checkpoint(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  823.       public void flush() throws IOException {
  824.           Checkpoint cp = checkpointSource.newCheckpoint();
  825. >         checkpoint(cp);
  826.           if (singleLedgerDirs) {
  827.               checkpointSource.checkpointComplete(cp, true);

#182
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BKLogSegmentWriter.java:1027: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKLogSegmentWriter.flushIfNeeded()` reads without synchronization from `this.outstandingBytes`. Potentially races with write in method `BKLogSegmentWriter.asyncWrite(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1025.       void flushIfNeeded() throws BKTransmitException, WriteException, InvalidEnvelopedEntryException,
  1026.               LockingException, FlushException {
  1027. >         if (outstandingBytes > transmissionThreshold) {
  1028.               // If flush delay is disabled, flush immediately, else schedule appropriately.
  1029.               if (0 == minDelayBetweenImmediateFlushMs) {

#183
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BKLogSegmentWriter.java:990: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKLogSegmentWriter.flushIfNeededNoThrow()` indirectly reads without synchronization from `this.outstandingBytes`. Potentially races with write in method `BKLogSegmentWriter.asyncWrite(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  988.       void flushIfNeededNoThrow() {
  989.           try {
  990. >             flushIfNeeded();
  991.           } catch (IOException ioe) {
  992.               LOG.error("Encountered exception while flushing log records to stream {}",

#184
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1148: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.force()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1146.       public CompletableFuture<Void> force() {
  1147.           CompletableFuture<Void> result = new CompletableFuture<>();
  1148. >         ForceLedgerOp op = new ForceLedgerOp(this, clientCtx.getBookieClient(), getCurrentEnsemble(), result);
  1149.           boolean wasClosed = false;
  1150.           synchronized (this) {

#185
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:142: warning: Interface Not Thread Safe
  Unprotected call to method `RangeOption.endKey()` of un-annotated interface `org.apache.bookkeeper.api.kv.options.RangeOption`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  140.           pKey.retain();
  141.           lKey.retain();
  142. >         if (null != option.endKey()) {
  143.               option.endKey().retain();
  144.           }

#186
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVAsyncStore.java:71: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVAsyncStore.get(...)` indirectly reads without synchronization from `this.readIOScheduler`. Potentially races with write in method `RocksdbKVAsyncStore.init(...)`.
 Reporting because this access may occur on a background thread.
  69.           }
  70.   
  71. >         return executeReadIO(() -> {
  72.               byte[] keyBytes = keyCoder.encode(key);
  73.               byte[] valBytes = localStore.get(keyBytes);

#187
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:75: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  73.    * A {@link PTable} implementation using simple grpc calls.
  74.    */
  75. > @Slf4j
  76.   public class PByteBufSimpleTableImpl
  77.       extends AbstractStub<PByteBufSimpleTableImpl>

#188
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:490: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getAccessControlManager()` reads without synchronization from `this.namespace`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  488.                       throw new IOException("Invalid Access Control List Root Path : " + aclRootPath);
  489.                   }
  490. >                 String zkRootPath = namespace.getPath() + "/" + aclRootPath;
  491.                   LOG.info("Creating zk based access control manager @ {} for {}",
  492.                           zkRootPath, namespace);

#189
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:493: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getAccessControlManager()` reads without synchronization from `this.conf`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  491.                   LOG.info("Creating zk based access control manager @ {} for {}",
  492.                           zkRootPath, namespace);
  493. >                 accessControlManager = new ZKAccessControlManager(conf, readerZKC,
  494.                           zkRootPath, scheduler);
  495.                   LOG.info("Created zk based access control manager @ {} for {}",

#190
bookkeeper-http/servlet-http-server/src/main/java/org/apache/bookkeeper/http/servlet/BookieServletHttpServer.java:40: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieServletHttpServer.getBookieHttpServiceProvider()` reads without synchronization from `servlet.BookieServletHttpServer.bookieHttpServiceProvider`. Potentially races with write in method `BookieServletHttpServer.setHttpServiceProvider(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  38.   
  39.     public static HttpServiceProvider getBookieHttpServiceProvider(){
  40. >     return bookieHttpServiceProvider;
  41.     }
  42.     /**

#191
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:450: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.getCtime()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  448.        */
  449.       public long getCtime() {
  450. >         return getLedgerMetadata().getCtime();
  451.       }
  452.   

#192
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:2057: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.getCurrentEnsemble()` reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2055.           // thing until metadata is immutable. At that point, current ensemble
  2056.           // becomes a property of the LedgerHandle itself.
  2057. >         return LedgerMetadataUtils.getCurrentEnsemble(versionedMetadata.getValue());
  2058.       }
  2059.   

#193
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:387: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.getCustomMetadata()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  385.        */
  386.       public Map<String, byte[]> getCustomMetadata() {
  387. >         return getLedgerMetadata().getCustomMetadata();
  388.       }
  389.   

#194
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieImpl.java:1226: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieImpl.getExitCode()` reads without synchronization from `this.exitCode`. Potentially races with write in method `BookieImpl.start()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1224.        */
  1225.       public int getExitCode() {
  1226. >         return exitCode;
  1227.       }
  1228.   

#195
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java:240: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieServer.getExitCode()` reads without synchronization from `this.exitCode`. Potentially races with write in method `BookieServer.shutdown()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  238.   
  239.       public int getExitCode() {
  240. >         return exitCode;
  241.       }
  242.   

#196
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:508: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getFifteenMinuteRate()` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  506.       @Override
  507.       public double getFifteenMinuteRate() {
  508. >         return getRate(15 * 60);
  509.       }
  510.   

#197
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:513: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getFiveMinuteRate()` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  511.       @Override
  512.       public double getFiveMinuteRate() {
  513. >         return getRate(5 * 60);
  514.       }
  515.   

#198
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataBookieDriver.java:29: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataBookieDriver.getLayoutManager()` indirectly reads without synchronization from `this.layoutManager`. Potentially races with write in method `EtcdMetadataBookieDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  27.    * Etcd based metadata bookie driver.
  28.    */
  29. > @Slf4j
  30.   public class EtcdMetadataBookieDriver extends EtcdMetadataDriverBase implements MetadataBookieDriver {
  31.   

#199
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:101: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataDriverBase.getLayoutManager()` reads without synchronization from `this.layoutManager`. Potentially races with write in method `EtcdMetadataDriverBase.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
   99.   
  100.       public LayoutManager getLayoutManager() {
  101. >         return layoutManager;
  102.       }
  103.   

#200
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:109: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataDriverBase.getLedgerManagerFactory()` reads with synchronization from `this.conf`. Potentially races with unsynchronized write in method `EtcdMetadataDriverBase.initialize(...)`.
 Reporting because this access may occur on a background thread.
  107.               try {
  108.                   lmFactory = new EtcdLedgerManagerFactory();
  109. >                 lmFactory.initialize(conf, layoutManager, EtcdLedgerManagerFactory.VERSION);
  110.               } catch (IOException ioe) {
  111.                   throw new MetadataException(

#201
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:357: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.getLedgerMetadata()` reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  355.       @Override
  356.       public LedgerMetadata getLedgerMetadata() {
  357. >         return versionedMetadata.getValue();
  358.       }
  359.   

#202
bookkeeper-http/servlet-http-server/src/main/java/org/apache/bookkeeper/http/servlet/BookieServletHttpServer.java:46: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieServletHttpServer.getListenPort()` reads without synchronization from `servlet.BookieServletHttpServer.listenPort`. Potentially races with write in method `BookieServletHttpServer.setPort(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  44.      **/
  45.     public static int getListenPort(){
  46. >     return listenPort;
  47.     }
  48.   

#203
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:427: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getLogMetadataStore()` reads without synchronization from `this.metadataStore`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  425.       @Override
  426.       public LogMetadataStore getLogMetadataStore() {
  427. >         return metadataStore;
  428.       }
  429.   

#204
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:444: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getLogSegmentEntryStore(...)` indirectly reads without synchronization from `this.failureInjector`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  442.               return getWriterEntryStore();
  443.           } else {
  444. >             return getReaderEntryStore();
  445.           }
  446.       }

#205
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:442: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getLogSegmentEntryStore(...)` indirectly reads without synchronization from `this.allocator`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  440.       public LogSegmentEntryStore getLogSegmentEntryStore(Role role) {
  441.           if (Role.WRITER == role) {
  442. >             return getWriterEntryStore();
  443.           } else {
  444.               return getReaderEntryStore();

#206
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:433: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getLogStreamMetadataStore(...)` reads without synchronization from `this.writerStreamMetadataStore`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  431.       public LogStreamMetadataStore getLogStreamMetadataStore(Role role) {
  432.           if (Role.WRITER == role) {
  433. >             return writerStreamMetadataStore;
  434.           } else {
  435.               return readerStreamMetadataStore;

#207
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:435: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getLogStreamMetadataStore(...)` reads without synchronization from `this.readerStreamMetadataStore`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  433.               return writerStreamMetadataStore;
  434.           } else {
  435. >             return readerStreamMetadataStore;
  436.           }
  437.       }

#208
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:518: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getMeanRate()` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  516.       @Override
  517.       public double getMeanRate() {
  518. >         return getRate(Integer.MAX_VALUE);
  519.       }
  520.   

#209
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:522: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getMetadataAccessor(...)` reads without synchronization from `this.conf`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  520.           checkState();
  521.           streamName = validateAndNormalizeName(streamName);
  522. >         return new ZKMetadataAccessor(
  523.                   streamName,
  524.                   conf,

#210
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:520: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getMetadataAccessor(...)` indirectly reads without synchronization from `this.namespace`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  518.               throw new UnsupportedOperationException();
  519.           }
  520. >         checkState();
  521.           streamName = validateAndNormalizeName(streamName);
  522.           return new ZKMetadataAccessor(

#211
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:523: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getOneMinuteRate()` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  521.       @Override
  522.       public double getOneMinuteRate() {
  523. >         return getRate(60);
  524.       }
  525.   

#212
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLoggerAllocator.java:248: warning: Thread Safety Violation
  Read/Write race. Non-private method `EntryLoggerAllocator.getPreallocationFuture()` reads without synchronization from `this.preallocation`. Potentially races with write in method `EntryLoggerAllocator.createNewLog(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  246.        */
  247.       Future<BufferedLogChannel> getPreallocationFuture(){
  248. >         return preallocation;
  249.       }
  250.   }

#213
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:62: warning: Thread Safety Violation
  Read/Write race. Non-private method `RangeRouter.getRange(...)` indirectly reads without synchronization from `this.ranges`. Potentially races with write in method `RangeRouter.setRanges(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  60.        */
  61.       public long getRange(@Nullable K key) {
  62. >         return getRangeProperties(key).getRangeId();
  63.       }
  64.   

#214
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:68: warning: Interface Not Thread Safe
  Unprotected call to method `HashRouter.getRoutingKey(...)` of un-annotated interface `org.apache.bookkeeper.common.router.HashRouter`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because the current class is annotated `@ThreadSafe`.
  66.           long routingKey;
  67.           if (null != key) {
  68. >             routingKey = keyRouter.getRoutingKey(key);
  69.           } else {
  70.               routingKey = ThreadLocalRandom.current().nextLong();

#215
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:74: warning: Thread Safety Violation
  Read/Write race. Non-private method `RangeRouter.getRangeProperties(...)` reads without synchronization from `this.ranges`. Potentially races with write in method `RangeRouter.setRanges(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  72.           HashStreamRanges rs;
  73.           long stamp = lock.tryOptimisticRead();
  74. >         rs = ranges;
  75.           if (!lock.validate(stamp)) {
  76.               stamp = lock.readLock();

#216
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:92: warning: Thread Safety Violation
  Read/Write race. Non-private method `RangeRouter.getRanges()` reads without synchronization from `this.ranges`. Potentially races with write in method `RangeRouter.setRanges(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  90.           HashStreamRanges rs;
  91.           long stamp = lock.tryOptimisticRead();
  92. >         rs = ranges;
  93.           if (!lock.validate(stamp)) {
  94.               stamp = lock.readLock();

#217
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:487: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getRate(...)` reads without synchronization from `this.meter.[_].[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  485.               for (int i = t; i > secFrom; i--) {
  486.                   // no need to synchronize for reading (meter (int) is written atomically)
  487. >                 sum += meter[h][(timeWindow + i) % timeWindow];
  488.               }
  489.           }

#218
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:481: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getRate(...)` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  479.       public double getRate(int seconds) {
  480.           seconds = Math.min(seconds, timeWindow - 2);
  481. >         int t = getNow(getHash()) - 1; // start from last completed second
  482.           int secFrom = t - seconds;
  483.           long sum = 0;

#219
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:512: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.getRawBytes(...)` reads without synchronization from `this.dataCfHandle`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  510.       protected byte[] getRawBytes(K key, byte[] keyBytes) {
  511.           try {
  512. >             return this.db.get(dataCfHandle, keyBytes);
  513.           } catch (RocksDBException e) {
  514.               throw new StateStoreRuntimeException("Error while getting value for key " + key + " from store " + name, e);

#220
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java:166: warning: Thread Safety Violation
  Read/Write race. Non-private method `FileInfo.getSizeSinceLastWrite()` reads without synchronization from `this.sizeSinceLastWrite`. Potentially races with write in method `FileInfo.readHeader()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  164.   
  165.       public long getSizeSinceLastWrite() {
  166. >         return sizeSinceLastWrite;
  167.       }
  168.   

#221
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:540: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getSnapshot()` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getOneMinuteRate()`.
 Reporting because this access may occur on a background thread.
  538.   
  539.           // get time and trigger housekeeping
  540. >         int now = getNow(0) - 1; // start from last completed second
  541.           int secFrom = now - (timeWindow - 2);
  542.   

#222
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:564: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getSnapshot()` reads without synchronization from `this.buckets.[_].[_]`. Potentially races with write in method `FastTimer.getOneMinuteRate()`.
 Reporting because this access may occur on a background thread.
  562.               // no need to synchronize for reading (buckets (int) is written atomically)
  563.               for (int b = 0; b < numBuckets; b++) {
  564. >                 buckets[b] += this.buckets[b][t];
  565.               }
  566.           }

#223
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:506: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getSubscriptionsStore(...)` reads without synchronization from `this.conf`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  504.           return new ZKSubscriptionsStore(
  505.                   writerZKC,
  506. >                 LogMetadataForReader.getSubscribersPath(namespace, streamName, conf.getUnpartitionedStreamName()));
  507.       }
  508.   

#224
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java:215: warning: Thread Safety Violation
  Read/Write race. Non-private method `BenchThroughputLatency.getThroughput()` reads without synchronization from `this.throughput`. Potentially races with write in method `BenchThroughputLatency.run()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  213.       long throughput = -1;
  214.       public long getThroughput() {
  215. >         return throughput;
  216.       }
  217.   

#225
microbenchmarks/src/main/java/org/apache/bookkeeper/stats/codahale/TimerBenchmark.java:109: warning: Thread Safety Violation
  Read/Write race. Non-private method `TimerBenchmark$MyState.getTime()` reads without synchronization from `codahale.TimerBenchmark$MyState.times`. Potentially races with write in method `TimerBenchmark$MyState.doSetup()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  107.   
  108.           public long getTime() {
  109. >             return times[(timeIdx++) % times.length];
  110.           }
  111.   

#226
microbenchmarks/src/main/java/org/apache/bookkeeper/stats/codahale/TimerBenchmark.java:105: warning: Thread Safety Violation
  Read/Write race. Non-private method `TimerBenchmark$MyState.getTimer()` reads without synchronization from `codahale.TimerBenchmark$MyState.timers`. Potentially races with write in method `TimerBenchmark$MyState.doSetup()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  103.   
  104.           public OpStatsLogger getTimer() {
  105. >             return timers[(timerIdx++) % timers.length];
  106.           }
  107.   

#227
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:417: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getUri()` reads without synchronization from `this.namespace`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  415.       @Override
  416.       public URI getUri() {
  417. >         return namespace;
  418.       }
  419.   

#228
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:361: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.getVersionedLedgerMetadata()` reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  359.   
  360.       Versioned<LedgerMetadata> getVersionedLedgerMetadata() {
  361. >         return versionedMetadata;
  362.       }
  363.   

#229
bookkeeper-server/src/main/java/org/apache/bookkeeper/discover/ZKRegistrationClient.java:181: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKRegistrationClient.getWatchReadOnlyBookiesTask()` reads without synchronization from `this.watchReadOnlyBookiesTask`. Potentially races with write in method `ZKRegistrationClient.watchReadOnlyBookies(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  179.       @Getter(AccessLevel.PACKAGE)
  180.       private WatchTask watchWritableBookiesTask = null;
  181. >     @Getter(AccessLevel.PACKAGE)
  182.       private WatchTask watchReadOnlyBookiesTask = null;
  183.       private final ConcurrentHashMap<BookieId, Versioned<BookieServiceInfo>> bookieServiceInfoCache =

#230
bookkeeper-server/src/main/java/org/apache/bookkeeper/discover/ZKRegistrationClient.java:179: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKRegistrationClient.getWatchWritableBookiesTask()` reads without synchronization from `this.watchWritableBookiesTask`. Potentially races with write in method `ZKRegistrationClient.watchWritableBookies(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  177.       private final ZooKeeper zk;
  178.       private final ScheduledExecutorService scheduler;
  179. >     @Getter(AccessLevel.PACKAGE)
  180.       private WatchTask watchWritableBookiesTask = null;
  181.       @Getter(AccessLevel.PACKAGE)

#231
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1918: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.handleBookieFailure(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1916.           }
  1917.           if (triggerLoop) {
  1918. >             ensembleChangeLoop(origEnsemble, toReplace);
  1919.           }
  1920.       }

#232
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:721: warning: Thread Safety Violation
  Unprotected write. Non-private method `TopologyAwareEnsemblePlacementPolicy.handleBookiesThatJoined(...)` mutates container `this.historyBookies` via call to `Map.put(...)` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  719.                   topology.add(node);
  720.                   knownBookies.put(addr, node);
  721. >                 historyBookies.put(addr, node);
  722.                   if (this.isWeighted) {
  723.                       this.bookieInfoMap.putIfAbsent(node, new BookieInfo());

#233
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:720: warning: Thread Safety Violation
  Unprotected write. Non-private method `TopologyAwareEnsemblePlacementPolicy.handleBookiesThatJoined(...)` mutates container `this.knownBookies` via call to `Map.put(...)` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  718.                   BookieNode node = createBookieNode(addr);
  719.                   topology.add(node);
  720. >                 knownBookies.put(addr, node);
  721.                   historyBookies.put(addr, node);
  722.                   if (this.isWeighted) {

#234
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:723: warning: Thread Safety Violation
  Read/Write race. Non-private method `TopologyAwareEnsemblePlacementPolicy.handleBookiesThatJoined(...)` reads without synchronization from `this.bookieInfoMap`. Potentially races with write in method `TopologyAwareEnsemblePlacementPolicy.updateBookieInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  721.                   historyBookies.put(addr, node);
  722.                   if (this.isWeighted) {
  723. >                     this.bookieInfoMap.putIfAbsent(node, new BookieInfo());
  724.                   }
  725.   

#235
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:690: warning: Thread Safety Violation
  Read/Write race. Non-private method `TopologyAwareEnsemblePlacementPolicy.handleBookiesThatLeft(...)` reads without synchronization from `this.bookieInfoMap`. Potentially races with write in method `TopologyAwareEnsemblePlacementPolicy.updateBookieInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  688.                       topology.remove(node);
  689.                       if (this.isWeighted) {
  690. >                         this.bookieInfoMap.remove(node);
  691.                       }
  692.   

#236
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:686: warning: Thread Safety Violation
  Unprotected write. Non-private method `TopologyAwareEnsemblePlacementPolicy.handleBookiesThatLeft(...)` mutates container `this.knownBookies` via call to `Map.remove(...)` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  684.           for (BookieId addr : leftBookies) {
  685.               try {
  686. >                 BookieNode node = knownBookies.remove(addr);
  687.                   if (null != node) {
  688.                       topology.remove(node);

#237
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1776: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.handleUnrecoverableErrorDuringAdd(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1774.       // close the ledger and send fails to all the adds in the pipeline
  1775.       void handleUnrecoverableErrorDuringAdd(int rc) {
  1776. >         if (getLedgerMetadata().getState() == LedgerMetadata.State.IN_RECOVERY) {
  1777.               // we should not close ledger if ledger is recovery mode
  1778.               // otherwise we may lose entry.

#238
bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java:95: warning: Thread Safety Violation
  Read/Write race. Non-private method `InMemoryMetastoreTable$MetadataVersion.hashCode()` reads without synchronization from `this.version`. Potentially races with write in method `InMemoryMetastoreTable$MetadataVersion.incrementVersion()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  93.           @Override
  94.           public int hashCode() {
  95. >             return version;
  96.           }
  97.       }

#239
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:216: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  214.           pKey.retain();
  215.           lKey.retain();
  216. >         return retryUtils.execute(() -> fromListenableFuture(
  217.               ClientCalls.futureUnaryCall(
  218.                   getChannel(pKey).newCall(getIncrementMethod(), getCallOptions()),

#240
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:75: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  73.    * A {@link PTable} implementation using simple grpc calls.
  74.    */
  75. > @Slf4j
  76.   public class PByteBufSimpleTableImpl
  77.       extends AbstractStub<PByteBufSimpleTableImpl>

#241
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:68: warning: Thread Safety Violation
  Unprotected write. Non-private method `EtcdMetadataDriverBase.initialize(...)` writes to field `this.statsLogger` outside of synchronization.
 Reporting because this access may occur on a background thread.
  66.           throws MetadataException {
  67.           this.conf = conf;
  68. >         this.statsLogger = statsLogger;
  69.   
  70.           final String metadataServiceUriStr;

#242
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:85: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataDriverBase.initialize(...)` reads without synchronization from `this.keyPrefix`. Potentially races with write in method `EtcdMetadataDriverBase.initialize(...)`.
 Reporting because this access may occur on a background thread.
  83.               .collect(Collectors.toList());
  84.   
  85. >         log.info("Initializing etcd metadata driver : etcd endpoints = {}, key scope = {}",
  86.               etcdEndpoints, keyPrefix);
  87.   

#243
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:78: warning: Thread Safety Violation
  Unprotected write. Non-private method `EtcdMetadataDriverBase.initialize(...)` writes to field `this.keyPrefix` outside of synchronization.
 Reporting because this access may occur on a background thread.
  76.           }
  77.           ServiceURI serviceURI = ServiceURI.create(metadataServiceUriStr);
  78. >         this.keyPrefix = serviceURI.getServicePath();
  79.   
  80.           List<String> etcdEndpoints = Lists.newArrayList(serviceURI.getServiceHosts())

#244
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:94: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataDriverBase.initialize(...)` reads without synchronization from `this.client`. Potentially races with write in method `EtcdMetadataDriverBase.close()`.
 Reporting because this access may occur on a background thread.
  92.           }
  93.   
  94. >         this.layoutManager = new EtcdLayoutManager(
  95.               client,
  96.               keyPrefix

#245
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:67: warning: Thread Safety Violation
  Unprotected write. Non-private method `EtcdMetadataDriverBase.initialize(...)` writes to field `this.conf` outside of synchronization.
 Reporting because this access may occur on a background thread.
  65.       protected void initialize(AbstractConfiguration<?> conf, StatsLogger statsLogger)
  66.           throws MetadataException {
  67. >         this.conf = conf;
  68.           this.statsLogger = statsLogger;
  69.   

#246
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataClientDriver.java:53: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataClientDriver.initialize(...)` indirectly reads without synchronization from `this.client`. Potentially races with write in method `EtcdMetadataClientDriver.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  51.                                              Optional<Object> ctx)
  52.               throws MetadataException {
  53. >         super.initialize(conf, statsLogger);
  54.           this.conf = conf;
  55.           this.statsLogger = statsLogger;

#247
stream/common/src/main/java/org/apache/bookkeeper/common/grpc/stats/MonitoringClientInterceptor.java:78: warning: Interface Not Thread Safe
  Unprotected call to method `StatsLogger.scope(...)` of un-annotated interface `org.apache.bookkeeper.stats.StatsLogger`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.ClientInterceptor` is annotated `@ThreadSafe`.
  76.       public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(
  77.           MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) {
  78. >         ClientStats stats = getMethodStats(method);
  79.           return new MonitoringClientCall<>(
  80.               next.newCall(method, callOptions),

#248
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/routing/RoutingHeaderProxyInterceptor.java:166: warning: Interface Not Thread Safe
  Unprotected call to method `Logger.isTraceEnabled()` of un-annotated interface `org.slf4j.Logger`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.ClientInterceptor` is annotated `@ThreadSafe`.
  164.                                                                  CallOptions callOptions,
  165.                                                                  Channel next) {
  166. >         if (log.isTraceEnabled()) {
  167.               log.trace("Intercepting method {} : req marshaller = {}, resp marshaller = {}",
  168.                   method.getFullMethodName(),

#249
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/container/StorageContainerClientInterceptor.java:53: warning: Interface Not Thread Safe
  Unprotected call to method `Logger.isTraceEnabled()` of un-annotated interface `org.slf4j.Logger`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.ClientInterceptor` is annotated `@ThreadSafe`.
  51.                                                                  CallOptions callOptions,
  52.                                                                  Channel next) {
  53. >         if (log.isTraceEnabled()) {
  54.               log.trace("Intercepting method {} : req marshaller = {}, resp marshaller = {}",
  55.                   method.getFullMethodName(),

#250
stream/common/src/main/java/org/apache/bookkeeper/common/grpc/stats/MonitoringServerInterceptor.java:82: warning: Interface Not Thread Safe
  Unprotected call to method `StatsLogger.scope(...)` of un-annotated interface `org.apache.bookkeeper.stats.StatsLogger`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.ServerInterceptor` is annotated `@ThreadSafe`.
  80.                                                         ServerCallHandler<ReqT, RespT> next) {
  81.           MethodDescriptor<ReqT, RespT> method = call.getMethodDescriptor();
  82. >         ServerStats stats = getMethodStats(method);
  83.           ServerCall<ReqT, RespT> monitoringCall = new MonitoringServerCall<>(call, stats);
  84.           return new MonitoringServerCallListener<>(

#251
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java:158: warning: Thread Safety Violation
  Read/Write race. Non-private method `FileInfo.isClosed()` reads without synchronization from `this.isClosed`. Potentially races with write in method `FileInfo.close(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  156.   
  157.       public boolean isClosed() {
  158. >         return isClosed;
  159.       }
  160.   

#252
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:516: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.isHandleWritable()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  514.   
  515.       boolean isHandleWritable() {
  516. >         return !getLedgerMetadata().isClosed() && handleState == HandleState.OPEN;
  517.       }
  518.   

#253
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java:262: warning: Thread Safety Violation
  Read/Write race. Non-private method `AuditorElector.isRunning()` reads without synchronization from `this.auditor`. Potentially races with write in method `AuditorElector.shutdown()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  260.        */
  261.       public boolean isRunning() {
  262. >         if (auditor != null) {
  263.               return auditor.isRunning();
  264.           }

#254
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/TransientLedgerInfo.java:144: warning: Thread Safety Violation
  Read/Write race. Non-private method `TransientLedgerInfo.isStale()` reads without synchronization from `this.lastAccessed`. Potentially races with write in method `TransientLedgerInfo.setLastAddConfirmed(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  142.       boolean isStale() {
  143.           return (lastAccessed + TimeUnit.MINUTES.toMillis(LEDGER_INFO_CACHING_TIME_MINUTES)) < System
  144. >                 .currentTimeMillis();
  145.       }
  146.   

#255
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClientImpl.java:657: warning: Thread Safety Violation
  Unprotected write. Non-private method `BookieClientImpl.main(...)` indirectly mutates container `util.ReflectionUtils.constructorCache` via call to `Map.put(...)` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  655.           ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(
  656.                   new DefaultThreadFactory("BookKeeperClientScheduler"));
  657. >         BookieClientImpl bc = new BookieClientImpl(new ClientConfiguration(), eventLoopGroup,
  658.                   null, executor, scheduler, NullStatsLogger.INSTANCE, BookieSocketAddress.LEGACY_BOOKIEID_RESOLVER);
  659.           BookieId addr = new BookieSocketAddress(args[0], Integer.parseInt(args[1])).toBookieId();

#256
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java:83: warning: Thread Safety Violation
  Read/Write race. Non-private method `DefaultEnsemblePlacementPolicy.newEnsemble(...)` reads without synchronization from `this.isWeighted`. Potentially races with write in method `DefaultEnsemblePlacementPolicy.initialize(...)`.
 Reporting because this access may occur on a background thread.
  81.           }
  82.   
  83. >         if (isWeighted) {
  84.               // hold the readlock while selecting bookies. We don't want the list of bookies
  85.               // changing while we are creating the ensemble

#257
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RegionAwareEnsemblePlacementPolicy.java:296: warning: Thread Safety Violation
  Read/Write race. Non-private method `RegionAwareEnsemblePlacementPolicy.newEnsemble(...)` reads without synchronization from `this.disableDurabilityFeature`. Potentially races with write in method `RegionAwareEnsemblePlacementPolicy.initialize(...)`.
 Reporting because this access may occur on a background thread.
  294.               throws BKException.BKNotEnoughBookiesException {
  295.   
  296. >         int effectiveMinRegionsForDurability = disableDurabilityFeature.isAvailable() ? 1 : minRegionsForDurability;
  297.   
  298.           // All of these conditions indicate bad configuration

#258
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:340: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZoneawareEnsemblePlacementPolicyImpl.newEnsemble(...)` reads without synchronization from `this.enforceStrictZoneawarePlacement`. Potentially races with write in method `ZoneawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  338.               int ackQuorumSize, Map<String, byte[]> customMetadata, Set<BookieId> excludeBookies)
  339.               throws BKNotEnoughBookiesException {
  340. >         if (enforceStrictZoneawarePlacement) {
  341.               if (ensembleSize % writeQuorumSize != 0) {
  342.                   /*

#259
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:394: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZoneawareEnsemblePlacementPolicyImpl.newEnsemble(...)` reads without synchronization from `this.desiredNumZonesPerWriteQuorum`. Potentially races with write in method `ZoneawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  392.               }
  393.           }
  394. >         int desiredNumZonesPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, desiredNumZonesPerWriteQuorum);
  395.           List<BookieId> newEnsemble = new ArrayList<BookieId>(
  396.                   Collections.nCopies(ensembleSize, null));

#260
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:370: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZoneawareEnsemblePlacementPolicyImpl.newEnsemble(...)` reads without synchronization from `this.minNumZonesPerWriteQuorum`. Potentially races with write in method `ZoneawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  368.                           + " writeQuorumSize When StrictZoneawarePlacement is enabled");
  369.               }
  370. >             if (writeQuorumSize <= minNumZonesPerWriteQuorum) {
  371.                   /*
  372.                    * if we allow writeQuorumSize <= minNumZonesPerWriteQuorum,

#261
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/store/MVCCStoreFactoryImpl.java:196: warning: Thread Safety Violation
  Read/Write race. Non-private method `MVCCStoreFactoryImpl.newStore(...)` reads without synchronization from `this.checkpointStore`. Potentially races with write in method `MVCCStoreFactoryImpl.newStore(...)`.
 Reporting because this access may occur on a background thread.
  194.               normalizedName(rangeId));
  195.   
  196. >         if (null == checkpointStore) {
  197.               checkpointStore = checkpointStoreSupplier.get();
  198.           }

#262
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/store/MVCCStoreFactoryImpl.java:197: warning: Thread Safety Violation
  Unprotected write. Non-private method `MVCCStoreFactoryImpl.newStore(...)` writes to field `this.checkpointStore` outside of synchronization.
 Reporting because this access may occur on a background thread.
  195.   
  196.           if (null == checkpointStore) {
  197. >             checkpointStore = checkpointStoreSupplier.get();
  198.           }
  199.   

#263
bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java:528: warning: Thread Safety Violation
  Read/Write race. Non-private method `TLSContextFactory.newTLSHandler()` indirectly reads without synchronization from `this.allocator`. Potentially races with write in method `TLSContextFactory.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  526.       @Override
  527.       public SslHandler newTLSHandler() {
  528. >         return this.newTLSHandler(null, -1);
  529.       }
  530.   

#264
bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java:535: warning: Thread Safety Violation
  Read/Write race. Non-private method `TLSContextFactory.newTLSHandler(...)` reads without synchronization from `this.protocols`. Potentially races with write in method `TLSContextFactory.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  533.           SslHandler sslHandler = getSSLContext().newHandler(allocator, peer, port);
  534.   
  535. >         if (protocols != null && protocols.length != 0) {
  536.               sslHandler.engine().setEnabledProtocols(protocols);
  537.           }

#265
bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java:542: warning: Thread Safety Violation
  Read/Write race. Non-private method `TLSContextFactory.newTLSHandler(...)` reads without synchronization from `this.ciphers`. Potentially races with write in method `TLSContextFactory.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  540.           }
  541.   
  542. >         if (ciphers != null && ciphers.length != 0) {
  543.               sslHandler.engine().setEnabledCipherSuites(ciphers);
  544.           }

#266
bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java:549: warning: Thread Safety Violation
  Read/Write race. Non-private method `TLSContextFactory.newTLSHandler(...)` reads without synchronization from `this.config`. Potentially races with write in method `TLSContextFactory.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  547.           }
  548.   
  549. >         if (type == NodeType.Client && ((ClientConfiguration) config).getHostnameVerificationEnabled()) {
  550.               SSLParameters sslParameters = sslHandler.engine().getSSLParameters();
  551.               sslParameters.setEndpointIdentificationAlgorithm("HTTPS");

#267
bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java:533: warning: Thread Safety Violation
  Read/Write race. Non-private method `TLSContextFactory.newTLSHandler(...)` reads without synchronization from `this.allocator`. Potentially races with write in method `TLSContextFactory.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  531.       @Override
  532.       public SslHandler newTLSHandler(String peer, int port) {
  533. >         SslHandler sslHandler = getSSLContext().newHandler(allocator, peer, port);
  534.   
  535.           if (protocols != null && protocols.length != 0) {

#268
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java:188: warning: Thread Safety Violation
  Unprotected write. Non-private method `LedgerRecoveryOp.onEntryComplete(...)` indirectly writes to field `entry.data` outside of synchronization.
 Reporting because this access may occur on a background thread.
  186.           if (!promise.isDone() && !readDone && rc == BKException.Code.OK) {
  187.               readCount.incrementAndGet();
  188. >             byte[] data = entry.getEntry();
  189.   
  190.               /*

#269
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java:385: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieInfoReader.onExit()` reads without synchronization from `this.errorCnt`. Potentially races with write in method `BookieInfoReader.getReadWriteBookieInfo()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  383.       void onExit() {
  384.           bk.placementPolicy.updateBookieInfo(bookieInfoMap.getBookieMap());
  385. >         if (errorCnt > 0) {
  386.               if (LOG.isInfoEnabled()) {
  387.                   LOG.info("Rescheduling in {}s due to errors", conf.getGetBookieInfoIntervalSeconds());

#270
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java:391: warning: Thread Safety Violation
  Unprotected write. Non-private method `BookieInfoReader.onExit()` indirectly writes to field `this.instanceState.running` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  389.               instanceState.tryStartPartial();
  390.               submitTaskWithDelay(conf.getGetBookieInfoRetryIntervalSeconds());
  391. >         } else if (instanceState.completeUnlessQueued()) {
  392.               if (LOG.isInfoEnabled()) {
  393.                   LOG.info("Rescheduling, another scan is pending");

#271
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java:389: warning: Thread Safety Violation
  Unprotected write. Non-private method `BookieInfoReader.onExit()` indirectly writes to field `this.instanceState.queuedType` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  387.                   LOG.info("Rescheduling in {}s due to errors", conf.getGetBookieInfoIntervalSeconds());
  388.               }
  389. >             instanceState.tryStartPartial();
  390.               submitTaskWithDelay(conf.getGetBookieInfoRetryIntervalSeconds());
  391.           } else if (instanceState.completeUnlessQueued()) {

#272
stream/distributedlog/core/src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java:246: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKDistributedLock$3.onSuccess(...)` writes to field `this.this$0.lockWaiter` outside of synchronization.
 Reporting because this access may occur on a background thread.
  244.                       }
  245.                       tryLockFuture = null;
  246. >                     lockWaiter = waiter;
  247.                       waitForAcquire(waiter, acquirePromise);
  248.                   }

#273
stream/distributedlog/core/src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java:245: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKDistributedLock$3.onSuccess(...)` writes to field `this.this$0.tryLockFuture` outside of synchronization.
 Reporting because this access may occur on a background thread.
  243.                           }
  244.                       }
  245. >                     tryLockFuture = null;
  246.                       lockWaiter = waiter;
  247.                       waitForAcquire(waiter, acquirePromise);

#274
stream/distributedlog/core/src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java:200: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKDistributedLock$2.onSuccess(...)` indirectly writes to field `this.this$0.tryLockFuture` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  198.           lockFactory
  199.               .createLock(lockPath, lockContext)
  200. >             .whenCompleteAsync(new FutureEventListener<SessionLock>() {
  201.               @Override
  202.               public void onSuccess(SessionLock lock) {

#275
stream/distributedlog/core/src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java:232: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKDistributedLock$3.onSuccess(...)` indirectly writes to field `this.this$0.lockWaiter` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  230.           tryLockFuture = lock.asyncTryLock(lockTimeout, TimeUnit.MILLISECONDS);
  231.           tryLockFuture.whenCompleteAsync(
  232. >             new FutureEventListener<LockWaiter>() {
  233.                   @Override
  234.                   public void onSuccess(LockWaiter waiter) {

#276
stream/distributedlog/core/src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java:214: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKDistributedLock$2.onSuccess(...)` indirectly writes to field `this.this$0.tryLockFuture` outside of synchronization.
 Reporting because this access may occur on a background thread.
  212.                       internalLock.setLockListener(ZKDistributedLock.this);
  213.                   }
  214. >                 asyncTryLock(lock, acquirePromise, lockTimeout);
  215.               }
  216.   

#277
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:359: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openLocalDB(...)` indirectly reads without synchronization from `this.ttlSeconds`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  357.                                                                     ColumnFamilyOptions cfOpts)
  358.           throws StateStoreException {
  359. >         return openRocksdb(dir, options, cfOpts);
  360.       }
  361.   

#278
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:365: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.ttlSeconds`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  363.           File dir, DBOptions options, ColumnFamilyOptions cfOpts)
  364.           throws StateStoreException {
  365. >         final boolean haveTtl = ttlSeconds != 0;
  366.           final ColumnFamilyDescriptor metaDesc = new ColumnFamilyDescriptor(METADATA_CF, cfOpts);
  367.           final ColumnFamilyDescriptor dataDesc = new ColumnFamilyDescriptor(haveTtl ? DATA_TTL_CF : DATA_CF, cfOpts);

#279
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:338: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.writeOpts` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  336.           // initialize the write options
  337.   
  338. >         writeOpts = new WriteOptions();
  339.           writeOpts.setDisableWAL(true); // disable wal, since the source of truth will be on distributedlog
  340.   

#280
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:351: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.metaCfHandle` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  349.           Pair<RocksDB, List<ColumnFamilyHandle>> dbPair = openLocalDB(dbDir, dbOpts, cfOpts);
  350.           this.db = dbPair.getLeft();
  351. >         this.metaCfHandle = dbPair.getRight().get(0);
  352.           this.dataCfHandle = dbPair.getRight().get(1);
  353.       }

#281
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:349: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.dbDir`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  347.   
  348.           this.dbDir = spec.getLocalStateStoreDir();
  349. >         Pair<RocksDB, List<ColumnFamilyHandle>> dbPair = openLocalDB(dbDir, dbOpts, cfOpts);
  350.           this.db = dbPair.getLeft();
  351.           this.metaCfHandle = dbPair.getRight().get(0);

#282
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:322: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.dbOpts` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  320.           tableConfig.setChecksumType(DEFAULT_CHECKSUM_TYPE);
  321.   
  322. >         dbOpts = new DBOptions();
  323.           dbOpts.setCreateIfMissing(true);
  324.           dbOpts.setErrorIfExists(false);

#283
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:352: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.dataCfHandle` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  350.           this.db = dbPair.getLeft();
  351.           this.metaCfHandle = dbPair.getRight().get(0);
  352. >         this.dataCfHandle = dbPair.getRight().get(1);
  353.       }
  354.   

#284
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:350: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.db` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  348.           this.dbDir = spec.getLocalStateStoreDir();
  349.           Pair<RocksDB, List<ColumnFamilyHandle>> dbPair = openLocalDB(dbDir, dbOpts, cfOpts);
  350. >         this.db = dbPair.getLeft();
  351.           this.metaCfHandle = dbPair.getRight().get(0);
  352.           this.dataCfHandle = dbPair.getRight().get(1);

#285
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:348: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.dbDir` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  346.           // open the rocksdb
  347.   
  348. >         this.dbDir = spec.getLocalStateStoreDir();
  349.           Pair<RocksDB, List<ColumnFamilyHandle>> dbPair = openLocalDB(dbDir, dbOpts, cfOpts);
  350.           this.db = dbPair.getLeft();

#286
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:323: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.dbOpts`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  321.   
  322.           dbOpts = new DBOptions();
  323. >         dbOpts.setCreateIfMissing(true);
  324.           dbOpts.setErrorIfExists(false);
  325.           dbOpts.setInfoLogLevel(DEFAULT_LOG_LEVEL);

#287
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:344: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.flushOpts`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  342.   
  343.           flushOpts = new FlushOptions();
  344. >         flushOpts.setWaitForFlush(true);
  345.   
  346.           // open the rocksdb

#288
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:343: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.flushOpts` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  341.           // initialize the flush options
  342.   
  343. >         flushOpts = new FlushOptions();
  344.           flushOpts.setWaitForFlush(true);
  345.   

#289
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:330: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.cfOpts`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  328.   
  329.           cfOpts = new ColumnFamilyOptions();
  330. >         cfOpts.setTableFormatConfig(tableConfig);
  331.           cfOpts.setWriteBufferSize(WRITE_BUFFER_SIZE);
  332.           cfOpts.setCompressionType(DEFAULT_COMPRESSION_TYPE);

#290
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:339: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.writeOpts`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  337.   
  338.           writeOpts = new WriteOptions();
  339. >         writeOpts.setDisableWAL(true); // disable wal, since the source of truth will be on distributedlog
  340.   
  341.           // initialize the flush options

#291
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:329: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.cfOpts` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  327.           dbOpts.setCreateMissingColumnFamilies(true);
  328.   
  329. >         cfOpts = new ColumnFamilyOptions();
  330.           cfOpts.setTableFormatConfig(tableConfig);
  331.           cfOpts.setWriteBufferSize(WRITE_BUFFER_SIZE);

#292
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/store/MVCCStoreFactoryImpl.java:164: warning: Thread Safety Violation
  Unprotected write. Non-private method `MVCCStoreFactoryImpl.openStore(...)` indirectly writes to field `this.checkpointStore` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  162.           MVCCAsyncStore<byte[], byte[]> store = getStore(scId, streamId, rangeId);
  163.           if (null == store) {
  164. >             return newStore(scId, streamId, rangeId, ttlSeconds);
  165.           } else {
  166.               return FutureUtils.value(store);

#293
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java:138: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerChecker$LedgerFragmentCallback.operationComplete(...)` reads without synchronization from container `this.badBookies` via call to `Map.keySet()`. Potentially races with write in method `LedgerChecker$LedgerFragmentCallback.operationComplete(...)`.
 Reporting because this access may occur on a background thread.
  136.                       }
  137.                       cb.operationComplete(rcToReturn,
  138. >                             fragment.subset(badBookies.keySet()));
  139.                   }
  140.               }

#294
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java:98: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerChecker$LedgerFragmentCallback.operationComplete(...)` indirectly reads without synchronization from container `this.badBookies` via call to `Map.keySet()`. Potentially races with write in method `LedgerChecker$LedgerFragmentCallback.operationComplete(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
   96.        * This will collect the bad bookies inside a ledger fragment.
   97.        */
   98. >     private static class LedgerFragmentCallback implements GenericCallback<LedgerFragment> {
   99.   
  100.           private final LedgerFragment fragment;

#295
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java:208: warning: Thread Safety Violation
  Unprotected write. Non-private method `BenchReadThroughputLatency$2.process(...)` indirectly mutates container `util.ReflectionUtils.constructorCache` via call to `Map.put(...)` outside of synchronization.
 Reporting because this access may occur on a background thread.
  206.                               if (event.getType() == Event.EventType.NodeCreated
  207.                                          && event.getPath().equals(nodepath)) {
  208. >                                 readLedger(conf, ledger.get(), passwd);
  209.                                   shutdownLatch.countDown();
  210.                               } else if (event.getType() == Event.EventType.NodeChildrenChanged) {

#296
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:169: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  167.           lKey.retain();
  168.           value.retain();
  169. >         return retryUtils.execute(() -> fromListenableFuture(
  170.               ClientCalls.futureUnaryCall(
  171.                   getChannel(pKey).newCall(getPutMethod(), getCallOptions()),

#297
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVAsyncStore.java:96: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVAsyncStore.put(...)` reads without synchronization from `this.writeIOScheduler`. Potentially races with write in method `RocksdbKVAsyncStore.init(...)`.
 Reporting because this access may occur on a background thread.
  94.               .setPutReq(KVUtils.newPutRequest(keyBytes, valBytes))
  95.               .build();
  96. >         return writeCommandReturnTxId(command).thenApplyAsync((revision) -> {
  97.               ByteBuf serializedBuf = KVUtils.serialize(valBytes, revision);
  98.               try {

#298
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVAsyncStore.java:90: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVAsyncStore.put(...)` reads without synchronization from `this.keyCoder`. Potentially races with write in method `RocksdbKVAsyncStore.init(...)`.
 Reporting because this access may occur on a background thread.
  88.           }
  89.   
  90. >         byte[] keyBytes = keyCoder.encode(key);
  91.           byte[] valBytes = valCoder.encode(value);
  92.   

#299
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVAsyncStore.java:91: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVAsyncStore.put(...)` reads without synchronization from `this.valCoder`. Potentially races with write in method `RocksdbKVAsyncStore.init(...)`.
 Reporting because this access may occur on a background thread.
  89.   
  90.           byte[] keyBytes = keyCoder.encode(key);
  91. >         byte[] valBytes = valCoder.encode(value);
  92.   
  93.           Command command = Command.newBuilder()

#300
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:75: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  73.    * A {@link PTable} implementation using simple grpc calls.
  74.    */
  75. > @Slf4j
  76.   public class PByteBufSimpleTableImpl
  77.       extends AbstractStub<PByteBufSimpleTableImpl>

#301
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:764: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readAsync(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  762.           }
  763.   
  764. >         return readEntriesInternalAsync(firstEntry, lastEntry, false);
  765.       }
  766.   

#302
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:643: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readEntries(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  641.           CompletableFuture<Enumeration<LedgerEntry>> result = new CompletableFuture<>();
  642.   
  643. >         asyncReadEntries(firstEntry, lastEntry, new SyncReadCallback(result), null);
  644.   
  645.           return SyncCallbackUtils.waitForResult(result);

#303
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:889: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readEntriesInternalAsync(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  887.                   DistributionSchedule.WriteSet ws = distributionSchedule.getWriteSet(firstEntry);
  888.                   try {
  889. >                     if (!waitForWritable(ws, ws.size() - 1, clientCtx.getConf().waitForWriteSetMs)) {
  890.                           op.allowFailFastOnUnwritableChannel();
  891.                       }

#304
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1762: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readExplicitLastConfirmed()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1760.       public long readExplicitLastConfirmed() throws InterruptedException, BKException {
  1761.           LastConfirmedCtx ctx = new LastConfirmedCtx();
  1762. >         asyncReadExplicitLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);
  1763.           synchronized (ctx) {
  1764.               while (!ctx.ready()) {

#305
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1518: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readLastAddConfirmedAndEntryAsync(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1516.                                                                                         boolean parallel) {
  1517.           FutureReadLastConfirmedAndEntry result = new FutureReadLastConfirmedAndEntry();
  1518. >         asyncReadLastConfirmedAndEntry(entryId, timeOutInMillis, parallel, result, null);
  1519.           return result;
  1520.       }

#306
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1506: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readLastAddConfirmedAsync()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1504.       public CompletableFuture<Long> readLastAddConfirmedAsync() {
  1505.           FutureReadLastConfirmed result = new FutureReadLastConfirmed();
  1506. >         asyncReadLastConfirmed(result, null);
  1507.           return result;
  1508.       }

#307
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1653: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readLastConfirmed()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1651.               throws InterruptedException, BKException {
  1652.           LastConfirmedCtx ctx = new LastConfirmedCtx();
  1653. >         asyncReadLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);
  1654.           synchronized (ctx) {
  1655.               while (!ctx.ready()) {

#308
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java:131: warning: Thread Safety Violation
  Unprotected write. Non-private method `LedgerRecoveryOp$1.readLastConfirmedDataComplete(...)` writes to field `this.this$0.metadataForRecovery` outside of synchronization.
 Reporting because this access may occur on a background thread.
  129.                               // keep a copy of ledger metadata before proceeding
  130.                               // ledger recovery
  131. >                             metadataForRecovery = lh.getLedgerMetadata();
  132.                               doRecoveryRead();
  133.                           } else if (rc == BKException.Code.TimeoutException) {

#309
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:862: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readLastEntry()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  860.           } else {
  861.               CompletableFuture<Enumeration<LedgerEntry>> result = new CompletableFuture<>();
  862. >             asyncReadEntries(lastEntryId, lastEntryId, new SyncReadCallback(result), null);
  863.   
  864.               return SyncCallbackUtils.waitForResult(result).nextElement();

#310
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:799: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readUnconfirmedAsync(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  797.           }
  798.   
  799. >         return readEntriesInternalAsync(firstEntry, lastEntry, false);
  800.       }
  801.   

#311
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:666: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readUnconfirmedEntries(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  664.           CompletableFuture<Enumeration<LedgerEntry>> result = new CompletableFuture<>();
  665.   
  666. >         asyncReadUnconfirmedEntries(firstEntry, lastEntry, new SyncReadCallback(result), null);
  667.   
  668.           return SyncCallbackUtils.waitForResult(result);

#312
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:273: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.recordReadErrorOnBookie(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  271.               // This will be idempotent when we have multiple read errors on the
  272.               // same bookie. The net result is that we just go to the next bookie
  273. >             stickyBookieIndex = clientCtx.getPlacementPolicy().getStickyReadBookieIndex(getLedgerMetadata(),
  274.                       Optional.of(bookieIndex));
  275.           }

#313
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:423: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZoneawareEnsemblePlacementPolicyImpl.replaceBookie(...)` reads without synchronization from `this.desiredNumZonesPerWriteQuorum`. Potentially races with write in method `ZoneawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  421.               throws BKNotEnoughBookiesException {
  422.           int bookieToReplaceIndex = currentEnsemble.indexOf(bookieToReplace);
  423. >         int desiredNumZonesPerWriteQuorumForThisEnsemble = (writeQuorumSize < desiredNumZonesPerWriteQuorum)
  424.                   ? writeQuorumSize : desiredNumZonesPerWriteQuorum;
  425.           List<BookieId> newEnsemble = new ArrayList<BookieId>(currentEnsemble);

#314
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java:202: warning: Thread Safety Violation
  Unprotected write. Non-private method `BenchThroughputLatency.run()` writes to field `this.throughput` outside of synchronization.
 Reporting because this access may occur on a background thread.
  200.               duration = System.currentTimeMillis() - start;
  201.           }
  202. >         throughput = sent * 1000 / getDuration();
  203.   
  204.           reporter.interrupt();

#315
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java:140: warning: Thread Safety Violation
  Unprotected write. Non-private method `BenchThroughputLatency.run()` writes to field `this.previous` outside of synchronization.
 Reporting because this access may occur on a background thread.
  138.       public void run() {
  139.           LOG.info("Running...");
  140. >         long start = previous = System.currentTimeMillis();
  141.   
  142.           int sent = 0;

#316
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java:180: warning: Thread Safety Violation
  Read/Write race. Non-private method `BenchThroughputLatency.run()` reads without synchronization from `this.bytes`. Potentially races with write in method `BenchThroughputLatency.setEntryData(...)`.
 Reporting because this access may occur on a background thread.
  178.               } else {
  179.                   long nanoTime = System.nanoTime();
  180. >                 lh[index].asyncAddEntry(bytes, this, new Context(sent, nanoTime));
  181.                   counter.incrementAndGet();
  182.               }

#317
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java:210: warning: Thread Safety Violation
  Read/Write race. Non-private method `BenchThroughputLatency.run()` reads without synchronization from `this.throughput`. Potentially races with write in method `BenchThroughputLatency.run()`.
 Reporting because this access may occur on a background thread.
  208.               Thread.currentThread().interrupt();
  209.           }
  210. >         LOG.info("Finished processing in ms: " + getDuration() + " tp = " + throughput);
  211.       }
  212.   

#318
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java:77: warning: Thread Safety Violation
  Read/Write race. Non-private method `ReadOnlyLedgerHandle$MetadataUpdater.safeRun()` indirectly reads without synchronization from `this.this$0.versionedMetadata`. Potentially races with write in method `ReadOnlyLedgerHandle$MetadataUpdater.safeRun()`.
 Reporting because this access may occur on a background thread.
  75.           public void safeRun() {
  76.               while (true) {
  77. >                 Versioned<LedgerMetadata> currentMetadata = getVersionedLedgerMetadata();
  78.                   Version.Occurred occurred = currentMetadata.getVersion().compare(newMetadata.getVersion());
  79.                   if (Version.Occurred.BEFORE == occurred) {

#319
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1823: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.sendAddSuccessCallbacks()` reads without synchronization from `this.changingEnsemble`. Potentially races with write in method `LedgerHandle.maybeHandleDelayedWriteBookieFailure()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1821.           PendingAddOp pendingAddOp;
  1822.   
  1823. >         while ((pendingAddOp = pendingAddOps.peek()) != null
  1824.                  && !changingEnsemble) {
  1825.               if (!pendingAddOp.completed) {

#320
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java:113: warning: Thread Safety Violation
  Read/Write race. Non-private method `PacketProcessorBase.sendResponse(...)` reads without synchronization from `this.enqueueNanos`. Potentially races with write in method `PacketProcessorBase.reset()`.
 Reporting because this access may occur on a background thread.
  111.                   requestProcessor.getRequestStats().getChannelWriteStats()
  112.                       .registerFailedEvent(MathUtils.elapsedNanos(writeNanos), TimeUnit.NANOSECONDS);
  113. >                 statsLogger.registerFailedEvent(MathUtils.elapsedNanos(enqueueNanos), TimeUnit.NANOSECONDS);
  114.                   if (response instanceof BookieProtocol.Response) {
  115.                       ((BookieProtocol.Response) response).release();

#321
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java:111: warning: Thread Safety Violation
  Read/Write race. Non-private method `PacketProcessorBase.sendResponse(...)` reads without synchronization from `this.requestProcessor`. Potentially races with write in method `PacketProcessorBase.reset()`.
 Reporting because this access may occur on a background thread.
  109.                   logger.warn("cannot write response to non-writable channel {} for request {}", channel,
  110.                       StringUtils.requestToString(request));
  111. >                 requestProcessor.getRequestStats().getChannelWriteStats()
  112.                       .registerFailedEvent(MathUtils.elapsedNanos(writeNanos), TimeUnit.NANOSECONDS);
  113.                   statsLogger.registerFailedEvent(MathUtils.elapsedNanos(enqueueNanos), TimeUnit.NANOSECONDS);

#322
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java:110: warning: Thread Safety Violation
  Read/Write race. Non-private method `PacketProcessorBase.sendResponse(...)` reads without synchronization from `this.request`. Potentially races with write in method `PacketProcessorBase.reset()`.
 Reporting because this access may occur on a background thread.
  108.               if (!channel.isWritable()) {
  109.                   logger.warn("cannot write response to non-writable channel {} for request {}", channel,
  110. >                     StringUtils.requestToString(request));
  111.                   requestProcessor.getRequestStats().getChannelWriteStats()
  112.                       .registerFailedEvent(MathUtils.elapsedNanos(writeNanos), TimeUnit.NANOSECONDS);

#323
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java:108: warning: Thread Safety Violation
  Read/Write race. Non-private method `PacketProcessorBase.sendResponse(...)` reads without synchronization from `this.channel`. Potentially races with write in method `PacketProcessorBase.reset()`.
 Reporting because this access may occur on a background thread.
  106.               }
  107.   
  108. >             if (!channel.isWritable()) {
  109.                   logger.warn("cannot write response to non-writable channel {} for request {}", channel,
  110.                       StringUtils.requestToString(request));

#324
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:108: warning: Thread Safety Violation
  Read/Write race. Non-private method `RangeRouter.setRanges(...)` reads without synchronization from `this.ranges`. Potentially races with write in method `RangeRouter.setRanges(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  106.           try {
  107.               // we only update the routing only when see new active ranges
  108. >             if ((this.ranges == null)
  109.                   || (ranges.getMaxRangeId() > this.ranges.getMaxRangeId())) {
  110.                   HashStreamRanges oldRanges = this.ranges;

#325
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:111: warning: Thread Safety Violation
  Unprotected write. Non-private method `RangeRouter.setRanges(...)` writes to field `this.ranges` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  109.                   || (ranges.getMaxRangeId() > this.ranges.getMaxRangeId())) {
  110.                   HashStreamRanges oldRanges = this.ranges;
  111. >                 this.ranges = ranges;
  112.                   return oldRanges;
  113.               } else {

#326
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataClientDriver.java:101: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKMetadataClientDriver.setSessionStateListener(...)` reads without synchronization from `this.zk`. Potentially races with write in method `ZKMetadataClientDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
   99.       @Override
  100.       public void setSessionStateListener(SessionStateListener sessionStateListener) {
  101. >         zk.register((event) -> {
  102.               // Check for expired connection.
  103.               if (event.getType().equals(EventType.None) && event.getState().equals(KeeperState.Expired)) {

#327
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java:242: warning: Thread Safety Violation
  Read/Write race. Non-private method `AuditorElector.shutdown()` reads without synchronization from `this.auditor`. Potentially races with write in method `AuditorElector.shutdown()`.
 Reporting because this access may occur on a background thread.
  240.           }
  241.   
  242. >         if (auditor != null) {
  243.               auditor.shutdown();
  244.               auditor = null;

#328
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java:244: warning: Thread Safety Violation
  Unprotected write. Non-private method `AuditorElector.shutdown()` writes to field `this.auditor` outside of synchronization.
 Reporting because this access may occur on a background thread.
  242.           if (auditor != null) {
  243.               auditor.shutdown();
  244. >             auditor = null;
  245.           }
  246.           if (ownBkc) {

#329
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieImpl.java:813: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieImpl.shutdown()` indirectly reads without synchronization from `this.exitCode`. Potentially races with write in method `BookieImpl.start()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  811.       // to shut down bookie gracefully
  812.       public int shutdown() {
  813. >         return shutdown(ExitCode.OK);
  814.       }
  815.       // internal shutdown method to let shutdown bookie gracefully

#330
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/SingleDirectoryDbLedgerStorage.java:267: warning: Thread Safety Violation
  Read/Write race. Non-private method `SingleDirectoryDbLedgerStorage.shutdown()` indirectly reads without synchronization from `this.lastCheckpoint`. Potentially races with write in method `SingleDirectoryDbLedgerStorage.checkpoint(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  265.       public void shutdown() throws InterruptedException {
  266.           try {
  267. >             flush();
  268.   
  269.               gcThread.shutdown();

#331
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieImpl.java:863: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieImpl.shutdown(...)` reads without synchronization from `this.exitCode`. Potentially races with write in method `BookieImpl.shutdown()`.
 Reporting because this access may occur on a background thread.
  861.               stateManager.close();
  862.           }
  863. >         return this.exitCode;
  864.       }
  865.   

#332
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SnapshotMap.java:62: warning: Thread Safety Violation
  Read/Write race. Non-private method `SnapshotMap.snapshot()` reads without synchronization from container `this.updatesToMerge` via call to `Map.entrySet()`. Potentially races with write in method `SnapshotMap.remove(...)`.
 Reporting because this access may occur on a background thread.
  60.           }
  61.           // merging the updates to snapshot
  62. >         for (Map.Entry<K, V> entry : updatesToMerge.entrySet()) {
  63.               snapshot.put(entry.getKey(), entry.getValue());
  64.           }

#333
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java:126: warning: Thread Safety Violation
  Unprotected write. Non-private method `BookieServer.start()` writes to field `this.exitCode` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  124.           // fail fast, when bookie startup is not successful
  125.           if (!this.bookie.isRunning()) {
  126. >             exitCode = bookie.getExitCode();
  127.               this.requestProcessor.close();
  128.               return;

#334
stream/common/src/main/java/org/apache/bookkeeper/common/grpc/proxy/ProxyServerCallHandler.java:45: warning: Interface Not Thread Safe
  Unprotected call to method `ChannelFinder.findChannel(...)` of un-annotated interface `org.apache.bookkeeper.common.grpc.proxy.ChannelFinder`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.ServerCallHandler` is annotated `@ThreadSafe`.
  43.       @Override
  44.       public Listener<ReqT> startCall(ServerCall<ReqT, RespT> serverCall, Metadata headers) {
  45. >         Channel channel = finder.findChannel(serverCall, headers);
  46.           ClientCall<ReqT, RespT> clientCall = channel.newCall(
  47.               serverCall.getMethodDescriptor(), callOptions);

#335
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:145: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.toOpStatData()` reads without synchronization from `this.latencyBuckets.[_]`. Potentially races with write in method `BKStats$OpStats.updateLatency(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  143.               StringBuilder sb = new StringBuilder();
  144.               for (int i = 0; i < NUM_BUCKETS; i++) {
  145. >                 sb.append(latencyBuckets[i]);
  146.                   if (i != NUM_BUCKETS - 1) {
  147.                       sb.append(',');

#336
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:142: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.toOpStatData()` reads without synchronization from `this.numSuccessOps`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  140.   
  141.           public OpStatData toOpStatData() {
  142. >             double avgLatency = numSuccessOps > 0 ? totalLatency / numSuccessOps : 0.0f;
  143.               StringBuilder sb = new StringBuilder();
  144.               for (int i = 0; i < NUM_BUCKETS; i++) {

#337
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:151: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.toOpStatData()` reads without synchronization from `this.maxLatency`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  149.               }
  150.   
  151. >             return new OpStatData(maxLatency, minLatency, avgLatency, numSuccessOps, numFailedOps, sb.toString());
  152.           }
  153.   

#338
stream/distributedlog/core/src/main/java/org/apache/distributedlog/EntryPosition.java:60: warning: Thread Safety Violation
  Read/Write race. Non-private method `EntryPosition.toString()` reads without synchronization from `this.entryId`. Potentially races with write in method `EntryPosition.advance(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  58.       public String toString() {
  59.           StringBuilder sb = new StringBuilder();
  60. >         sb.append("(").append(lssn).append(", ").append(entryId).append(")");
  61.           return sb.toString();
  62.       }

#339
bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java:90: warning: Thread Safety Violation
  Read/Write race. Non-private method `InMemoryMetastoreTable$MetadataVersion.toString()` reads without synchronization from `this.version`. Potentially races with write in method `InMemoryMetastoreTable$MetadataVersion.incrementVersion()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  88.           @Override
  89.           public String toString() {
  90. >             return "version=" + version;
  91.           }
  92.   

#340
bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopologyImpl.java:839: warning: Thread Safety Violation
  Read/Write race. Non-private method `NetworkTopologyImpl.toString()` reads without synchronization from `this.numOfRacks`. Potentially races with write in method `NetworkTopologyImpl.remove(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  837.           StringBuilder tree = new StringBuilder();
  838.           tree.append("Number of racks: ");
  839. >         tree.append(numOfRacks);
  840.           tree.append("\n");
  841.           // print the number of leaves

#341
bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopologyImpl.java:848: warning: Thread Safety Violation
  Read/Write race. Non-private method `NetworkTopologyImpl.toString()` indirectly reads without synchronization from container `this.clusterMap.children` via call to `List.isEmpty()`. Potentially races with write in method `NetworkTopologyImpl.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  846.           // print nodes
  847.           for (int i = 0; i < numOfLeaves; i++) {
  848. >             tree.append(NodeBase.getPath(clusterMap.getLeaf(i, null)));
  849.               tree.append("\n");
  850.           }

#342
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java:412: warning: Thread Safety Violation
  Read/Write race. Non-private method `RoundRobinDistributionSchedule$RRQuorumCoverageSet.toString()` reads without synchronization from `this.covered.[_]`. Potentially races with write in method `RoundRobinDistributionSchedule$RRQuorumCoverageSet.addBookie(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  410.                   buffer.append(covered[i]).append(", ");
  411.               }
  412. >             buffer.append(covered[i]).append("]");
  413.               return buffer.toString();
  414.           }

#343
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1496: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.tryReadLastAddConfirmedAsync()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1494.       public CompletableFuture<Long> tryReadLastAddConfirmedAsync() {
  1495.           FutureReadLastConfirmed result = new FutureReadLastConfirmed();
  1496. >         asyncTryReadLastConfirmed(result, null);
  1497.           return result;
  1498.       }

#344
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1681: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.tryReadLastConfirmed()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1679.       public long tryReadLastConfirmed() throws InterruptedException, BKException {
  1680.           LastConfirmedCtx ctx = new LastConfirmedCtx();
  1681. >         asyncTryReadLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);
  1682.           synchronized (ctx) {
  1683.               while (!ctx.ready()) {

#345
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:578: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.update(...)` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  576.       @Override
  577.       public void update(long duration, TimeUnit unit) {
  578. >         update(unit.toNanos(duration));
  579.       }
  580.   

#346
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:258: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.updateLastRevision(...)` reads without synchronization from `this.metaCfHandle`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  256.                   // update revision
  257.                   setLastRevision(revision);
  258. >                 batch.put(metaCfHandle, LAST_REVISION, lastRevisionBytes);
  259.               } catch (RocksDBException e) {
  260.                   throw new StateStoreRuntimeException(

#347
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:257: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.updateLastRevision(...)` indirectly writes to field `this.lastRevisionBytes.[_]` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  255.               try {
  256.                   // update revision
  257. >                 setLastRevision(revision);
  258.                   batch.put(metaCfHandle, LAST_REVISION, lastRevisionBytes);
  259.               } catch (RocksDBException e) {

#348
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/WeightedRandomSelectionImpl.java:102: warning: Thread Safety Violation
  Read/Write race. Non-private method `WeightedRandomSelectionImpl.updateMap(...)` reads without synchronization from `this.maxProbabilityMultiplier`. Potentially races with write in method `WeightedRandomSelectionImpl.setMaxProbabilityMultiplier(...)`.
 Reporting because this access may occur on a background thread.
  100.           }
  101.   
  102. >         double maxWeight = maxProbabilityMultiplier * medianWeight;
  103.           Map<T, Double> weightMap = new HashMap<T, Double>();
  104.           for (Map.Entry<T, WeightedObject> e : map.entrySet()) {

Found 349 issues
                            Issue Type(ISSUED_TYPE_ID): #
      Thread Safety Violation(THREAD_SAFETY_VIOLATION): 210
                    Null Dereference(NULL_DEREFERENCE): 91
                          Resource Leak(RESOURCE_LEAK): 34
  Interface Not Thread Safe(INTERFACE_NOT_THREAD_SAFE): 14
