#0
tools/framework/src/main/java/org/apache/bookkeeper/tools/framework/CliCommandGroup.java:47: error: Null Dereference
  object returned by `newSpec.commands()` could be null and is dereferenced at line 47.
  45.           String path = newSpec.parent() + " " + newSpec.name();
  46.   
  47. >         for (Command<GlobalFlagsT> cmd : newSpec.commands()) {
  48.               if (cmd instanceof CliCommand) {
  49.                   CliCommand<GlobalFlagsT, GlobalFlagsT> cliCmd = (CliCommand<GlobalFlagsT, GlobalFlagsT>) cmd;

#1
circe-checksum/src/main/java/com/scurrilous/circe/utils/NativeUtils.java:36: error: Null Dereference
  object returned by `getProperty("os.name")` could be null and is dereferenced at line 36.
  34.   public class NativeUtils {
  35.   
  36. >     public static final String OS_NAME = System.getProperty("os.name").toLowerCase(Locale.US);
  37.   
  38.       /**

#2
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Shell.java:51: error: Null Dereference
  object returned by `getProperty("os.name")` could be null and is dereferenced at line 51.
  49.        */
  50.       public static final boolean WINDOWS = /* borrowed from Path.WINDOWS */
  51. >             System.getProperty("os.name").startsWith("Windows");
  52.   
  53.       private long interval; // refresh interval in msec

#3
stream/distributedlog/core/src/main/java/org/apache/distributedlog/feature/AbstractFeatureProvider.java:54: error: Null Dereference
  object `featureProviderClass` last assigned on line 47 could be null and is dereferenced at line 54.
  52.           Constructor<? extends FeatureProvider> constructor;
  53.           try {
  54. >             constructor = featureProviderClass.getDeclaredConstructor(
  55.                       String.class,
  56.                       DistributedLogConfiguration.class,

#4
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/KVCommandProcessor.java:57: error: Null Dereference
  object returned by `command.getReqCase()` could be null and is dereferenced at line 57.
  55.           }
  56.   
  57. >         switch (command.getReqCase()) {
  58.               case NOP_REQ:
  59.                   break;

#5
bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/cli/commands/bookie/LastMarkCommand.java:60: error: Null Dereference
  object returned by `getLastLogMark(journal)` could be null and is dereferenced at line 60.
  58.           for (int idx = 0; idx < journalDirs.length; idx++) {
  59.               Journal journal = new Journal(idx, journalDirs[idx], conf, dirsManager);
  60. >             LogMark lastLogMark = journal.getLastLogMark().getCurMark();
  61.               LOG.info("LastLogMark : Journal Id - " + lastLogMark.getLogFileId() + "("
  62.                   + Long.toHexString(lastLogMark.getLogFileId()) + ".txn), Pos - "

#6
cpu-affinity/src/main/java/org/apache/bookkeeper/common/util/affinity/impl/NativeUtils.java:69: error: Resource Leak
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 70 is not released after line 69.
**Note**: potential exception at line 75
  67.           int read;
  68.   
  69. >         try (InputStream input = NativeUtils.class.getResourceAsStream(path);
  70.                   OutputStream out = new FileOutputStream(temp)) {
  71.               if (input == null) {

#7
bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/cli/commands/autorecovery/TriggerAuditCommand.java:59: error: Null Dereference
  object `admin.mFactory` last assigned on line 56 could be null and is dereferenced by call to `triggerAudit()` at line 59.
  57.   
  58.           try {
  59. >             admin.triggerAudit();
  60.           } finally {
  61.               if (admin != null) {

#8
cpu-affinity/src/main/java/org/apache/bookkeeper/common/util/affinity/impl/IsolatedProcessors.java:57: error: Null Dereference
  object returned by `trim(range)` could be null and is dereferenced at line 57.
  55.           SortedSet<Integer> processors = new TreeSet<>();
  56.   
  57. >         for (String part : StringUtils.trim(range).split(",")) {
  58.               if (part.contains("-")) {
  59.                   // This is a range, eg: 1-5 with both edges included

#9
cpu-affinity/src/main/java/org/apache/bookkeeper/common/util/affinity/impl/ProcessorsInfo.java:74: error: Null Dereference
  object `key` last assigned on line 71 could be null and is dereferenced at line 74.
  72.                   String value = StringUtils.trim(parts[1]);
  73.   
  74. >                 if (key.equals("core id")) {
  75.                       coreId = Integer.parseInt(value);
  76.                   } else if (key.equals("processor")) {

#10
bookkeeper-server/src/main/java/org/apache/bookkeeper/sasl/SASLClientProviderFactory.java:69: error: Null Dereference
  object `SASLClientProviderFactory.login` last assigned on line 68 could be null and is dereferenced at line 69.
  67.   
  68.               this.login = loginClient();
  69. >             this.subject = login.getSubject();
  70.               this.isKrbTicket = !subject.getPrivateCredentials(KerberosTicket.class).isEmpty();
  71.               boolean systemRole = CLIENT_ROLE_SYSTEM.equals(clientConfiguration.getClientRole());

#11
bookkeeper-server/src/main/java/org/apache/bookkeeper/sasl/SASLBookieAuthProviderFactory.java:85: error: Null Dereference
  object `SASLBookieAuthProviderFactory.login` last assigned on line 84 could be null and is dereferenced at line 85.
  83.   
  84.               this.login = loginServer();
  85. >             this.subject = login.getSubject();
  86.               this.isKrbTicket = !subject.getPrivateCredentials(KerberosTicket.class).isEmpty();
  87.               if (isKrbTicket) {

#12
bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/cli/commands/autorecovery/WhoIsAuditorCommand.java:80: error: Null Dereference
  object `bka.mFactory` last assigned on line 79 could be null and is dereferenced by call to `getCurrentAuditor()` at line 80.
  78.               @Cleanup
  79.               BookKeeperAdmin bka = new BookKeeperAdmin(clientConfiguration);
  80. >             bookieId = bka.getCurrentAuditor();
  81.           }
  82.           if (bookieId == null) {

#13
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/utils/NetUtils.java:79: error: Null Dereference
  object `endpointParts` last assigned on line 78 could be null and is dereferenced at line 79.
  77.       public static List<Endpoint> parseEndpoints(String endpointStr) {
  78.           String[] endpointParts = StringUtils.split(endpointStr, ',');
  79. >         checkArgument(endpointParts.length > 0,
  80.               "Invalid endpoint strings %s", endpointStr);
  81.           List<Endpoint> endpoints = Lists.newArrayListWithExpectedSize(endpointParts.length);

#14
tools/ledger/src/main/java/org/apache/bookkeeper/tools/cli/commands/bookieid/SearchReplaceBookieIdCommand.java:82: error: Resource Leak
  resource of type `org.apache.bookkeeper.client.BookKeeperAdmin` acquired to `admin` by call to `new()` at line 82 is not released after line 82.
**Note**: potential exception at line 86
  80.       @Override
  81.       protected void run(BookKeeper bk, Flags flags) throws Exception {
  82. >         try (BookKeeperAdmin admin = new BookKeeperAdmin((org.apache.bookkeeper.client.BookKeeper) bk)) {
  83.               LedgerManager ledgerManager = ((org.apache.bookkeeper.client.BookKeeper) bk).getLedgerManager();
  84.               long i = 0;

#15
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdUtils.java:84: error: Null Dereference
  object `keyParts` last assigned on line 83 could be null and is dereferenced at line 84.
  82.       static UUID parseLedgerKey(String ledgerKey) {
  83.           String[] keyParts = StringUtils.split(ledgerKey, '/');
  84. >         return UUID.fromString(keyParts[keyParts.length - 1]);
  85.       }
  86.   

#16
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BookKeeperClient.java:111: error: Null Dereference
  object `dnsResolverCls` last assigned on line 105 could be null and is dereferenced by call to `getDNSResolver(...)` at line 111.
  109.           }
  110.           final DNSToSwitchMapping dnsResolver =
  111. >                 NetUtils.getDNSResolver(dnsResolverCls, conf.getBkDNSResolverOverrides());
  112.   
  113.           try {

#17
bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/cli/commands/autorecovery/LostBookieRecoveryDelayCommand.java:104: error: Null Dereference
  object `admin.mFactory` last assigned on line 101 could be null and is dereferenced by call to `getLostBookieRecoveryDelay()` at line 104.
  102.           try {
  103.               if (getter) {
  104. >                 int lostBookieRecoveryDelay = admin.getLostBookieRecoveryDelay();
  105.                   LOG.info("LostBookieRecoveryDelay value in ZK: {}", String.valueOf(lostBookieRecoveryDelay));
  106.               } else {

#18
bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/cli/commands/autorecovery/LostBookieRecoveryDelayCommand.java:108: error: Null Dereference
  object `admin.mFactory` last assigned on line 101 could be null and is dereferenced by call to `setLostBookieRecoveryDelay(...)` at line 108.
  106.               } else {
  107.                   int lostBookieRecoveryDelay = flags.set;
  108. >                 admin.setLostBookieRecoveryDelay(lostBookieRecoveryDelay);
  109.                   LOG.info("Successfully set LostBookieRecoveryDelay value in ZK: {}",
  110.                            String.valueOf(lostBookieRecoveryDelay));

#19
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/HardLink.java:89: error: Null Dereference
  object `osName` last assigned on line 88 could be null and is dereferenced at line 89.
  87.     private static OSType getOSType() {
  88.       String osName = System.getProperty("os.name");
  89. >     if (osName.contains("Windows") && (osName.contains("XP")
  90.               || osName.contains("2003")
  91.               || osName.contains("Vista")

#20
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataDriverBase.java:97: error: Null Dereference
  object `schemeParts` last assigned on line 96 could be null and is dereferenced at line 97.
  95.           checkNotNull(scheme, "Invalid metadata service : " + metadataServiceUri);
  96.           String[] schemeParts = StringUtils.split(scheme.toLowerCase(), '+');
  97. >         checkArgument(SCHEME.equals(schemeParts[0]), "Unknown metadata service scheme found : "
  98.               + schemeParts[0]);
  99.           Class<? extends LedgerManagerFactory> ledgerManagerFactoryClass;

#21
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java:98: error: Null Dereference
  object `metadataClientDriver` last assigned on line 97 could be null and is dereferenced at line 98.
   96.           this.bkc = Auditor.createBookKeeperClient(conf, statsLogger.scope(BookKeeperClientStats.CLIENT_SCOPE));
   97.           MetadataClientDriver metadataClientDriver = bkc.getMetadataClientDriver();
   98. >         metadataClientDriver.setSessionStateListener(() -> {
   99.               LOG.error("Client connection to the Metadata server has expired, so shutting down AutoRecoveryMain!");
  100.               // do not run "shutdown" in the main ZooKeeper client thread

#22
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/utils/NetUtils.java:96: error: Null Dereference
  object `endpointParts` last assigned on line 95 could be null and is dereferenced at line 96.
  94.       public static Endpoint parseEndpoint(String endpointStr) {
  95.           String[] endpointParts = StringUtils.split(endpointStr, ':');
  96. >         checkArgument(2 == endpointParts.length,
  97.               "Invalid endpoint string %s - It should be 'host:port'.", endpointStr);
  98.           String host = endpointParts[0];

#23
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/DbLedgerStorage.java:132: error: Null Dereference
  object returned by `getListeners(ldm)` could be null and is dereferenced at line 132.
  130.                       stateManager, checkpointSource, checkpointer, statsLogger, gcExecutor, perDirectoryWriteCacheSize,
  131.                       perDirectoryReadCacheSize));
  132. >             ldm.getListeners().forEach(ledgerDirsManager::addLedgerDirsListener);
  133.           }
  134.   

#24
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/http/service/ClusterInfoService.java:104: error: Null Dereference
  object returned by `ClusterInfoService.bka.getAllBookies()` could be null and is dereferenced at line 104.
  102.       @SneakyThrows
  103.       private void fillBookiesInfo(ClusterInfo info) {
  104. >         int totalBookiesCount = bka.getAllBookies().size();
  105.           int writableBookiesCount = bka.getAvailableBookies().size();
  106.           int readonlyBookiesCount = bka.getReadOnlyBookies().size();

#25
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/http/service/ClusterInfoService.java:105: error: Null Dereference
  object returned by `ClusterInfoService.bka.getAvailableBookies()` could be null and is dereferenced at line 105.
  103.       private void fillBookiesInfo(ClusterInfo info) {
  104.           int totalBookiesCount = bka.getAllBookies().size();
  105. >         int writableBookiesCount = bka.getAvailableBookies().size();
  106.           int readonlyBookiesCount = bka.getReadOnlyBookies().size();
  107.           int unavailableBookiesCount = totalBookiesCount - writableBookiesCount - readonlyBookiesCount;

#26
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/http/service/ClusterInfoService.java:106: error: Null Dereference
  object returned by `ClusterInfoService.bka.getReadOnlyBookies()` could be null and is dereferenced at line 106.
  104.           int totalBookiesCount = bka.getAllBookies().size();
  105.           int writableBookiesCount = bka.getAvailableBookies().size();
  106. >         int readonlyBookiesCount = bka.getReadOnlyBookies().size();
  107.           int unavailableBookiesCount = totalBookiesCount - writableBookiesCount - readonlyBookiesCount;
  108.   

#27
stream/common/src/main/java/org/apache/bookkeeper/common/grpc/stats/ClientStats.java:115: error: Null Dereference
  object `serviceName` last assigned on line 114 could be null and is dereferenced at line 115.
  113.               String fullMethodName = methodDescriptor.getFullMethodName();
  114.               String serviceName = MethodDescriptor.extractFullServiceName(fullMethodName);
  115. >             String methodName = fullMethodName.substring(serviceName.length() + 1);
  116.   
  117.               MethodType type = methodDescriptor.getType();

#28
stream/common/src/main/java/org/apache/bookkeeper/common/grpc/stats/ServerStats.java:115: error: Null Dereference
  object `serviceName` last assigned on line 114 could be null and is dereferenced at line 115.
  113.               String fullMethodName = methodDescriptor.getFullMethodName();
  114.               String serviceName = MethodDescriptor.extractFullServiceName(fullMethodName);
  115. >             String methodName = fullMethodName.substring(serviceName.length() + 1);
  116.   
  117.               MethodType type = methodDescriptor.getType();

#29
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/subscription/ZKSubscriptionsStore.java:118: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `getLastCommitPositionFromZK()` at line 118 is not released after line 118.
  116.               CompletableFuture<Pair<String, DLSN>> future =
  117.                   // Get the last commit position from zookeeper
  118. >                 getSubscriber(subscriber).getLastCommitPositionFromZK().thenApply(
  119.                       dlsn -> Pair.of(subscriber, dlsn));
  120.               futures.add(future);

#30
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java:116: error: Null Dereference
  object returned by `PacketProcessorBaseV3.request.getHeader().getVersion()` could be null and is dereferenced at line 116.
  114.   
  115.       protected boolean isVersionCompatible() {
  116. >         return this.request.getHeader().getVersion().equals(ProtocolVersion.VERSION_THREE);
  117.       }
  118.   

#31
stream/clients/java/all/src/main/java/org/apache/bookkeeper/clients/StorageClientImpl.java:138: error: Resource Leak
  resource of type `org.apache.bookkeeper.clients.impl.kv.PByteBufTableImpl` acquired by call to `PByteBufTableImpl(...)` at line 137 is not released after line 138.
  136.                       scheduler.chooseThread(props.getStreamId()),
  137.                       settings.backoffPolicy()
  138. >                 ).initialize();
  139.               }),
  140.               future

#32
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java:132: error: Null Dereference
  object `bk` last assigned on line 128 could be null and is dereferenced at line 132.
  130.               return FutureUtils.exception(e);
  131.           }
  132. >         bk.asyncDeleteLedger(segment.getLogSegmentId(), this, request);
  133.           return request.deletePromise;
  134.       }

#33
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java:174: error: Null Dereference
  object `ensemble` last assigned on line 130 could be null and is dereferenced by call to `newEnsembleEntry(...)` at line 174.
  172.               .withEnsembleSize(actualEnsembleSize).withWriteQuorumSize(writeQuorumSize).withAckQuorumSize(ackQuorumSize)
  173.               .withDigestType(digestType.toApiDigestType()).withPassword(passwd);
  174. >         metadataBuilder.newEnsembleEntry(0L, ensemble);
  175.           if (customMetadata != null) {
  176.               metadataBuilder.withCustomMetadata(customMetadata);

#34
tests/integration-tests-utils/src/main/java/org/apache/bookkeeper/tests/integration/utils/DockerUtils.java:135: error: Resource Leak
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 141 is not released after line 135.
**Note**: potential exception at line 145
  133.           final int readBlockSize = 10000;
  134.   
  135. >         try (InputStream dockerStream = docker.copyArchiveFromContainerCmd(containerId, path).exec();
  136.                TarArchiveInputStream stream = new TarArchiveInputStream(dockerStream)) {
  137.               TarArchiveEntry entry = stream.getNextTarEntry();

#35
tests/integration-tests-utils/src/main/java/org/apache/bookkeeper/tests/integration/utils/DockerUtils.java:152: error: Resource Leak
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 141 is not released after line 152.
**Note**: potential exception at line 145
  150.                   entry = stream.getNextTarEntry();
  151.               }
  152. >         } catch (RuntimeException | IOException e) {
  153.               LOG.error("Error reading bk logs from container {}", containerId, e);
  154.           }

#36
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCCommandProcessor.java:144: error: Null Dereference
  object returned by `command.getReqCase()` could be null and is dereferenced at line 144.
  142.       public void applyCommand(long txid, ByteBuf cmdBuf, MVCCStoreImpl<byte[], byte[]> store) {
  143.           Command command = MVCCUtils.newCommand(cmdBuf);
  144. >         switch (command.getReqCase()) {
  145.               case NOP_REQ:
  146.                   return;

#37
stream/distributedlog/core/src/main/java/org/apache/bookkeeper/client/LedgerReader.java:150: error: Null Dereference
  object returned by `future(op)` could be null and is dereferenced at line 150.
  148.               private void readNext(long entryId) {
  149.                   PendingReadOp op = new PendingReadOp(lh, clientCtx, entryId, entryId, false);
  150. >                 op.future().whenComplete(this);
  151.                   op.submit();
  152.               }

#38
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCUtils.java:151: error: Null Dereference
  object returned by `protoOp.getRequestCase()` could be null and is dereferenced at line 151.
  149.   
  150.       public static Op<byte[], byte[]> toApiOp(RequestOp protoOp) {
  151. >         switch (protoOp.getRequestCase()) {
  152.               case REQUEST_PUT:
  153.                   return ProtoPutOpImpl.newPutOp(protoOp.getRequestPut());

#39
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerMetadataSerDe.java:190: error: Null Dereference
  object returned by `metadata.getDigestType()` could be null and is dereferenced by call to `apiToProtoDigestType(...)` at line 190.
  188.   
  189.   
  190. >             builder.setDigestType(apiToProtoDigestType(metadata.getDigestType()));
  191.   
  192.               serializePassword(metadata.getPassword(), builder);

#40
stream/distributedlog/core/src/main/java/org/apache/distributedlog/namespace/NamespaceDriverManager.java:168: error: Null Dereference
  object `schemeParts` last assigned on line 167 could be null and is dereferenced at line 168.
  166.           scheme = scheme.toLowerCase();
  167.           String[] schemeParts = StringUtils.split(scheme, '-');
  168. >         checkArgument(schemeParts.length > 0,
  169.                   "Invalid distributedlog scheme found : " + uri);
  170.           checkArgument(Objects.equal(DistributedLogConstants.SCHEME_PREFIX, schemeParts[0].toLowerCase()),

#41
stream/distributedlog/core/src/main/java/org/apache/distributedlog/auditor/DLAuditor.java:172: error: Null Dereference
  object returned by `bkc.get()` could be null and is dereferenced by call to `getLedgerManager(...)` at line 172.
  170.                                              final ExecutorService executorService)
  171.               throws IOException {
  172. >         LedgerManager lm = BookKeeperAccessor.getLedgerManager(bkc.get());
  173.   
  174.           final Set<Long> ledgers = new HashSet<Long>();

#42
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/storage/GetStreamRequest.java:193: error: Null Dereference
  object returned by `getIdCase()` could be null and is dereferenced at line 193.
  191.       org.apache.bookkeeper.stream.proto.storage.GetStreamRequest other = (org.apache.bookkeeper.stream.proto.storage.GetStreamRequest) obj;
  192.   
  193. >     if (!getIdCase().equals(other.getIdCase())) return false;
  194.       switch (idCase_) {
  195.         case 1:

#43
stream/distributedlog/core/src/main/java/org/apache/bookkeeper/client/LedgerReader.java:200: error: Null Dereference
  object returned by `future(op)` could be null and is dereferenced at line 200.
  198.               long entryId = recoveryData.getLastAddConfirmed();
  199.               PendingReadOp op = new PendingReadOp(lh, clientCtx, entryId, entryId, false);
  200. >             op.future().whenComplete(readListener);
  201.               op.submit();
  202.           };

#44
stream/server/src/main/java/org/apache/bookkeeper/stream/server/StorageServer.java:290: error: Resource Leak
  resource of type `org.apache.bookkeeper.stream.server.service.CuratorProviderService` acquired by call to `CuratorProviderService(...)` at line 290 is not released after line 290.
**Note**: potential exception at line 290
  288.           // Create the curator provider service
  289.           CuratorProviderService curatorProviderService = new CuratorProviderService(
  290. >             bkServerConf, dlConf, rootStatsLogger.scope("curator"));
  291.   
  292.           // Create the distributedlog namespace service

#45
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java:210: error: Null Dereference
  object `bk` last assigned on line 204 could be null and is dereferenced at line 210.
  208.           OpenReaderRequest request = new OpenReaderRequest(segment, startEntryId);
  209.           if (segment.isInProgress()) {
  210. >             bk.asyncOpenLedgerNoRecovery(
  211.                       segment.getLogSegmentId(),
  212.                       BookKeeper.DigestType.CRC32,

#46
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java:217: error: Null Dereference
  object `bk` last assigned on line 204 could be null and is dereferenced at line 217.
  215.                       request);
  216.           } else {
  217. >             bk.asyncOpenLedger(
  218.                       segment.getLogSegmentId(),
  219.                       BookKeeper.DigestType.CRC32,

#47
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/SplitPolicy.java:229: error: Null Dereference
  object returned by `getPolicyCase()` could be null and is dereferenced at line 229.
  227.   
  228.       if (type_ != other.type_) return false;
  229. >     if (!getPolicyCase().equals(other.getPolicyCase())) return false;
  230.       switch (policyCase_) {
  231.         case 2:

#48
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BookKeeperClient.java:239: error: Null Dereference
  object `bk` last assigned on line 234 could be null and is dereferenced at line 239.
  237.           }
  238.           final CompletableFuture<Void> promise = new CompletableFuture<Void>();
  239. >         bk.asyncDeleteLedger(lid, new AsyncCallback.DeleteCallback() {
  240.               @Override
  241.               public void deleteComplete(int rc, Object ctx) {

#49
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java:251: error: Resource Leak
  resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 239 is not released after line 251.
**Note**: potential exception at line 240
  249.                           curMark.setLogMark(mark.getLogFileId(), mark.getLogFileOffset());
  250.                       }
  251. >                 } catch (IOException e) {
  252.                       LOG.error("Problems reading from " + file + " (this is okay if it is the first time starting this "
  253.                               + "bookie");

#50
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/RequestOp.java:241: error: Null Dereference
  object returned by `getRequestCase()` could be null and is dereferenced at line 241.
  239.       org.apache.bookkeeper.stream.proto.kv.rpc.RequestOp other = (org.apache.bookkeeper.stream.proto.kv.rpc.RequestOp) obj;
  240.   
  241. >     if (!getRequestCase().equals(other.getRequestCase())) return false;
  242.       switch (requestCase_) {
  243.         case 1:

#51
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/ResponseOp.java:241: error: Null Dereference
  object returned by `getResponseCase()` could be null and is dereferenced at line 241.
  239.       org.apache.bookkeeper.stream.proto.kv.rpc.ResponseOp other = (org.apache.bookkeeper.stream.proto.kv.rpc.ResponseOp) obj;
  240.   
  241. >     if (!getResponseCase().equals(other.getResponseCase())) return false;
  242.       switch (responseCase_) {
  243.         case 1:

#52
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MetadataDrivers.java:257: error: Null Dereference
  object `schemeParts` last assigned on line 256 could be null and is dereferenced at line 257.
  255.           scheme = scheme.toLowerCase();
  256.           String[] schemeParts = StringUtils.split(scheme, '+');
  257. >         checkArgument(schemeParts.length > 0,
  258.                   "Invalid metadata service scheme found : " + uri);
  259.           return getClientDriver(schemeParts[0]);

#53
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java:282: error: Null Dereference
  object `bk` last assigned on line 259 could be null and is dereferenced at line 282.
  280.           };
  281.           if (segment.isInProgress() && !fence) {
  282. >             bk.asyncOpenLedgerNoRecovery(
  283.                       segment.getLogSegmentId(),
  284.                       BookKeeper.DigestType.CRC32,

#54
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java:289: error: Null Dereference
  object `bk` last assigned on line 259 could be null and is dereferenced at line 289.
  287.                       null);
  288.           } else {
  289. >             bk.asyncOpenLedger(
  290.                       segment.getLogSegmentId(),
  291.                       BookKeeper.DigestType.CRC32,

#55
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:277: error: Null Dereference
  object `parts` last assigned on line 276 could be null and is dereferenced at line 277.
  275.   
  276.           String[] parts = StringUtils.split(NodeBase.normalize(defaultFaultDomain), NodeBase.PATH_SEPARATOR);
  277. >         if (parts.length != 2) {
  278.               LOG.error("provided defaultFaultDomain: {} is not valid", defaultFaultDomain);
  279.               throw new IllegalArgumentException("invalid defaultFaultDomain");

#56
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/KvUtils.java:282: error: Null Dereference
  object returned by `op.getResponseCase()` could be null and is dereferenced at line 282.
  280.           result.isSuccess(txnResponse.getSucceeded());
  281.           result.results(Lists.transform(txnResponse.getResponsesList(), op -> {
  282. >             switch (op.getResponseCase()) {
  283.                   case RESPONSE_PUT:
  284.                       return newPutResult(

#57
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/Main.java:333: error: Resource Leak
  resource of type `org.apache.bookkeeper.client.BookKeeperAdmin` acquired by call to `build()` at line 332 is not released after line 333.
  331.                   .setStatsProvider(statsProviderService.getStatsProvider())
  332.                   .build();
  333. >             HttpService httpService =
  334.                   new HttpService(provider, conf, rootStatsLogger);
  335.               serverBuilder.addComponent(httpService);

#58
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/Main.java:333: error: Resource Leak
  resource of type `org.apache.bookkeeper.client.BookKeeper` acquired by call to `build()` at line 332 is not released after line 333.
  331.                   .setStatsProvider(statsProviderService.getStatsProvider())
  332.                   .build();
  333. >             HttpService httpService =
  334.                   new HttpService(provider, conf, rootStatsLogger);
  335.               serverBuilder.addComponent(httpService);

#59
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/Main.java:329: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.BookieService` acquired by call to `BookieService(...)` at line 304 is not released after line 329.
  327.           if (conf.getServerConf().isHttpServerEnabled()) {
  328.               BKHttpServiceProvider provider = new BKHttpServiceProvider.Builder()
  329. >                 .setBookieServer(bookieService.getServer())
  330.                   .setServerConfiguration(conf.getServerConf())
  331.                   .setStatsProvider(statsProviderService.getStatsProvider())

#60
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/Main.java:327: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.BookieService` acquired to `bookieService` by call to `BookieService(...)` at line 304 is not released after line 327.
  325.   
  326.           // 4. build http service
  327. >         if (conf.getServerConf().isHttpServerEnabled()) {
  328.               BKHttpServiceProvider provider = new BKHttpServiceProvider.Builder()
  329.                   .setBookieServer(bookieService.getServer())

#61
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/Main.java:335: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.HttpService` acquired by call to `HttpService(...)` at line 333 is not released after line 335.
  333.               HttpService httpService =
  334.                   new HttpService(provider, conf, rootStatsLogger);
  335. >             serverBuilder.addComponent(httpService);
  336.               log.info("Load lifecycle component : {}", HttpService.class.getName());
  337.           }

#62
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/Main.java:297: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.StatsProviderService` acquired by call to `StatsProviderService(...)` at line 297 is not released after line 297.
**Note**: potential exception at line 297
  295.   
  296.           // 1. build stats provider
  297. >         StatsProviderService statsProviderService =
  298.               new StatsProviderService(conf);
  299.           StatsLogger rootStatsLogger = statsProviderService.getStatsProvider().getStatsLogger("");

#63
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/Main.java:331: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.StatsProviderService` acquired by call to `StatsProviderService(...)` at line 297 is not released after line 331.
  329.                   .setBookieServer(bookieService.getServer())
  330.                   .setServerConfiguration(conf.getServerConf())
  331. >                 .setStatsProvider(statsProviderService.getStatsProvider())
  332.                   .build();
  333.               HttpService httpService =

#64
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/Main.java:327: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.StatsProviderService` acquired to `statsProviderService` by call to `StatsProviderService(...)` at line 297 is not released after line 327.
  325.   
  326.           // 4. build http service
  327. >         if (conf.getServerConf().isHttpServerEnabled()) {
  328.               BKHttpServiceProvider provider = new BKHttpServiceProvider.Builder()
  329.                   .setBookieServer(bookieService.getServer())

#65
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MetadataDrivers.java:294: error: Null Dereference
  object `schemeParts` last assigned on line 293 could be null and is dereferenced at line 294.
  292.           scheme = scheme.toLowerCase();
  293.           String[] schemeParts = StringUtils.split(scheme, '+');
  294. >         checkArgument(schemeParts.length > 0,
  295.                   "Invalid metadata service scheme found : " + uri);
  296.           return getBookieDriver(schemeParts[0]);

#66
stream/distributedlog/core/src/main/java/org/apache/distributedlog/auditor/DLAuditor.java:300: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `get()` at line 300 is not released after line 300.
  298.               String rootPath = uri.getPath() + "/" + allocationPath;
  299.               try {
  300. >                 List<String> pools = getZooKeeperClient(namespace).get().getChildren(rootPath, false);
  301.                   for (String pool : pools) {
  302.                       poolQueue.add(rootPath + "/" + pool);

#67
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/DbLedgerStorage.java:313: error: Null Dereference
  object `ledgerDirs` last assigned on line 311 could be null and is dereferenced at line 313.
  311.           List<File> ledgerDirs = ledgerDirsManager.getAllLedgerDirs();
  312.   
  313. >         int dirIndex = MathUtils.signSafeMod(ledgerId, ledgerDirs.size());
  314.           String ledgerBasePath = ledgerDirs.get(dirIndex).toString();
  315.   

#68
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java:313: error: Null Dereference
  object returned by `header.getOperation()` could be null and is dereferenced at line 313.
  311.               try {
  312.                   BookkeeperProtocol.BKPacketHeader header = r.getHeader();
  313. >                 switch (header.getOperation()) {
  314.                       case ADD_ENTRY:
  315.                           processAddRequestV3(r, c);

#69
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MSLedgerManagerFactory.java:310: error: Null Dereference
  object returned by `key2LedgerId(e.getKey())` could be null and is dereferenced at line 310.
  308.           @Override
  309.           public void process(MSWatchedEvent e){
  310. >             long ledgerId = key2LedgerId(e.getKey());
  311.               switch(e.getType()) {
  312.               case CHANGED:

#70
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/kv/TableStoreImpl.java:310: error: Null Dereference
  object returned by `reqOp.getRequestCase()` could be null and is dereferenced at line 310.
  308.   
  309.       private Op<byte[], byte[]> buildTxnOp(RoutingHeader header, RequestOp reqOp) {
  310. >         switch (reqOp.getRequestCase()) {
  311.               case REQUEST_PUT:
  312.                   return buildPutOp(header, reqOp.getRequestPut());

#71
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/store/Command.java:321: error: Null Dereference
  object returned by `getReqCase()` could be null and is dereferenced at line 321.
  319.       org.apache.bookkeeper.stream.proto.kv.store.Command other = (org.apache.bookkeeper.stream.proto.kv.store.Command) obj;
  320.   
  321. >     if (!getReqCase().equals(other.getReqCase())) return false;
  322.       switch (reqCase_) {
  323.         case 1:

#72
stream/distributedlog/core/src/main/java/org/apache/distributedlog/auditor/DLAuditor.java:332: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `get()` at line 331 is not released after line 332.
  330.                       throws InterruptedException, ZooKeeperClient.ZooKeeperConnectionException, KeeperException {
  331.                   List<String> allocators = getZooKeeperClient(namespace).get()
  332. >                                         .getChildren(poolPath, false);
  333.                   for (String allocator : allocators) {
  334.                       String allocatorPath = poolPath + "/" + allocator;

#73
stream/distributedlog/core/src/main/java/org/apache/distributedlog/auditor/DLAuditor.java:335: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `get()` at line 335 is not released after line 335.
  333.                   for (String allocator : allocators) {
  334.                       String allocatorPath = poolPath + "/" + allocator;
  335. >                     byte[] data = getZooKeeperClient(namespace).get().getData(allocatorPath, false, new Stat());
  336.                       if (null != data && data.length > 0) {
  337.                           try {

#74
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java:368: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.AutoRecoveryService` acquired by call to `AutoRecoveryService(...)` at line 368 is not released after line 368.
**Note**: potential exception at line 368
  366.   
  367.           // 2. build AutoRecovery server
  368. >         AutoRecoveryService autoRecoveryService = new AutoRecoveryService(conf, rootStatsLogger);
  369.   
  370.           serverBuilder.addComponent(autoRecoveryService);

#75
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java:361: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.StatsProviderService` acquired by call to `StatsProviderService(...)` at line 361 is not released after line 361.
**Note**: potential exception at line 361
  359.   
  360.           // 1. build stats provider
  361. >         StatsProviderService statsProviderService = new StatsProviderService(conf);
  362.           StatsLogger rootStatsLogger = statsProviderService.getStatsProvider().getStatsLogger("");
  363.   

#76
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java:385: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.StatsProviderService` acquired to `statsProviderService` by call to `StatsProviderService(...)` at line 361 is not released after line 385.
**Note**: potential exception at line 368
  383.           }
  384.   
  385. >         return serverBuilder.build();
  386.       }
  387.   }

#77
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java:376: error: Null Dereference
  object `fragments` last assigned on line 369 could be null and is dereferenced at line 376.
  374.   
  375.               boolean foundOpenFragments = false;
  376. >             for (LedgerFragment ledgerFragment : fragments) {
  377.                   if (!ledgerFragment.isClosed()) {
  378.                       foundOpenFragments = true;

#78
stream/server/src/main/java/org/apache/bookkeeper/stream/server/StorageServer.java:386: error: Resource Leak
  resource of type `org.apache.bookkeeper.stream.storage.impl.cluster.ZkClusterMetadataStore` acquired by call to `new()` at line 382 is not released after line 386.
  384.                   regService.get(),
  385.                   new DefaultStorageContainerController(),
  386. >                 new ZkClusterControllerLeaderSelector(curatorProviderService.get(), ZK_METADATA_ROOT_PATH),
  387.                   storageConf),
  388.               rootStatsLogger.scope("cluster_controller"));

#79
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java:411: error: Null Dereference
  object `bookies` last assigned on line 410 could be null and is dereferenced at line 411.
  409.           Collection<BookieId> bookies;
  410.           bookies = bk.bookieWatcher.getBookies();
  411. >         bookies.addAll(bk.bookieWatcher.getReadOnlyBookies());
  412.           if (bookies.isEmpty()) {
  413.               return map;

#80
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:455: error: Null Dereference
  object `candidateNode` last assigned on line 454 could be null and is dereferenced at line 455.
  453.           for (int i = 0; i < ensembleSize; i++) {
  454.               BookieNode candidateNode = selectCandidateNode(bookiesToConsider);
  455. >             newEnsemble.set(i, candidateNode.getAddr());
  456.               bookiesToConsider.remove(candidateNode);
  457.           }

#81
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/storage/GetStreamRequest.java:448: error: Null Dereference
  object returned by `other.getIdCase()` could be null and is dereferenced at line 448.
  446.       public Builder mergeFrom(org.apache.bookkeeper.stream.proto.storage.GetStreamRequest other) {
  447.         if (other == org.apache.bookkeeper.stream.proto.storage.GetStreamRequest.getDefaultInstance()) return this;
  448. >       switch (other.getIdCase()) {
  449.           case STREAM_NAME: {
  450.             mergeStreamName(other.getStreamName());

#82
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:474: error: Null Dereference
  object returned by `selectCandidateNode(bookiesToConsider)` could be null and is dereferenced at line 474.
  472.               throw new BKNotEnoughBookiesException();
  473.           }
  474. >         BookieId candidateAddr = (selectCandidateNode(bookiesToConsider)).getAddr();
  475.           newEnsemble.set(bookieToReplaceIndex, candidateAddr);
  476.           return PlacementResult.of(candidateAddr,

#83
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java:478: error: Null Dereference
  object `available` last assigned on line 476 could be null and is dereferenced at line 478.
  476.           Collection<BookieId> available = admin.getAvailableBookies();
  477.           for (BookieId b : finalEnsemble) {
  478. >             if (!available.contains(b)) {
  479.                   if (LOG.isDebugEnabled()) {
  480.                       LOG.debug("Bookie {} is missing from the list of Available Bookies. ledger {}:ensemble {}.",

#84
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexInMemPageMgr.java:510: error: Resource Leak
  resource of type `org.apache.bookkeeper.bookie.LedgerEntryPage` acquired to `lep` by call to `new()` at line 497 is not released after line 510.
**Note**: potential exception at line 498
  508.                       ledger, entry);
  509.               flushOneOrMoreLedgers(false);
  510. >         }
  511.       }
  512.   

#85
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/SplitPolicy.java:498: error: Null Dereference
  object returned by `other.getPolicyCase()` could be null and is dereferenced at line 498.
  496.           setTypeValue(other.getTypeValue());
  497.         }
  498. >       switch (other.getPolicyCase()) {
  499.           case FIXED_RANGE_POLICY: {
  500.             mergeFixedRangePolicy(other.getFixedRangePolicy());

#86
stream/distributedlog/core/src/main/java/org/apache/distributedlog/auditor/DLAuditor.java:510: error: Null Dereference
  object returned by `bkc.get()` could be null and is dereferenced by call to `getLedgerManager(...)` at line 510.
  508.           final AtomicLong numLedgers = new AtomicLong(0);
  509.   
  510. >         LedgerManager lm = BookKeeperAccessor.getLedgerManager(bkc.get());
  511.   
  512.           final CompletableFuture<Void> doneFuture = FutureUtils.createFuture();

#87
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java:536: error: Resource Leak
  resource of type `java.io.RandomAccessFile` acquired by call to `RandomAccessFile(...)` at line 521 is not released after line 536.
  534.           } finally {
  535.               newFc.force(true);
  536. >             newFc.close();
  537.           }
  538.           // delete old.idx

#88
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java:529: error: Null Dereference
  object `fragments` last assigned on line 528 could be null and is dereferenced at line 529.
  527.                           Set<LedgerFragment> fragments =
  528.                               getUnderreplicatedFragments(lh, conf.getAuditorLedgerVerificationPercentage());
  529. >                         for (LedgerFragment fragment : fragments) {
  530.                               if (!fragment.isClosed()) {
  531.                                   // Need recovery open, close the old ledger handle.

#89
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/RequestOp.java:520: error: Null Dereference
  object returned by `other.getRequestCase()` could be null and is dereferenced at line 520.
  518.       public Builder mergeFrom(org.apache.bookkeeper.stream.proto.kv.rpc.RequestOp other) {
  519.         if (other == org.apache.bookkeeper.stream.proto.kv.rpc.RequestOp.getDefaultInstance()) return this;
  520. >       switch (other.getRequestCase()) {
  521.           case REQUEST_RANGE: {
  522.             mergeRequestRange(other.getRequestRange());

#90
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/ResponseOp.java:520: error: Null Dereference
  object returned by `other.getResponseCase()` could be null and is dereferenced at line 520.
  518.       public Builder mergeFrom(org.apache.bookkeeper.stream.proto.kv.rpc.ResponseOp other) {
  519.         if (other == org.apache.bookkeeper.stream.proto.kv.rpc.ResponseOp.getDefaultInstance()) return this;
  520. >       switch (other.getResponseCase()) {
  521.           case RESPONSE_RANGE: {
  522.             mergeResponseRange(other.getResponseRange());

#91
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:559: error: Null Dereference
  object `bookiesToConsiderAfterExcludingZonesAndUDs` last assigned on line 548 could be null and is dereferenced at line 559.
  557.               }
  558.           }
  559. >         if (bookiesToConsiderAfterExcludingZonesAndUDs.isEmpty()) {
  560.               zonesToExclude = getZonesToExcludeToMaintainMinZones(currentEnsemble, bookieToReplaceIndex,
  561.                       writeQuorumSize);

#92
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:571: error: Null Dereference
  object returned by `selectCandidateNode(bookiesToConsiderAfterExcludingZonesAndUDs)` could be null and is dereferenced at line 571.
  569.           }
  570.   
  571. >         BookieId candidateAddr = selectCandidateNode(bookiesToConsiderAfterExcludingZonesAndUDs).getAddr();
  572.           newEnsemble.set(bookieToReplaceIndex, candidateAddr);
  573.           return candidateAddr;

#93
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/Compare.java:630: error: Null Dereference
  object returned by `getTargetUnionCase()` could be null and is dereferenced at line 630.
  628.       if (!getKey()
  629.           .equals(other.getKey())) return false;
  630. >     if (!getTargetUnionCase().equals(other.getTargetUnionCase())) return false;
  631.       switch (targetUnionCase_) {
  632.         case 4:

#94
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/store/Command.java:636: error: Null Dereference
  object returned by `other.getReqCase()` could be null and is dereferenced at line 636.
  634.       public Builder mergeFrom(org.apache.bookkeeper.stream.proto.kv.store.Command other) {
  635.         if (other == org.apache.bookkeeper.stream.proto.kv.store.Command.getDefaultInstance()) return this;
  636. >       switch (other.getReqCase()) {
  637.           case NOP_REQ: {
  638.             mergeNopReq(other.getNopReq());

#95
stream/statelib/target/generated-sources/protobuf/java/org/apache/bookkeeper/proto/statestore/kv/Command.java:636: error: Null Dereference
  object returned by `other.getReqCase()` could be null and is dereferenced at line 636.
  634.       public Builder mergeFrom(org.apache.bookkeeper.proto.statestore.kv.Command other) {
  635.         if (other == org.apache.bookkeeper.proto.statestore.kv.Command.getDefaultInstance()) return this;
  636. >       switch (other.getReqCase()) {
  637.           case NOP_REQ: {
  638.             mergeNopReq(other.getNopReq());

#96
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:651: error: Null Dereference
  object `realRange` last assigned on line 650 could be null and is dereferenced at line 651.
  649.               } else {
  650.                   Pair<byte[], byte[]> realRange = getRealRange(key, endKey);
  651. >                 endKey = realRange.getRight();
  652.                   ++endKey[endKey.length - 1];
  653.                   batch.deleteRange(realRange.getLeft(), endKey);

#97
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/HardLink.java:653: error: Null Dereference
  object returned by `getProperty("os.name")` could be null and is dereferenced at line 653.
  651.     public static String makeShellPath(File file) throws IOException {
  652.       String filename = file.getCanonicalPath();
  653. >     if (System.getProperty("os.name").startsWith("Windows")) {
  654.         BufferedReader r = null;
  655.         try {

#98
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:686: error: Null Dereference
  object `realRange` last assigned on line 685 could be null and is dereferenced at line 686.
  684.           } else {
  685.               Pair<byte[], byte[]> realRange = getRealRange(rawKey, rawEndKey);
  686. >             rawKey = realRange.getLeft();
  687.               rawEndKey = realRange.getRight();
  688.   

#99
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:708: error: Null Dereference
  object returned by `excludingUDsOfZonesToConsider.get(nodeLocation.getZone())` could be null and is dereferenced at line 708.
  706.           for (BookieNode bookieToConsider : bookiesToConsider) {
  707.               ZoneAwareNodeLocation nodeLocation = getZoneAwareNodeLocation(bookieToConsider);
  708. >             if (excludingUDsOfZonesToConsider.get(nodeLocation.getZone()).contains(nodeLocation.getUpgradeDomain())) {
  709.                   continue;
  710.               }

#100
stream/distributedlog/core/src/main/java/org/apache/distributedlog/admin/DistributedLogAdmin.java:787: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `delete(...)` at line 787 is not released after line 787.
  785.               }
  786.               String zkPath = getUri() + "/" + bkdlConfig.getACLRootPath() + "/" + stream;
  787. >             ZKAccessControl.delete(getZooKeeperClient(), zkPath);
  788.               return 0;
  789.           }

#101
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:789: error: Null Dereference
  object `record` could be null and is dereferenced at line 789.
  787.           switch (op.target()) {
  788.               case MOD:
  789. >                 cmp = record.compareModRev(op.revision());
  790.                   break;
  791.               case CREATE:

#102
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:792: error: Null Dereference
  object `record` could be null and is dereferenced at line 792.
  790.                   break;
  791.               case CREATE:
  792. >                 cmp = record.compareCreateRev(op.revision());
  793.                   break;
  794.               case VERSION:

#103
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:795: error: Null Dereference
  object `record` could be null and is dereferenced at line 795.
  793.                   break;
  794.               case VERSION:
  795. >                 cmp = record.compareVersion(op.revision());
  796.                   break;
  797.               case VALUE:

#104
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:806: error: Null Dereference
  object returned by `readEntriesInternalAsync(firstEntry,lastEntry,isRecoveryRead)` could be null and is dereferenced at line 806.
  804.           if (!clientCtx.isClientClosed()) {
  805.               readEntriesInternalAsync(firstEntry, lastEntry, isRecoveryRead)
  806. >                 .whenCompleteAsync(new FutureEventListener<LedgerEntries>() {
  807.                       @Override
  808.                       public void onSuccess(LedgerEntries entries) {

#105
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:918: error: Null Dereference
  object `numOfNodesInAZone` last assigned on line 917 could be null and is dereferenced at line 918.
  916.                           udsOfThisZoneInThisWriteSet.add(upgradeDomain);
  917.                           Integer numOfNodesInAZone = numOfBookiesInZones.get(zone);
  918. >                         numOfBookiesInZones.put(zone, (numOfNodesInAZone + 1));
  919.                       }
  920.                   }

#106
stream/distributedlog/core/src/main/java/org/apache/distributedlog/admin/DistributedLogAdmin.java:900: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `getZKAccessControl(...)` at line 900 is not released after line 900.
  898.               }
  899.               String zkPath = getZKPath(getUri().getPath() + "/" + bkdlConfig.getACLRootPath());
  900. >             ZKAccessControl accessControl = getZKAccessControl(getZooKeeperClient(), zkPath);
  901.               AccessControlEntry acl = accessControl.getAccessControlEntry();
  902.               acl.setDenyWrite(denyWrite);

#107
stream/distributedlog/core/src/main/java/org/apache/distributedlog/admin/DistributedLogAdmin.java:907: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `setZKAccessControl(...)` at line 907 is not released after line 907.
  905.               acl.setDenyAcquire(denyAcquire);
  906.               acl.setDenyRelease(denyRelease);
  907. >             setZKAccessControl(getZooKeeperClient(), accessControl);
  908.               return 0;
  909.           }

#108
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/Compare.java:926: error: Null Dereference
  object returned by `other.getTargetUnionCase()` could be null and is dereferenced at line 926.
  924.           setKey(other.getKey());
  925.         }
  926. >       switch (other.getTargetUnionCase()) {
  927.           case VERSION: {
  928.             setVersion(other.getVersion());

#109
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:964: error: Null Dereference
  object `udsOfThisZone` last assigned on line 963 could be null and is dereferenced at line 964.
  962.               if (numOfNodesInThisZone > 1) {
  963.                   Set<String> udsOfThisZone = nodesLocationInWriteSet.get(zone);
  964. >                 if (udsOfThisZone.size() < 2) {
  965.                       return false;
  966.                   }

#110
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:996: error: Null Dereference
  object `realRange` last assigned on line 995 could be null and is dereferenced at line 996.
  994.           }
  995.           Pair<byte[], byte[]> realRange = getRealRange(rawKey, rawEndKey);
  996. >         rawKey = realRange.getLeft();
  997.           rawEndKey = realRange.getRight();
  998.   

#111
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java:1076: error: Null Dereference
  object `availableBkAddresses` last assigned on line 1074 could be null and is dereferenced at line 1076.
  1074.           Collection<BookieId> availableBkAddresses = admin.getAvailableBookies();
  1075.           Collection<BookieId> readOnlyBkAddresses = admin.getReadOnlyBookies();
  1076. >         availableBkAddresses.addAll(readOnlyBkAddresses);
  1077.   
  1078.           List<String> availableBookies = new ArrayList<String>();

#112
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BKLogWriteHandler.java:1119: error: Null Dereference
  object `partialTruncate` last assigned on line 1093 could be null and is dereferenced by call to `setLogSegmentTruncationStatus(...)` at line 1119.
  1117.               }
  1118.           }
  1119. >         return setLogSegmentTruncationStatus(truncateList, partialTruncate, dlsn);
  1120.       }
  1121.   

#113
stream/distributedlog/core/src/main/java/org/apache/distributedlog/tools/DistributedLogTool.java:1276: error: Null Dereference
  object returned by `DistributedLogTool$DeleteLedgersCommand$1.this$0.getBookKeeperClient().get()` could be null and is dereferenced at line 1276.
  1274.                                   }
  1275.                                   try {
  1276. >                                     getBookKeeperClient().get().deleteLedger(ledger);
  1277.                                       int numLedgersDeleted = numLedgers.incrementAndGet();
  1278.                                       if (numLedgersDeleted % 1000 == 0) {

#114
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java:1465: error: Null Dereference
  object `cmd.bka` last assigned on line 1464 could be null and is dereferenced by call to `apply(...)` at line 1465.
  1463.               CliFlags flags = new CliFlags();
  1464.               WhoIsAuditorCommand cmd = new WhoIsAuditorCommand();
  1465. >             boolean result = cmd.apply(bkConf, flags);
  1466.               return result ? 0 : -1;
  1467.           }

#115
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1595: error: Resource Leak
  resource of type `org.apache.bookkeeper.client.ReadLastConfirmedAndEntryOp$ParallelReadRequest` acquired by call to `initiate()` at line 1595 is not released after line 1595.
  1593.           new ReadLastConfirmedAndEntryOp(this, clientCtx, getCurrentEnsemble(), innercb, entryId - 1, timeOutInMillis)
  1594.               .parallelRead(parallel)
  1595. >             .initiate();
  1596.       }
  1597.   

#116
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1595: error: Resource Leak
  resource of type `org.apache.bookkeeper.client.ReadLastConfirmedAndEntryOp$SequenceReadRequest` acquired by call to `initiate()` at line 1595 is not released after line 1595.
  1593.           new ReadLastConfirmedAndEntryOp(this, clientCtx, getCurrentEnsemble(), innercb, entryId - 1, timeOutInMillis)
  1594.               .parallelRead(parallel)
  1595. >             .initiate();
  1596.       }
  1597.   

#117
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java:1568: error: Null Dereference
  object returned by `getAvailableBookies()` could be null and is dereferenced at line 1568.
  1566.               throws CompatibilityException, UnavailableException, KeeperException, InterruptedException, IOException,
  1567.               BKAuditException, TimeoutException, BKException {
  1568. >         if (getAvailableBookies().contains(bookieAddress) || getReadOnlyBookies().contains(bookieAddress)) {
  1569.               LOG.error("Bookie: {} is not shutdown yet", bookieAddress);
  1570.               throw BKException.create(BKException.Code.IllegalOpException);

#118
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java:1568: error: Null Dereference
  object returned by `getReadOnlyBookies()` could be null and is dereferenced at line 1568.
  1566.               throws CompatibilityException, UnavailableException, KeeperException, InterruptedException, IOException,
  1567.               BKAuditException, TimeoutException, BKException {
  1568. >         if (getAvailableBookies().contains(bookieAddress) || getReadOnlyBookies().contains(bookieAddress)) {
  1569.               LOG.error("Bookie: {} is not shutdown yet", bookieAddress);
  1570.               throw BKException.create(BKException.Code.IllegalOpException);

#119
stream/distributedlog/core/src/main/java/org/apache/distributedlog/tools/DistributedLogTool.java:1691: error: Null Dereference
  object returned by `bkc.get()` could be null and is dereferenced by call to `BookKeeperAdmin(...)` at line 1691.
  1689.                                            BookKeeperClient bkc,
  1690.                                            List<LogSegmentMetadata> segments) throws Exception {
  1691. >             BookKeeperAdmin bkAdmin = new BookKeeperAdmin(bkc.get());
  1692.               try {
  1693.                   MetadataUpdater metadataUpdater = LogSegmentMetadataStoreUpdater.createMetadataUpdater(

#120
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClientImpl.java:122: warning: Thread Safety Violation
  Unprotected write. Non-private method `BookieClientImpl(...)` indirectly mutates container `util.ReflectionUtils.constructorCache` via call to `Map.put(...)` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  120.           this.bookieAddressResolver = bookieAddressResolver;
  121.           this.registry = ExtensionRegistry.newInstance();
  122. >         this.authProviderFactory = AuthProviderFactoryFactory.newClientAuthProviderFactory(conf);
  123.   
  124.           this.statsLogger = statsLogger;

#121
bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopologyImpl.java:407: warning: Thread Safety Violation
  Read/Write race. Non-private method `NetworkTopologyImpl.add(...)` indirectly reads without synchronization from `this.numOfRacks`. Potentially races with write in method `NetworkTopologyImpl.remove(...)`.
 Reporting because this access may occur on a background thread.
  405.               return;
  406.           }
  407. >         String oldTopoStr = this.toString();
  408.           if (node instanceof InnerNode) {
  409.               throw new IllegalArgumentException("Not allow to add an inner node: " + NodeBase.getPath(node));

#122
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BKLogSegmentWriter.java:1189: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKLogSegmentWriter.addComplete(...)` reads without synchronization from `this.lastEntryId`. Potentially races with write in method `BKLogSegmentWriter.addComplete(...)`.
 Reporting because this access may occur on a background thread.
  1187.   
  1188.           // Sanity check to make sure we're receiving these callbacks in order.
  1189. >         if (entryId > -1 && lastEntryId >= entryId) {
  1190.               LOG.error("Log segment {} saw out of order entry {} lastEntryId {}",
  1191.                   fullyQualifiedLogSegment, entryId, lastEntryId);

#123
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BKLogSegmentWriter.java:1193: warning: Thread Safety Violation
  Unprotected write. Non-private method `BKLogSegmentWriter.addComplete(...)` writes to field `this.lastEntryId` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1191.                   fullyQualifiedLogSegment, entryId, lastEntryId);
  1192.           }
  1193. >         lastEntryId = entryId;
  1194.   
  1195.           assert (ctx instanceof BKTransmitPacket);

#124
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:920: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.addEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  918.        */
  919.       public long addEntry(byte[] data) throws InterruptedException, BKException {
  920. >         return addEntry(data, 0, data.length);
  921.       }
  922.   

#125
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:970: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.addEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  968.   
  969.           SyncAddCallback callback = new SyncAddCallback();
  970. >         asyncAddEntry(data, offset, length, callback, null);
  971.   
  972.           return SyncCallbackUtils.waitForResult(callback);

#126
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:929: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.appendAsync(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  927.       public CompletableFuture<Long> appendAsync(ByteBuf data) {
  928.           SyncAddCallback callback = new SyncAddCallback();
  929. >         asyncAddEntry(data, callback, null);
  930.           return callback;
  931.       }

#127
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicyImpl.java:1053: warning: Thread Safety Violation
  Read/Write race. Non-private method `RackawareEnsemblePlacementPolicyImpl.areAckedBookiesAdheringToPlacementPolicy(...)` reads without synchronization from `this.minNumRacksPerWriteQuorum`. Potentially races with write in method `RackawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  1051.                                                               int ackQuorumSize) {
  1052.           HashSet<String> rackCounter = new HashSet<>();
  1053. >         int minWriteQuorumNumRacksPerWriteQuorum = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);
  1054.   
  1055.           ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();

#128
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:976: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZoneawareEnsemblePlacementPolicyImpl.areAckedBookiesAdheringToPlacementPolicy(...)` reads without synchronization from `this.minNumZonesPerWriteQuorum`. Potentially races with write in method `ZoneawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  974.               int ackQuorumSize) {
  975.           HashSet<String> zonesOfAckedBookies = new HashSet<>();
  976. >         int minNumZonesPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumZonesPerWriteQuorum);
  977.           boolean areAckedBookiesAdheringToPlacementPolicy = false;
  978.           ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();

#129
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1062: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncAddEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1060.   
  1061.       public void asyncAddEntry(ByteBuf data, final AddCallback cb, final Object ctx) {
  1062. >         PendingAddOp op = PendingAddOp.create(this, clientCtx, getCurrentEnsemble(), data, writeFlags, cb, ctx);
  1063.           doAsyncAddEntry(op);
  1064.       }

#130
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1058: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncAddEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1056.           }
  1057.   
  1058. >         asyncAddEntry(Unpooled.wrappedBuffer(data, offset, length), cb, ctx);
  1059.       }
  1060.   

#131
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1010: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncAddEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1008.       public void asyncAddEntry(final byte[] data, final AddCallback cb,
  1009.                                 final Object ctx) {
  1010. >         asyncAddEntry(data, 0, data.length, cb, ctx);
  1011.       }
  1012.   

#132
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:699: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadEntries(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  697.           }
  698.   
  699. >         asyncReadEntriesInternal(firstEntry, lastEntry, cb, ctx, false);
  700.       }
  701.   

#133
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:805: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadEntriesInternal(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  803.                                     Object ctx, boolean isRecoveryRead) {
  804.           if (!clientCtx.isClientClosed()) {
  805. >             readEntriesInternalAsync(firstEntry, lastEntry, isRecoveryRead)
  806.                   .whenCompleteAsync(new FutureEventListener<LedgerEntries>() {
  807.                       @Override

#134
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1736: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadExplicitLastConfirmed(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1734.               }
  1735.           };
  1736. >         new PendingReadLacOp(this, clientCtx.getBookieClient(), getCurrentEnsemble(), innercb).initiate();
  1737.       }
  1738.   

#135
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1400: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadLastConfirmed(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1398.           if (clientCtx.getConf().useV2WireProtocol) {
  1399.               // in v2 protocol we don't support readLAC RPC
  1400. >             asyncReadPiggybackLastConfirmed(cb, ctx);
  1401.           } else {
  1402.               asyncReadExplicitLastConfirmed(cb, ctx);

#136
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1560: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadLastConfirmedAndEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1558.           }
  1559.           if (entryId <= lac) {
  1560. >             asyncReadEntries(entryId, entryId, new ReadCallback() {
  1561.                   @Override
  1562.                   public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {

#137
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:850: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadLastEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  848.               cb.readComplete(BKException.Code.NoSuchEntryException, this, null, ctx);
  849.           } else {
  850. >             asyncReadEntriesInternal(lastEntryId, lastEntryId, cb, ctx, false);
  851.           }
  852.       }

#138
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:738: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadUnconfirmedEntries(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  736.           }
  737.   
  738. >         asyncReadEntriesInternal(firstEntry, lastEntry, cb, ctx, false);
  739.       }
  740.   

#139
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1215: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncRecoveryAddEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1213.       void asyncRecoveryAddEntry(final byte[] data, final int offset, final int length,
  1214.                                  final AddCallback cb, final Object ctx) {
  1215. >         PendingAddOp op = PendingAddOp.create(this, clientCtx, getCurrentEnsemble(),
  1216.                                                 Unpooled.wrappedBuffer(data, offset, length),
  1217.                                                 writeFlags, cb, ctx)

#140
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1483: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncTryReadLastConfirmed(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1481.               }
  1482.           };
  1483. >         new TryReadLastConfirmedOp(this, clientCtx.getBookieClient(), getCurrentEnsemble(),
  1484.                                      innercb, getLastAddConfirmed()).initiate();
  1485.       }

#141
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:142: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.checkStoreOpen()` reads without synchronization from `this.name`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  140.       protected void checkStoreOpen() {
  141.           if (closed) {
  142. >             throw new InvalidStateStoreException("State store " + name + " is already closed");
  143.           }
  144.           if (!isInitialized) {

#142
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/SingleDirectoryDbLedgerStorage.java:601: warning: Thread Safety Violation
  Read/Write race. Non-private method `SingleDirectoryDbLedgerStorage.checkpoint(...)` reads without synchronization from `this.lastCheckpoint`. Potentially races with write in method `SingleDirectoryDbLedgerStorage.checkpoint(...)`.
 Reporting because this access may occur on a background thread.
  599.       public void checkpoint(Checkpoint checkpoint) throws IOException {
  600.           Checkpoint thisCheckpoint = checkpointSource.newCheckpoint();
  601. >         if (lastCheckpoint.compareTo(checkpoint) > 0) {
  602.               return;
  603.           }

#143
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:385: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.close()` indirectly reads without synchronization from `this.allocator`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  383.               return;
  384.           }
  385. >         doClose();
  386.       }
  387.   

#144
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/store/MVCCStoreFactoryImpl.java:281: warning: Thread Safety Violation
  Unprotected write. Non-private method `MVCCStoreFactoryImpl.close()` writes to field `this.checkpointStore` outside of synchronization.
 Reporting because this access may occur on a background thread.
  279.           if (null != checkpointStore) {
  280.               checkpointStore.close();
  281. >             checkpointStore = null;
  282.           }
  283.   

#145
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/store/MVCCStoreFactoryImpl.java:279: warning: Thread Safety Violation
  Read/Write race. Non-private method `MVCCStoreFactoryImpl.close()` reads without synchronization from `this.checkpointStore`. Potentially races with write in method `MVCCStoreFactoryImpl.openStore(...)`.
 Reporting because this access may occur on a background thread.
  277.               log.info("Encountered issue on closing all the range stores opened by this range factory");
  278.           }
  279. >         if (null != checkpointStore) {
  280.               checkpointStore.close();
  281.               checkpointStore = null;

#146
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataBookieDriver.java:99: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKMetadataBookieDriver.close()` indirectly writes to field `this.lmFactory` outside of synchronization.
 Reporting because this access may occur on a background thread.
   97.               rmToClose.close();
   98.           }
   99. >         super.close();
  100.       }
  101.   }

#147
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataDriverBase.java:265: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKMetadataDriverBase.close()` reads without synchronization from `this.lmFactory`. Potentially races with write in method `ZKMetadataDriverBase.getLedgerManagerFactory()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  263.       @Override
  264.       public void close() {
  265. >         if (null != lmFactory) {
  266.               try {
  267.                   lmFactory.close();

#148
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataDriverBase.java:271: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKMetadataDriverBase.close()` writes to field `this.lmFactory` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  269.                   log.warn("Failed to close zookeeper based ledger manager", e);
  270.               }
  271. >             lmFactory = null;
  272.           }
  273.           if (ownZKHandle && null != zk) {

#149
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/journal/AbstractStateStoreWithJournal.java:462: warning: Thread Safety Violation
  Read/Write race. Non-private method `AbstractStateStoreWithJournal.closeAsync()` indirectly reads without synchronization from `this.name`. Potentially races with write in method `AbstractStateStoreWithJournal.init(...)`.
 Reporting because this access may occur on a background thread.
  460.           if (null != checkpointTask) {
  461.               if (!checkpointTask.cancel(true)) {
  462. >                 log.warn("Fail to cancel checkpoint task of state store {}", name());
  463.               }
  464.           }

#150
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/journal/AbstractStateStoreWithJournal.java:466: warning: Thread Safety Violation
  Read/Write race. Non-private method `AbstractStateStoreWithJournal.closeAsync()` reads without synchronization from `this.writeIOScheduler`. Potentially races with write in method `AbstractStateStoreWithJournal.init(...)`.
 Reporting because this access may occur on a background thread.
  464.           }
  465.           // wait until last checkpoint task completed
  466. >         writeIOScheduler.submit(() -> {
  467.               log.info("closing async state store {}", name);
  468.               FutureUtils.ensure(

#151
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:423: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.closeLocalDB()` reads without synchronization from `this.dataCfHandle`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  421.   
  422.           RocksUtils.close(metaCfHandle);
  423. >         RocksUtils.close(dataCfHandle);
  424.           RocksUtils.close(db);
  425.       }

#152
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:422: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.closeLocalDB()` reads without synchronization from `this.metaCfHandle`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  420.           }
  421.   
  422. >         RocksUtils.close(metaCfHandle);
  423.           RocksUtils.close(dataCfHandle);
  424.           RocksUtils.close(db);

#153
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:424: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.closeLocalDB()` reads without synchronization from `this.db`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  422.           RocksUtils.close(metaCfHandle);
  423.           RocksUtils.close(dataCfHandle);
  424. >         RocksUtils.close(db);
  425.       }
  426.   

#154
bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java:69: warning: Thread Safety Violation
  Read/Write race. Non-private method `InMemoryMetastoreTable$MetadataVersion.compare(...)` reads without synchronization from `this.version`. Potentially races with write in method `InMemoryMetastoreTable$MetadataVersion.incrementVersion()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  67.               }
  68.               MetadataVersion mv = (MetadataVersion) v;
  69. >             int res = version - mv.version;
  70.               if (res == 0) {
  71.                   return Occurred.CONCURRENTLY;

#155
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java:446: warning: Thread Safety Violation
  Unprotected write. Non-private method `PendingReadOp$SequenceReadRequest.complete(...)` indirectly writes to field `this.rc` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  444.           @Override
  445.           boolean complete(int bookieIndex, BookieId host, ByteBuf buffer) {
  446. >             boolean completed = super.complete(bookieIndex, host, buffer);
  447.               if (completed) {
  448.                   int numReplicasTried = getNextReplicaIndexToReadFrom();

#156
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedAndEntryOp.java:416: warning: Thread Safety Violation
  Unprotected write. Non-private method `ReadLastConfirmedAndEntryOp$SequenceReadRequest.complete(...)` indirectly writes to field `this.rc` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  414.           @Override
  415.           boolean complete(int bookieIndex, BookieId host, ByteBuf buffer, long entryId) {
  416. >             boolean completed = super.complete(bookieIndex, host, buffer, entryId);
  417.               if (completed) {
  418.                   int numReplicasTried = getNextReplicaIndexToReadFrom();

#157
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:820: warning: Thread Safety Violation
  Read/Write race. Non-private method `TopologyAwareEnsemblePlacementPolicy.convertBookiesToNodes(...)` reads without synchronization from container `this.knownBookies` via call to `Map.get(...)`. Potentially races with write in method `TopologyAwareEnsemblePlacementPolicy.onClusterChanged(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  818.           Set<Node> nodes = new HashSet<Node>();
  819.           for (BookieId addr : excludeBookies) {
  820. >             BookieNode bn = knownBookies.get(addr);
  821.               if (null == bn) {
  822.                   bn = createBookieNode(addr);

#158
stream/distributedlog/protocol/src/main/java/org/apache/distributedlog/EnvelopedRecordSetWriter.java:149: warning: Thread Safety Violation
  Read/Write race. Non-private method `EnvelopedRecordSetWriter.createBuffer()` reads without synchronization from `this.count`. Potentially races with write in method `EnvelopedRecordSetWriter.writeRecord(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  147.           compressedBuf.setInt(METADATA_OFFSET, metadata);
  148.           // update count
  149. >         compressedBuf.setInt(COUNT_OFFSET, count);
  150.           // update data len
  151.           compressedBuf.setInt(DECOMPRESSED_SIZE_OFFSET, dataLen);

#159
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:190: warning: Interface Not Thread Safe
  Unprotected call to method `DeleteOption.endKey()` of un-annotated interface `org.apache.bookkeeper.api.kv.options.DeleteOption`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  188.           pKey.retain();
  189.           lKey.retain();
  190. >         if (null != option.endKey()) {
  191.               option.endKey().retain();
  192.           }

#160
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:75: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  73.    * A {@link PTable} implementation using simple grpc calls.
  74.    */
  75. > @Slf4j
  76.   public class PByteBufSimpleTableImpl
  77.       extends AbstractStub<PByteBufSimpleTableImpl>

#161
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:164: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.minLatency`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  162.               OpStats diff = new OpStats();
  163.               diff.maxLatency = this.maxLatency > base.maxLatency ? this.maxLatency : base.maxLatency;
  164. >             diff.minLatency = this.minLatency > base.minLatency ? base.minLatency : this.minLatency;
  165.               diff.totalLatency = this.totalLatency - base.totalLatency;
  166.               diff.numSuccessOps = this.numSuccessOps - base.numSuccessOps;

#162
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:169: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.latencyBuckets.[_]`. Potentially races with write in method `BKStats$OpStats.updateLatency(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  167.               diff.numFailedOps = this.numFailedOps - base.numFailedOps;
  168.               for (int i = 0; i < NUM_BUCKETS; i++) {
  169. >                 diff.latencyBuckets[i] = this.latencyBuckets[i] - base.latencyBuckets[i];
  170.               }
  171.               return diff;

#163
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:163: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.maxLatency`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  161.           public OpStats diff(OpStats base) {
  162.               OpStats diff = new OpStats();
  163. >             diff.maxLatency = this.maxLatency > base.maxLatency ? this.maxLatency : base.maxLatency;
  164.               diff.minLatency = this.minLatency > base.minLatency ? base.minLatency : this.minLatency;
  165.               diff.totalLatency = this.totalLatency - base.totalLatency;

#164
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:167: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.numFailedOps`. Potentially races with write in method `BKStats$OpStats.incrementFailedOps()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  165.               diff.totalLatency = this.totalLatency - base.totalLatency;
  166.               diff.numSuccessOps = this.numSuccessOps - base.numSuccessOps;
  167. >             diff.numFailedOps = this.numFailedOps - base.numFailedOps;
  168.               for (int i = 0; i < NUM_BUCKETS; i++) {
  169.                   diff.latencyBuckets[i] = this.latencyBuckets[i] - base.latencyBuckets[i];

#165
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:166: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.numSuccessOps`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  164.               diff.minLatency = this.minLatency > base.minLatency ? base.minLatency : this.minLatency;
  165.               diff.totalLatency = this.totalLatency - base.totalLatency;
  166. >             diff.numSuccessOps = this.numSuccessOps - base.numSuccessOps;
  167.               diff.numFailedOps = this.numFailedOps - base.numFailedOps;
  168.               for (int i = 0; i < NUM_BUCKETS; i++) {

#166
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:165: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.totalLatency`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  163.               diff.maxLatency = this.maxLatency > base.maxLatency ? this.maxLatency : base.maxLatency;
  164.               diff.minLatency = this.minLatency > base.minLatency ? base.minLatency : this.minLatency;
  165. >             diff.totalLatency = this.totalLatency - base.totalLatency;
  166.               diff.numSuccessOps = this.numSuccessOps - base.numSuccessOps;
  167.               diff.numFailedOps = this.numFailedOps - base.numFailedOps;

#167
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1355: warning: Thread Safety Violation
  Unprotected write. Non-private method `LedgerHandle.doAsyncAddEntry(...)` indirectly writes to field `op.allowFailFast` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1353.               try {
  1354.                   if (!waitForWritable(ws, 0, clientCtx.getConf().waitForWriteSetMs)) {
  1355. >                     op.allowFailFastOnUnwritableChannel();
  1356.                   }
  1357.               } finally {

#168
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1352: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.doAsyncAddEntry(...)` indirectly reads without synchronization from `op.entryId`. Potentially races with write in method `LedgerHandle.doAsyncAddEntry(...)`.
 Reporting because this access may occur on a background thread.
  1350.   
  1351.           if (clientCtx.getConf().waitForWriteSetMs >= 0) {
  1352. >             DistributionSchedule.WriteSet ws = distributionSchedule.getWriteSet(op.getEntryId());
  1353.               try {
  1354.                   if (!waitForWritable(ws, 0, clientCtx.getConf().waitForWriteSetMs)) {

#169
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1354: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.doAsyncAddEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1352.               DistributionSchedule.WriteSet ws = distributionSchedule.getWriteSet(op.getEntryId());
  1353.               try {
  1354. >                 if (!waitForWritable(ws, 0, clientCtx.getConf().waitForWriteSetMs)) {
  1355.                       op.allowFailFastOnUnwritableChannel();
  1356.                   }

#170
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandleAdv.java:272: warning: Thread Safety Violation
  Unprotected write. Non-private method `LedgerHandleAdv.doAsyncAddEntry(...)` indirectly writes to field `op.allowFailFast` outside of synchronization.
 Reporting because this access may occur on a background thread.
  270.               try {
  271.                   if (!waitForWritable(ws, 0, clientCtx.getConf().waitForWriteSetMs)) {
  272. >                     op.allowFailFastOnUnwritableChannel();
  273.                   }
  274.               } finally {

#171
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1927: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.ensembleChangeLoop(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1925.               LOG.info("{} reaches max allowed ensemble change number {}",
  1926.                        logContext, clientCtx.getConf().maxAllowedEnsembleChanges);
  1927. >             handleUnrecoverableErrorDuringAdd(WriteException);
  1928.               return;
  1929.           }

#172
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:535: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.enumerateLogsWithMetadataInNamespace()` reads without synchronization from `this.writerZKC`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  533.           String namespaceRootPath = namespace.getPath();
  534.           HashMap<String, byte[]> result = new HashMap<String, byte[]>();
  535. >         ZooKeeperClient zkc = writerZKC;
  536.           try {
  537.               ZooKeeper zk = Utils.sync(zkc, namespaceRootPath);

#173
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:533: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.enumerateLogsWithMetadataInNamespace()` reads without synchronization from `this.namespace`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  531.       public Map<String, byte[]> enumerateLogsWithMetadataInNamespace()
  532.           throws IOException, IllegalArgumentException {
  533. >         String namespaceRootPath = namespace.getPath();
  534.           HashMap<String, byte[]> result = new HashMap<String, byte[]>();
  535.           ZooKeeperClient zkc = writerZKC;

#174
bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java:85: warning: Thread Safety Violation
  Read/Write race. Non-private method `InMemoryMetastoreTable$MetadataVersion.equals(...)` reads without synchronization from `this.version`. Potentially races with write in method `InMemoryMetastoreTable$MetadataVersion.incrementVersion()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  83.               }
  84.               MetadataVersion v = (MetadataVersion) obj;
  85. >             return 0 == (version - v.version);
  86.           }
  87.   

#175
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/SingleDirectoryDbLedgerStorage.java:716: warning: Thread Safety Violation
  Read/Write race. Non-private method `SingleDirectoryDbLedgerStorage.flush()` indirectly reads without synchronization from `this.lastCheckpoint`. Potentially races with write in method `SingleDirectoryDbLedgerStorage.checkpoint(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  714.       public void flush() throws IOException {
  715.           Checkpoint cp = checkpointSource.newCheckpoint();
  716. >         checkpoint(cp);
  717.           checkpointSource.checkpointComplete(cp, true);
  718.       }

#176
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BKLogSegmentWriter.java:1027: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKLogSegmentWriter.flushIfNeeded()` reads without synchronization from `this.outstandingBytes`. Potentially races with write in method `BKLogSegmentWriter.asyncWrite(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1025.       void flushIfNeeded() throws BKTransmitException, WriteException, InvalidEnvelopedEntryException,
  1026.               LockingException, FlushException {
  1027. >         if (outstandingBytes > transmissionThreshold) {
  1028.               // If flush delay is disabled, flush immediately, else schedule appropriately.
  1029.               if (0 == minDelayBetweenImmediateFlushMs) {

#177
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BKLogSegmentWriter.java:990: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKLogSegmentWriter.flushIfNeededNoThrow()` indirectly reads without synchronization from `this.outstandingBytes`. Potentially races with write in method `BKLogSegmentWriter.asyncWrite(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  988.       void flushIfNeededNoThrow() {
  989.           try {
  990. >             flushIfNeeded();
  991.           } catch (IOException ioe) {
  992.               LOG.error("Encountered exception while flushing log records to stream {}",

#178
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1148: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.force()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1146.       public CompletableFuture<Void> force() {
  1147.           CompletableFuture<Void> result = new CompletableFuture<>();
  1148. >         ForceLedgerOp op = new ForceLedgerOp(this, clientCtx.getBookieClient(), getCurrentEnsemble(), result);
  1149.           boolean wasClosed = false;
  1150.           synchronized (this) {

#179
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:142: warning: Interface Not Thread Safe
  Unprotected call to method `RangeOption.endKey()` of un-annotated interface `org.apache.bookkeeper.api.kv.options.RangeOption`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  140.           pKey.retain();
  141.           lKey.retain();
  142. >         if (null != option.endKey()) {
  143.               option.endKey().retain();
  144.           }

#180
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVAsyncStore.java:72: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVAsyncStore.get(...)` indirectly reads without synchronization from `this.readIOScheduler`. Potentially races with write in method `RocksdbKVAsyncStore.init(...)`.
 Reporting because this access may occur on a background thread.
  70.           }
  71.   
  72. >         return executeReadIO(() -> {
  73.               byte[] keyBytes = keyCoder.encode(key);
  74.               byte[] valBytes = localStore.get(keyBytes);

#181
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:75: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  73.    * A {@link PTable} implementation using simple grpc calls.
  74.    */
  75. > @Slf4j
  76.   public class PByteBufSimpleTableImpl
  77.       extends AbstractStub<PByteBufSimpleTableImpl>

#182
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:490: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getAccessControlManager()` reads without synchronization from `this.namespace`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  488.                       throw new IOException("Invalid Access Control List Root Path : " + aclRootPath);
  489.                   }
  490. >                 String zkRootPath = namespace.getPath() + "/" + aclRootPath;
  491.                   LOG.info("Creating zk based access control manager @ {} for {}",
  492.                           zkRootPath, namespace);

#183
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:493: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getAccessControlManager()` reads without synchronization from `this.conf`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  491.                   LOG.info("Creating zk based access control manager @ {} for {}",
  492.                           zkRootPath, namespace);
  493. >                 accessControlManager = new ZKAccessControlManager(conf, readerZKC,
  494.                           zkRootPath, scheduler);
  495.                   LOG.info("Created zk based access control manager @ {} for {}",

#184
bookkeeper-http/servlet-http-server/src/main/java/org/apache/bookkeeper/http/servlet/BookieServletHttpServer.java:37: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieServletHttpServer.getBookieHttpServiceProvider()` reads without synchronization from `servlet.BookieServletHttpServer.bookieHttpServiceProvider`. Potentially races with write in method `BookieServletHttpServer.setHttpServiceProvider(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  35.   
  36.     public static HttpServiceProvider getBookieHttpServiceProvider(){
  37. >     return bookieHttpServiceProvider;
  38.     }
  39.     /**

#185
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:450: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.getCtime()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  448.        */
  449.       public long getCtime() {
  450. >         return getLedgerMetadata().getCtime();
  451.       }
  452.   

#186
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:2054: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.getCurrentEnsemble()` reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2052.           // thing until metadata is immutable. At that point, current ensemble
  2053.           // becomes a property of the LedgerHandle itself.
  2054. >         return LedgerMetadataUtils.getCurrentEnsemble(versionedMetadata.getValue());
  2055.       }
  2056.   

#187
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:387: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.getCustomMetadata()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  385.        */
  386.       public Map<String, byte[]> getCustomMetadata() {
  387. >         return getLedgerMetadata().getCustomMetadata();
  388.       }
  389.   

#188
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java:1675: warning: Thread Safety Violation
  Read/Write race. Non-private method `Bookie.getExitCode()` reads without synchronization from `this.exitCode`. Potentially races with write in method `Bookie.start()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1673.        */
  1674.       public int getExitCode() {
  1675. >         return exitCode;
  1676.       }
  1677.   

#189
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java:270: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieServer.getExitCode()` reads without synchronization from `this.exitCode`. Potentially races with write in method `BookieServer.shutdown()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  268.   
  269.       public int getExitCode() {
  270. >         return exitCode;
  271.       }
  272.   

#190
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:508: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getFifteenMinuteRate()` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  506.       @Override
  507.       public double getFifteenMinuteRate() {
  508. >         return getRate(15 * 60);
  509.       }
  510.   

#191
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:513: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getFiveMinuteRate()` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  511.       @Override
  512.       public double getFiveMinuteRate() {
  513. >         return getRate(5 * 60);
  514.       }
  515.   

#192
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataBookieDriver.java:30: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataBookieDriver.getLayoutManager()` indirectly reads without synchronization from `this.layoutManager`. Potentially races with write in method `EtcdMetadataBookieDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  28.    * Etcd based metadata bookie driver.
  29.    */
  30. > @Slf4j
  31.   public class EtcdMetadataBookieDriver extends EtcdMetadataDriverBase implements MetadataBookieDriver {
  32.   

#193
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:101: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataDriverBase.getLayoutManager()` reads without synchronization from `this.layoutManager`. Potentially races with write in method `EtcdMetadataDriverBase.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
   99.   
  100.       public LayoutManager getLayoutManager() {
  101. >         return layoutManager;
  102.       }
  103.   

#194
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:109: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataDriverBase.getLedgerManagerFactory()` reads with synchronization from `this.conf`. Potentially races with unsynchronized write in method `EtcdMetadataDriverBase.initialize(...)`.
 Reporting because this access may occur on a background thread.
  107.               try {
  108.                   lmFactory = new EtcdLedgerManagerFactory();
  109. >                 lmFactory.initialize(conf, layoutManager, EtcdLedgerManagerFactory.VERSION);
  110.               } catch (IOException ioe) {
  111.                   throw new MetadataException(

#195
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:357: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.getLedgerMetadata()` reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  355.       @Override
  356.       public LedgerMetadata getLedgerMetadata() {
  357. >         return versionedMetadata.getValue();
  358.       }
  359.   

#196
bookkeeper-http/servlet-http-server/src/main/java/org/apache/bookkeeper/http/servlet/BookieServletHttpServer.java:43: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieServletHttpServer.getListenPort()` reads without synchronization from `servlet.BookieServletHttpServer.listenPort`. Potentially races with write in method `BookieServletHttpServer.setPort(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  41.      **/
  42.     public static int getListenPort(){
  43. >     return listenPort;
  44.     }
  45.   

#197
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:427: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getLogMetadataStore()` reads without synchronization from `this.metadataStore`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  425.       @Override
  426.       public LogMetadataStore getLogMetadataStore() {
  427. >         return metadataStore;
  428.       }
  429.   

#198
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:444: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getLogSegmentEntryStore(...)` indirectly reads without synchronization from `this.failureInjector`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  442.               return getWriterEntryStore();
  443.           } else {
  444. >             return getReaderEntryStore();
  445.           }
  446.       }

#199
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:442: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getLogSegmentEntryStore(...)` indirectly reads without synchronization from `this.allocator`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  440.       public LogSegmentEntryStore getLogSegmentEntryStore(Role role) {
  441.           if (Role.WRITER == role) {
  442. >             return getWriterEntryStore();
  443.           } else {
  444.               return getReaderEntryStore();

#200
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:433: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getLogStreamMetadataStore(...)` reads without synchronization from `this.writerStreamMetadataStore`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  431.       public LogStreamMetadataStore getLogStreamMetadataStore(Role role) {
  432.           if (Role.WRITER == role) {
  433. >             return writerStreamMetadataStore;
  434.           } else {
  435.               return readerStreamMetadataStore;

#201
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:435: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getLogStreamMetadataStore(...)` reads without synchronization from `this.readerStreamMetadataStore`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  433.               return writerStreamMetadataStore;
  434.           } else {
  435. >             return readerStreamMetadataStore;
  436.           }
  437.       }

#202
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:518: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getMeanRate()` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  516.       @Override
  517.       public double getMeanRate() {
  518. >         return getRate(Integer.MAX_VALUE);
  519.       }
  520.   

#203
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:522: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getMetadataAccessor(...)` reads without synchronization from `this.conf`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  520.           checkState();
  521.           streamName = validateAndNormalizeName(streamName);
  522. >         return new ZKMetadataAccessor(
  523.                   streamName,
  524.                   conf,

#204
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:520: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getMetadataAccessor(...)` indirectly reads without synchronization from `this.namespace`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  518.               throw new UnsupportedOperationException();
  519.           }
  520. >         checkState();
  521.           streamName = validateAndNormalizeName(streamName);
  522.           return new ZKMetadataAccessor(

#205
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:523: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getOneMinuteRate()` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  521.       @Override
  522.       public double getOneMinuteRate() {
  523. >         return getRate(60);
  524.       }
  525.   

#206
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLoggerAllocator.java:229: warning: Thread Safety Violation
  Read/Write race. Non-private method `EntryLoggerAllocator.getPreallocationFuture()` reads without synchronization from `this.preallocation`. Potentially races with write in method `EntryLoggerAllocator.createNewLog(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  227.        */
  228.       Future<BufferedLogChannel> getPreallocationFuture(){
  229. >         return preallocation;
  230.       }
  231.   }

#207
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:62: warning: Thread Safety Violation
  Read/Write race. Non-private method `RangeRouter.getRange(...)` indirectly reads without synchronization from `this.ranges`. Potentially races with write in method `RangeRouter.setRanges(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  60.        */
  61.       public long getRange(@Nullable K key) {
  62. >         return getRangeProperties(key).getRangeId();
  63.       }
  64.   

#208
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:68: warning: Interface Not Thread Safe
  Unprotected call to method `HashRouter.getRoutingKey(...)` of un-annotated interface `org.apache.bookkeeper.common.router.HashRouter`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because the current class is annotated `@ThreadSafe`.
  66.           long routingKey;
  67.           if (null != key) {
  68. >             routingKey = keyRouter.getRoutingKey(key);
  69.           } else {
  70.               routingKey = ThreadLocalRandom.current().nextLong();

#209
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:74: warning: Thread Safety Violation
  Read/Write race. Non-private method `RangeRouter.getRangeProperties(...)` reads without synchronization from `this.ranges`. Potentially races with write in method `RangeRouter.setRanges(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  72.           HashStreamRanges rs;
  73.           long stamp = lock.tryOptimisticRead();
  74. >         rs = ranges;
  75.           if (!lock.validate(stamp)) {
  76.               stamp = lock.readLock();

#210
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:92: warning: Thread Safety Violation
  Read/Write race. Non-private method `RangeRouter.getRanges()` reads without synchronization from `this.ranges`. Potentially races with write in method `RangeRouter.setRanges(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  90.           HashStreamRanges rs;
  91.           long stamp = lock.tryOptimisticRead();
  92. >         rs = ranges;
  93.           if (!lock.validate(stamp)) {
  94.               stamp = lock.readLock();

#211
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:487: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getRate(...)` reads without synchronization from `this.meter.[_].[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  485.               for (int i = t; i > secFrom; i--) {
  486.                   // no need to synchronize for reading (meter (int) is written atomically)
  487. >                 sum += meter[h][(timeWindow + i) % timeWindow];
  488.               }
  489.           }

#212
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:481: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getRate(...)` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  479.       public double getRate(int seconds) {
  480.           seconds = Math.min(seconds, timeWindow - 2);
  481. >         int t = getNow(getHash()) - 1; // start from last completed second
  482.           int secFrom = t - seconds;
  483.           long sum = 0;

#213
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:454: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.getRawBytes(...)` reads without synchronization from `this.dataCfHandle`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  452.       protected byte[] getRawBytes(K key, byte[] keyBytes) {
  453.           try {
  454. >             return this.db.get(dataCfHandle, keyBytes);
  455.           } catch (RocksDBException e) {
  456.               throw new StateStoreRuntimeException("Error while getting value for key " + key + " from store " + name, e);

#214
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataBookieDriver.java:80: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKMetadataBookieDriver.getRegistrationManager()` reads with synchronization from `this.zk`. Potentially races with unsynchronized write in method `ZKMetadataBookieDriver.close()`.
 Reporting because this access may occur on a background thread.
  78.       public synchronized RegistrationManager getRegistrationManager() {
  79.           if (null == regManager) {
  80. >             regManager = new ZKRegistrationManager(
  81.                   serverConf,
  82.                   zk,

#215
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java:166: warning: Thread Safety Violation
  Read/Write race. Non-private method `FileInfo.getSizeSinceLastWrite()` reads without synchronization from `this.sizeSinceLastWrite`. Potentially races with write in method `FileInfo.setFenced()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  164.   
  165.       public long getSizeSinceLastWrite() {
  166. >         return sizeSinceLastWrite;
  167.       }
  168.   

#216
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:540: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getSnapshot()` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getOneMinuteRate()`.
 Reporting because this access may occur on a background thread.
  538.   
  539.           // get time and trigger housekeeping
  540. >         int now = getNow(0) - 1; // start from last completed second
  541.           int secFrom = now - (timeWindow - 2);
  542.   

#217
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:564: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getSnapshot()` reads without synchronization from `this.buckets.[_].[_]`. Potentially races with write in method `FastTimer.getOneMinuteRate()`.
 Reporting because this access may occur on a background thread.
  562.               // no need to synchronize for reading (buckets (int) is written atomically)
  563.               for (int b = 0; b < numBuckets; b++) {
  564. >                 buckets[b] += this.buckets[b][t];
  565.               }
  566.           }

#218
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:506: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getSubscriptionsStore(...)` reads without synchronization from `this.conf`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  504.           return new ZKSubscriptionsStore(
  505.                   writerZKC,
  506. >                 LogMetadataForReader.getSubscribersPath(namespace, streamName, conf.getUnpartitionedStreamName()));
  507.       }
  508.   

#219
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java:215: warning: Thread Safety Violation
  Read/Write race. Non-private method `BenchThroughputLatency.getThroughput()` reads without synchronization from `this.throughput`. Potentially races with write in method `BenchThroughputLatency.run()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  213.       long throughput = -1;
  214.       public long getThroughput() {
  215. >         return throughput;
  216.       }
  217.   

#220
microbenchmarks/src/main/java/org/apache/bookkeeper/stats/codahale/TimerBenchmark.java:108: warning: Thread Safety Violation
  Read/Write race. Non-private method `TimerBenchmark$MyState.getTime()` reads without synchronization from `codahale.TimerBenchmark$MyState.times`. Potentially races with write in method `TimerBenchmark$MyState.doSetup()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  106.   
  107.           public long getTime() {
  108. >             return times[(timeIdx++) % times.length];
  109.           }
  110.   

#221
microbenchmarks/src/main/java/org/apache/bookkeeper/stats/codahale/TimerBenchmark.java:104: warning: Thread Safety Violation
  Read/Write race. Non-private method `TimerBenchmark$MyState.getTimer()` reads without synchronization from `codahale.TimerBenchmark$MyState.timers`. Potentially races with write in method `TimerBenchmark$MyState.doSetup()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  102.   
  103.           public OpStatsLogger getTimer() {
  104. >             return timers[(timerIdx++) % timers.length];
  105.           }
  106.   

#222
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:417: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getUri()` reads without synchronization from `this.namespace`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  415.       @Override
  416.       public URI getUri() {
  417. >         return namespace;
  418.       }
  419.   

#223
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:361: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.getVersionedLedgerMetadata()` reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  359.   
  360.       Versioned<LedgerMetadata> getVersionedLedgerMetadata() {
  361. >         return versionedMetadata;
  362.       }
  363.   

#224
bookkeeper-server/src/main/java/org/apache/bookkeeper/discover/ZKRegistrationClient.java:181: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKRegistrationClient.getWatchReadOnlyBookiesTask()` reads without synchronization from `this.watchReadOnlyBookiesTask`. Potentially races with write in method `ZKRegistrationClient.watchReadOnlyBookies(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  179.       @Getter(AccessLevel.PACKAGE)
  180.       private WatchTask watchWritableBookiesTask = null;
  181. >     @Getter(AccessLevel.PACKAGE)
  182.       private WatchTask watchReadOnlyBookiesTask = null;
  183.       private final ConcurrentHashMap<BookieId, Versioned<BookieServiceInfo>> bookieServiceInfoCache =

#225
bookkeeper-server/src/main/java/org/apache/bookkeeper/discover/ZKRegistrationClient.java:179: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKRegistrationClient.getWatchWritableBookiesTask()` reads without synchronization from `this.watchWritableBookiesTask`. Potentially races with write in method `ZKRegistrationClient.watchWritableBookies(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  177.       private final ZooKeeper zk;
  178.       private final ScheduledExecutorService scheduler;
  179. >     @Getter(AccessLevel.PACKAGE)
  180.       private WatchTask watchWritableBookiesTask = null;
  181.       @Getter(AccessLevel.PACKAGE)

#226
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1915: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.handleBookieFailure(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1913.           }
  1914.           if (triggerLoop) {
  1915. >             ensembleChangeLoop(origEnsemble, toReplace);
  1916.           }
  1917.       }

#227
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:721: warning: Thread Safety Violation
  Unprotected write. Non-private method `TopologyAwareEnsemblePlacementPolicy.handleBookiesThatJoined(...)` mutates container `this.historyBookies` via call to `Map.put(...)` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  719.                   topology.add(node);
  720.                   knownBookies.put(addr, node);
  721. >                 historyBookies.put(addr, node);
  722.                   if (this.isWeighted) {
  723.                       this.bookieInfoMap.putIfAbsent(node, new BookieInfo());

#228
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:720: warning: Thread Safety Violation
  Unprotected write. Non-private method `TopologyAwareEnsemblePlacementPolicy.handleBookiesThatJoined(...)` mutates container `this.knownBookies` via call to `Map.put(...)` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  718.                   BookieNode node = createBookieNode(addr);
  719.                   topology.add(node);
  720. >                 knownBookies.put(addr, node);
  721.                   historyBookies.put(addr, node);
  722.                   if (this.isWeighted) {

#229
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:723: warning: Thread Safety Violation
  Read/Write race. Non-private method `TopologyAwareEnsemblePlacementPolicy.handleBookiesThatJoined(...)` reads without synchronization from `this.bookieInfoMap`. Potentially races with write in method `TopologyAwareEnsemblePlacementPolicy.updateBookieInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  721.                   historyBookies.put(addr, node);
  722.                   if (this.isWeighted) {
  723. >                     this.bookieInfoMap.putIfAbsent(node, new BookieInfo());
  724.                   }
  725.   

#230
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:690: warning: Thread Safety Violation
  Read/Write race. Non-private method `TopologyAwareEnsemblePlacementPolicy.handleBookiesThatLeft(...)` reads without synchronization from `this.bookieInfoMap`. Potentially races with write in method `TopologyAwareEnsemblePlacementPolicy.updateBookieInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  688.                       topology.remove(node);
  689.                       if (this.isWeighted) {
  690. >                         this.bookieInfoMap.remove(node);
  691.                       }
  692.   

#231
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:686: warning: Thread Safety Violation
  Unprotected write. Non-private method `TopologyAwareEnsemblePlacementPolicy.handleBookiesThatLeft(...)` mutates container `this.knownBookies` via call to `Map.remove(...)` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  684.           for (BookieId addr : leftBookies) {
  685.               try {
  686. >                 BookieNode node = knownBookies.remove(addr);
  687.                   if (null != node) {
  688.                       topology.remove(node);

#232
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1773: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.handleUnrecoverableErrorDuringAdd(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1771.       // close the ledger and send fails to all the adds in the pipeline
  1772.       void handleUnrecoverableErrorDuringAdd(int rc) {
  1773. >         if (getLedgerMetadata().getState() == LedgerMetadata.State.IN_RECOVERY) {
  1774.               // we should not close ledger if ledger is recovery mode
  1775.               // otherwise we may lose entry.

#233
bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java:95: warning: Thread Safety Violation
  Read/Write race. Non-private method `InMemoryMetastoreTable$MetadataVersion.hashCode()` reads without synchronization from `this.version`. Potentially races with write in method `InMemoryMetastoreTable$MetadataVersion.incrementVersion()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  93.           @Override
  94.           public int hashCode() {
  95. >             return version;
  96.           }
  97.       }

#234
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:216: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  214.           pKey.retain();
  215.           lKey.retain();
  216. >         return retryUtils.execute(() -> fromListenableFuture(
  217.               ClientCalls.futureUnaryCall(
  218.                   getChannel(pKey).newCall(getIncrementMethod(), getCallOptions()),

#235
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:75: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  73.    * A {@link PTable} implementation using simple grpc calls.
  74.    */
  75. > @Slf4j
  76.   public class PByteBufSimpleTableImpl
  77.       extends AbstractStub<PByteBufSimpleTableImpl>

#236
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/PortManager.java:46: warning: Thread Safety Violation
  Unprotected write. Non-private method `PortManager.initPort(...)` writes to field `util.PortManager.nextPort` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  44.        */
  45.       public static void initPort(int initPort) {
  46. >         nextPort = initPort;
  47.       }
  48.   

#237
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:68: warning: Thread Safety Violation
  Unprotected write. Non-private method `EtcdMetadataDriverBase.initialize(...)` writes to field `this.statsLogger` outside of synchronization.
 Reporting because this access may occur on a background thread.
  66.           throws MetadataException {
  67.           this.conf = conf;
  68. >         this.statsLogger = statsLogger;
  69.   
  70.           final String metadataServiceUriStr;

#238
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:85: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataDriverBase.initialize(...)` reads without synchronization from `this.keyPrefix`. Potentially races with write in method `EtcdMetadataDriverBase.initialize(...)`.
 Reporting because this access may occur on a background thread.
  83.               .collect(Collectors.toList());
  84.   
  85. >         log.info("Initializing etcd metadata driver : etcd endpoints = {}, key scope = {}",
  86.               etcdEndpoints, keyPrefix);
  87.   

#239
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:78: warning: Thread Safety Violation
  Unprotected write. Non-private method `EtcdMetadataDriverBase.initialize(...)` writes to field `this.keyPrefix` outside of synchronization.
 Reporting because this access may occur on a background thread.
  76.           }
  77.           ServiceURI serviceURI = ServiceURI.create(metadataServiceUriStr);
  78. >         this.keyPrefix = serviceURI.getServicePath();
  79.   
  80.           List<String> etcdEndpoints = Lists.newArrayList(serviceURI.getServiceHosts())

#240
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:94: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataDriverBase.initialize(...)` reads without synchronization from `this.client`. Potentially races with write in method `EtcdMetadataDriverBase.close()`.
 Reporting because this access may occur on a background thread.
  92.           }
  93.   
  94. >         this.layoutManager = new EtcdLayoutManager(
  95.               client,
  96.               keyPrefix

#241
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:67: warning: Thread Safety Violation
  Unprotected write. Non-private method `EtcdMetadataDriverBase.initialize(...)` writes to field `this.conf` outside of synchronization.
 Reporting because this access may occur on a background thread.
  65.       protected void initialize(AbstractConfiguration<?> conf, StatsLogger statsLogger)
  66.           throws MetadataException {
  67. >         this.conf = conf;
  68.           this.statsLogger = statsLogger;
  69.   

#242
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataClientDriver.java:53: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataClientDriver.initialize(...)` indirectly reads without synchronization from `this.client`. Potentially races with write in method `EtcdMetadataClientDriver.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  51.                                              Optional<Object> ctx)
  52.               throws MetadataException {
  53. >         super.initialize(conf, statsLogger);
  54.           this.conf = conf;
  55.           this.statsLogger = statsLogger;

#243
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataBookieDriver.java:60: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKMetadataBookieDriver.initialize(...)` indirectly reads with synchronization from `this.zk`. Potentially races with unsynchronized write in method `ZKMetadataBookieDriver.close()`.
 Reporting because this access may occur on a background thread.
  58.                                                           StatsLogger statsLogger)
  59.               throws MetadataException {
  60. >         super.initialize(
  61.               conf,
  62.               statsLogger.scope(BOOKIE_SCOPE),

#244
stream/common/src/main/java/org/apache/bookkeeper/common/grpc/stats/MonitoringClientInterceptor.java:78: warning: Interface Not Thread Safe
  Unprotected call to method `StatsLogger.scope(...)` of un-annotated interface `org.apache.bookkeeper.stats.StatsLogger`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.ClientInterceptor` is annotated `@ThreadSafe`.
  76.       public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(
  77.           MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) {
  78. >         ClientStats stats = getMethodStats(method);
  79.           return new MonitoringClientCall<>(
  80.               next.newCall(method, callOptions),

#245
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/routing/RoutingHeaderProxyInterceptor.java:166: warning: Interface Not Thread Safe
  Unprotected call to method `Logger.isTraceEnabled()` of un-annotated interface `org.slf4j.Logger`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.ClientInterceptor` is annotated `@ThreadSafe`.
  164.                                                                  CallOptions callOptions,
  165.                                                                  Channel next) {
  166. >         if (log.isTraceEnabled()) {
  167.               log.trace("Intercepting method {} : req marshaller = {}, resp marshaller = {}",
  168.                   method.getFullMethodName(),

#246
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/container/StorageContainerClientInterceptor.java:53: warning: Interface Not Thread Safe
  Unprotected call to method `Logger.isTraceEnabled()` of un-annotated interface `org.slf4j.Logger`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.ClientInterceptor` is annotated `@ThreadSafe`.
  51.                                                                  CallOptions callOptions,
  52.                                                                  Channel next) {
  53. >         if (log.isTraceEnabled()) {
  54.               log.trace("Intercepting method {} : req marshaller = {}, resp marshaller = {}",
  55.                   method.getFullMethodName(),

#247
stream/common/src/main/java/org/apache/bookkeeper/common/grpc/stats/MonitoringServerInterceptor.java:82: warning: Interface Not Thread Safe
  Unprotected call to method `StatsLogger.scope(...)` of un-annotated interface `org.apache.bookkeeper.stats.StatsLogger`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.ServerInterceptor` is annotated `@ThreadSafe`.
  80.                                                         ServerCallHandler<ReqT, RespT> next) {
  81.           MethodDescriptor<ReqT, RespT> method = call.getMethodDescriptor();
  82. >         ServerStats stats = getMethodStats(method);
  83.           ServerCall<ReqT, RespT> monitoringCall = new MonitoringServerCall<>(call, stats);
  84.           return new MonitoringServerCallListener<>(

#248
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java:158: warning: Thread Safety Violation
  Read/Write race. Non-private method `FileInfo.isClosed()` reads without synchronization from `this.isClosed`. Potentially races with write in method `FileInfo.close(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  156.   
  157.       public boolean isClosed() {
  158. >         return isClosed;
  159.       }
  160.   

#249
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:516: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.isHandleWritable()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  514.   
  515.       boolean isHandleWritable() {
  516. >         return !getLedgerMetadata().isClosed() && handleState == HandleState.OPEN;
  517.       }
  518.   

#250
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java:262: warning: Thread Safety Violation
  Read/Write race. Non-private method `AuditorElector.isRunning()` reads without synchronization from `this.auditor`. Potentially races with write in method `AuditorElector.shutdown()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  260.        */
  261.       public boolean isRunning() {
  262. >         if (auditor != null) {
  263.               return auditor.isRunning();
  264.           }

#251
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/TransientLedgerInfo.java:144: warning: Thread Safety Violation
  Read/Write race. Non-private method `TransientLedgerInfo.isStale()` reads without synchronization from `this.lastAccessed`. Potentially races with write in method `TransientLedgerInfo.setLastAddConfirmed(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  142.       boolean isStale() {
  143.           return (lastAccessed + TimeUnit.MINUTES.toMillis(LEDGER_INFO_CACHING_TIME_MINUTES)) < System
  144. >                 .currentTimeMillis();
  145.       }
  146.   

#252
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClientImpl.java:657: warning: Thread Safety Violation
  Unprotected write. Non-private method `BookieClientImpl.main(...)` indirectly mutates container `util.ReflectionUtils.constructorCache` via call to `Map.put(...)` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  655.           ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(
  656.                   new DefaultThreadFactory("BookKeeperClientScheduler"));
  657. >         BookieClientImpl bc = new BookieClientImpl(new ClientConfiguration(), eventLoopGroup,
  658.                   null, executor, scheduler, NullStatsLogger.INSTANCE, b -> BookieSocketAddress.class.cast(b));
  659.           BookieId addr = new BookieSocketAddress(args[0], Integer.parseInt(args[1])).toBookieId();

#253
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java:83: warning: Thread Safety Violation
  Read/Write race. Non-private method `DefaultEnsemblePlacementPolicy.newEnsemble(...)` reads without synchronization from `this.isWeighted`. Potentially races with write in method `DefaultEnsemblePlacementPolicy.initialize(...)`.
 Reporting because this access may occur on a background thread.
  81.           }
  82.   
  83. >         if (isWeighted) {
  84.               // hold the readlock while selecting bookies. We don't want the list of bookies
  85.               // changing while we are creating the ensemble

#254
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RegionAwareEnsemblePlacementPolicy.java:296: warning: Thread Safety Violation
  Read/Write race. Non-private method `RegionAwareEnsemblePlacementPolicy.newEnsemble(...)` reads without synchronization from `this.disableDurabilityFeature`. Potentially races with write in method `RegionAwareEnsemblePlacementPolicy.initialize(...)`.
 Reporting because this access may occur on a background thread.
  294.               throws BKException.BKNotEnoughBookiesException {
  295.   
  296. >         int effectiveMinRegionsForDurability = disableDurabilityFeature.isAvailable() ? 1 : minRegionsForDurability;
  297.   
  298.           // All of these conditions indicate bad configuration

#255
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:339: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZoneawareEnsemblePlacementPolicyImpl.newEnsemble(...)` reads without synchronization from `this.enforceStrictZoneawarePlacement`. Potentially races with write in method `ZoneawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  337.               int ackQuorumSize, Map<String, byte[]> customMetadata, Set<BookieId> excludeBookies)
  338.               throws BKNotEnoughBookiesException {
  339. >         if (enforceStrictZoneawarePlacement) {
  340.               if (ensembleSize % writeQuorumSize != 0) {
  341.                   /*

#256
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:393: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZoneawareEnsemblePlacementPolicyImpl.newEnsemble(...)` reads without synchronization from `this.desiredNumZonesPerWriteQuorum`. Potentially races with write in method `ZoneawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  391.               }
  392.           }
  393. >         int desiredNumZonesPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, desiredNumZonesPerWriteQuorum);
  394.           List<BookieId> newEnsemble = new ArrayList<BookieId>(
  395.                   Collections.nCopies(ensembleSize, null));

#257
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:369: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZoneawareEnsemblePlacementPolicyImpl.newEnsemble(...)` reads without synchronization from `this.minNumZonesPerWriteQuorum`. Potentially races with write in method `ZoneawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  367.                           + " writeQuorumSize When StrictZoneawarePlacement is enabled");
  368.               }
  369. >             if (writeQuorumSize <= minNumZonesPerWriteQuorum) {
  370.                   /*
  371.                    * if we allow writeQuorumSize <= minNumZonesPerWriteQuorum,

#258
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/store/MVCCStoreFactoryImpl.java:195: warning: Thread Safety Violation
  Read/Write race. Non-private method `MVCCStoreFactoryImpl.newStore(...)` reads without synchronization from `this.checkpointStore`. Potentially races with write in method `MVCCStoreFactoryImpl.openStore(...)`.
 Reporting because this access may occur on a background thread.
  193.               normalizedName(rangeId));
  194.   
  195. >         if (null == checkpointStore) {
  196.               checkpointStore = checkpointStoreSupplier.get();
  197.           }

#259
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/store/MVCCStoreFactoryImpl.java:196: warning: Thread Safety Violation
  Unprotected write. Non-private method `MVCCStoreFactoryImpl.newStore(...)` writes to field `this.checkpointStore` outside of synchronization.
 Reporting because this access may occur on a background thread.
  194.   
  195.           if (null == checkpointStore) {
  196. >             checkpointStore = checkpointStoreSupplier.get();
  197.           }
  198.   

#260
bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java:528: warning: Thread Safety Violation
  Read/Write race. Non-private method `TLSContextFactory.newTLSHandler()` indirectly reads without synchronization from `this.allocator`. Potentially races with write in method `TLSContextFactory.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  526.       @Override
  527.       public SslHandler newTLSHandler() {
  528. >         return this.newTLSHandler(null, -1);
  529.       }
  530.   

#261
bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java:535: warning: Thread Safety Violation
  Read/Write race. Non-private method `TLSContextFactory.newTLSHandler(...)` reads without synchronization from `this.protocols`. Potentially races with write in method `TLSContextFactory.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  533.           SslHandler sslHandler = getSSLContext().newHandler(allocator, peer, port);
  534.   
  535. >         if (protocols != null && protocols.length != 0) {
  536.               sslHandler.engine().setEnabledProtocols(protocols);
  537.           }

#262
bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java:542: warning: Thread Safety Violation
  Read/Write race. Non-private method `TLSContextFactory.newTLSHandler(...)` reads without synchronization from `this.ciphers`. Potentially races with write in method `TLSContextFactory.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  540.           }
  541.   
  542. >         if (ciphers != null && ciphers.length != 0) {
  543.               sslHandler.engine().setEnabledCipherSuites(ciphers);
  544.           }

#263
bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java:549: warning: Thread Safety Violation
  Read/Write race. Non-private method `TLSContextFactory.newTLSHandler(...)` reads without synchronization from `this.config`. Potentially races with write in method `TLSContextFactory.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  547.           }
  548.   
  549. >         if (type == NodeType.Client && ((ClientConfiguration) config).getHostnameVerificationEnabled()) {
  550.               SSLParameters sslParameters = sslHandler.engine().getSSLParameters();
  551.               sslParameters.setEndpointIdentificationAlgorithm("HTTPS");

#264
bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java:533: warning: Thread Safety Violation
  Read/Write race. Non-private method `TLSContextFactory.newTLSHandler(...)` reads without synchronization from `this.allocator`. Potentially races with write in method `TLSContextFactory.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  531.       @Override
  532.       public SslHandler newTLSHandler(String peer, int port) {
  533. >         SslHandler sslHandler = getSSLContext().newHandler(allocator, peer, port);
  534.   
  535.           if (protocols != null && protocols.length != 0) {

#265
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java:188: warning: Thread Safety Violation
  Unprotected write. Non-private method `LedgerRecoveryOp.onEntryComplete(...)` indirectly writes to field `entry.data` outside of synchronization.
 Reporting because this access may occur on a background thread.
  186.           if (!promise.isDone() && !readDone && rc == BKException.Code.OK) {
  187.               readCount.incrementAndGet();
  188. >             byte[] data = entry.getEntry();
  189.   
  190.               /*

#266
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java:385: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieInfoReader.onExit()` reads without synchronization from `this.errorCnt`. Potentially races with write in method `BookieInfoReader.getReadWriteBookieInfo()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  383.       void onExit() {
  384.           bk.placementPolicy.updateBookieInfo(bookieInfoMap.getBookieMap());
  385. >         if (errorCnt > 0) {
  386.               if (LOG.isInfoEnabled()) {
  387.                   LOG.info("Rescheduling in {}s due to errors", conf.getGetBookieInfoIntervalSeconds());

#267
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java:391: warning: Thread Safety Violation
  Unprotected write. Non-private method `BookieInfoReader.onExit()` indirectly writes to field `this.instanceState.running` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  389.               instanceState.tryStartPartial();
  390.               submitTaskWithDelay(conf.getGetBookieInfoRetryIntervalSeconds());
  391. >         } else if (instanceState.completeUnlessQueued()) {
  392.               if (LOG.isInfoEnabled()) {
  393.                   LOG.info("Rescheduling, another scan is pending");

#268
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java:389: warning: Thread Safety Violation
  Unprotected write. Non-private method `BookieInfoReader.onExit()` indirectly writes to field `this.instanceState.queuedType` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  387.                   LOG.info("Rescheduling in {}s due to errors", conf.getGetBookieInfoIntervalSeconds());
  388.               }
  389. >             instanceState.tryStartPartial();
  390.               submitTaskWithDelay(conf.getGetBookieInfoRetryIntervalSeconds());
  391.           } else if (instanceState.completeUnlessQueued()) {

#269
stream/distributedlog/core/src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java:246: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKDistributedLock$3.onSuccess(...)` writes to field `this.this$0.lockWaiter` outside of synchronization.
 Reporting because this access may occur on a background thread.
  244.                       }
  245.                       tryLockFuture = null;
  246. >                     lockWaiter = waiter;
  247.                       waitForAcquire(waiter, acquirePromise);
  248.                   }

#270
stream/distributedlog/core/src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java:245: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKDistributedLock$3.onSuccess(...)` writes to field `this.this$0.tryLockFuture` outside of synchronization.
 Reporting because this access may occur on a background thread.
  243.                           }
  244.                       }
  245. >                     tryLockFuture = null;
  246.                       lockWaiter = waiter;
  247.                       waitForAcquire(waiter, acquirePromise);

#271
stream/distributedlog/core/src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java:200: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKDistributedLock$2.onSuccess(...)` indirectly writes to field `this.this$0.tryLockFuture` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  198.           lockFactory
  199.               .createLock(lockPath, lockContext)
  200. >             .whenCompleteAsync(new FutureEventListener<SessionLock>() {
  201.               @Override
  202.               public void onSuccess(SessionLock lock) {

#272
stream/distributedlog/core/src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java:232: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKDistributedLock$3.onSuccess(...)` indirectly writes to field `this.this$0.lockWaiter` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  230.           tryLockFuture = lock.asyncTryLock(lockTimeout, TimeUnit.MILLISECONDS);
  231.           tryLockFuture.whenCompleteAsync(
  232. >             new FutureEventListener<LockWaiter>() {
  233.                   @Override
  234.                   public void onSuccess(LockWaiter waiter) {

#273
stream/distributedlog/core/src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java:214: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKDistributedLock$2.onSuccess(...)` indirectly writes to field `this.this$0.tryLockFuture` outside of synchronization.
 Reporting because this access may occur on a background thread.
  212.                       internalLock.setLockListener(ZKDistributedLock.this);
  213.                   }
  214. >                 asyncTryLock(lock, acquirePromise, lockTimeout);
  215.               }
  216.   

#274
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:318: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.writeOpts` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  316.           // initialize the write options
  317.   
  318. >         writeOpts = new WriteOptions();
  319.           writeOpts.setDisableWAL(true); // disable wal, since the source of truth will be on distributedlog
  320.   

#275
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:331: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.metaCfHandle` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  329.           Pair<RocksDB, List<ColumnFamilyHandle>> dbPair = openLocalDB(dbDir, dbOpts, cfOpts);
  330.           this.db = dbPair.getLeft();
  331. >         this.metaCfHandle = dbPair.getRight().get(0);
  332.           this.dataCfHandle = dbPair.getRight().get(1);
  333.       }

#276
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:329: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.dbDir`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  327.   
  328.           this.dbDir = spec.getLocalStateStoreDir();
  329. >         Pair<RocksDB, List<ColumnFamilyHandle>> dbPair = openLocalDB(dbDir, dbOpts, cfOpts);
  330.           this.db = dbPair.getLeft();
  331.           this.metaCfHandle = dbPair.getRight().get(0);

#277
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:302: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.dbOpts` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  300.           tableConfig.setChecksumType(DEFAULT_CHECKSUM_TYPE);
  301.   
  302. >         dbOpts = new DBOptions();
  303.           dbOpts.setCreateIfMissing(true);
  304.           dbOpts.setErrorIfExists(false);

#278
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:332: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.dataCfHandle` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  330.           this.db = dbPair.getLeft();
  331.           this.metaCfHandle = dbPair.getRight().get(0);
  332. >         this.dataCfHandle = dbPair.getRight().get(1);
  333.       }
  334.   

#279
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:330: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.db` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  328.           this.dbDir = spec.getLocalStateStoreDir();
  329.           Pair<RocksDB, List<ColumnFamilyHandle>> dbPair = openLocalDB(dbDir, dbOpts, cfOpts);
  330. >         this.db = dbPair.getLeft();
  331.           this.metaCfHandle = dbPair.getRight().get(0);
  332.           this.dataCfHandle = dbPair.getRight().get(1);

#280
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:328: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.dbDir` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  326.           // open the rocksdb
  327.   
  328. >         this.dbDir = spec.getLocalStateStoreDir();
  329.           Pair<RocksDB, List<ColumnFamilyHandle>> dbPair = openLocalDB(dbDir, dbOpts, cfOpts);
  330.           this.db = dbPair.getLeft();

#281
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:303: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.dbOpts`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  301.   
  302.           dbOpts = new DBOptions();
  303. >         dbOpts.setCreateIfMissing(true);
  304.           dbOpts.setErrorIfExists(false);
  305.           dbOpts.setInfoLogLevel(DEFAULT_LOG_LEVEL);

#282
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:324: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.flushOpts`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  322.   
  323.           flushOpts = new FlushOptions();
  324. >         flushOpts.setWaitForFlush(true);
  325.   
  326.           // open the rocksdb

#283
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:323: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.flushOpts` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  321.           // initialize the flush options
  322.   
  323. >         flushOpts = new FlushOptions();
  324.           flushOpts.setWaitForFlush(true);
  325.   

#284
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:310: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.cfOpts`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  308.   
  309.           cfOpts = new ColumnFamilyOptions();
  310. >         cfOpts.setTableFormatConfig(tableConfig);
  311.           cfOpts.setWriteBufferSize(WRITE_BUFFER_SIZE);
  312.           cfOpts.setCompressionType(DEFAULT_COMPRESSION_TYPE);

#285
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:319: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.writeOpts`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  317.   
  318.           writeOpts = new WriteOptions();
  319. >         writeOpts.setDisableWAL(true); // disable wal, since the source of truth will be on distributedlog
  320.   
  321.           // initialize the flush options

#286
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:309: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.cfOpts` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  307.           dbOpts.setCreateMissingColumnFamilies(true);
  308.   
  309. >         cfOpts = new ColumnFamilyOptions();
  310.           cfOpts.setTableFormatConfig(tableConfig);
  311.           cfOpts.setWriteBufferSize(WRITE_BUFFER_SIZE);

#287
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/store/MVCCStoreFactoryImpl.java:163: warning: Thread Safety Violation
  Unprotected write. Non-private method `MVCCStoreFactoryImpl.openStore(...)` indirectly writes to field `this.checkpointStore` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  161.           MVCCAsyncStore<byte[], byte[]> store = getStore(scId, streamId, rangeId);
  162.           if (null == store) {
  163. >             return newStore(scId, streamId, rangeId);
  164.           } else {
  165.               return FutureUtils.value(store);

#288
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java:138: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerChecker$LedgerFragmentCallback.operationComplete(...)` reads without synchronization from container `this.badBookies` via call to `Map.keySet()`. Potentially races with write in method `LedgerChecker$LedgerFragmentCallback.operationComplete(...)`.
 Reporting because this access may occur on a background thread.
  136.                       }
  137.                       cb.operationComplete(rcToReturn,
  138. >                             fragment.subset(badBookies.keySet()));
  139.                   }
  140.               }

#289
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java:98: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerChecker$LedgerFragmentCallback.operationComplete(...)` indirectly reads without synchronization from container `this.badBookies` via call to `Map.keySet()`. Potentially races with write in method `LedgerChecker$LedgerFragmentCallback.operationComplete(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
   96.        * This will collect the bad bookies inside a ledger fragment.
   97.        */
   98. >     private static class LedgerFragmentCallback implements GenericCallback<LedgerFragment> {
   99.   
  100.           private final LedgerFragment fragment;

#290
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java:208: warning: Thread Safety Violation
  Unprotected write. Non-private method `BenchReadThroughputLatency$2.process(...)` indirectly mutates container `util.ReflectionUtils.constructorCache` via call to `Map.put(...)` outside of synchronization.
 Reporting because this access may occur on a background thread.
  206.                               if (event.getType() == Event.EventType.NodeCreated
  207.                                          && event.getPath().equals(nodepath)) {
  208. >                                 readLedger(conf, ledger.get(), passwd);
  209.                                   shutdownLatch.countDown();
  210.                               } else if (event.getType() == Event.EventType.NodeChildrenChanged) {

#291
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:169: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  167.           lKey.retain();
  168.           value.retain();
  169. >         return retryUtils.execute(() -> fromListenableFuture(
  170.               ClientCalls.futureUnaryCall(
  171.                   getChannel(pKey).newCall(getPutMethod(), getCallOptions()),

#292
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVAsyncStore.java:97: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVAsyncStore.put(...)` reads without synchronization from `this.writeIOScheduler`. Potentially races with write in method `RocksdbKVAsyncStore.init(...)`.
 Reporting because this access may occur on a background thread.
  95.               .setPutReq(KVUtils.newPutRequest(keyBytes, valBytes))
  96.               .build();
  97. >         return writeCommandReturnTxId(command).thenApplyAsync((revision) -> {
  98.               ByteBuf serializedBuf = KVUtils.serialize(valBytes, revision);
  99.               try {

#293
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVAsyncStore.java:91: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVAsyncStore.put(...)` reads without synchronization from `this.keyCoder`. Potentially races with write in method `RocksdbKVAsyncStore.init(...)`.
 Reporting because this access may occur on a background thread.
  89.           }
  90.   
  91. >         byte[] keyBytes = keyCoder.encode(key);
  92.           byte[] valBytes = valCoder.encode(value);
  93.   

#294
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVAsyncStore.java:92: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVAsyncStore.put(...)` reads without synchronization from `this.valCoder`. Potentially races with write in method `RocksdbKVAsyncStore.init(...)`.
 Reporting because this access may occur on a background thread.
  90.   
  91.           byte[] keyBytes = keyCoder.encode(key);
  92. >         byte[] valBytes = valCoder.encode(value);
  93.   
  94.           Command command = Command.newBuilder()

#295
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:75: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  73.    * A {@link PTable} implementation using simple grpc calls.
  74.    */
  75. > @Slf4j
  76.   public class PByteBufSimpleTableImpl
  77.       extends AbstractStub<PByteBufSimpleTableImpl>

#296
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:764: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readAsync(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  762.           }
  763.   
  764. >         return readEntriesInternalAsync(firstEntry, lastEntry, false);
  765.       }
  766.   

#297
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:643: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readEntries(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  641.           CompletableFuture<Enumeration<LedgerEntry>> result = new CompletableFuture<>();
  642.   
  643. >         asyncReadEntries(firstEntry, lastEntry, new SyncReadCallback(result), null);
  644.   
  645.           return SyncCallbackUtils.waitForResult(result);

#298
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:889: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readEntriesInternalAsync(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  887.                   DistributionSchedule.WriteSet ws = distributionSchedule.getWriteSet(firstEntry);
  888.                   try {
  889. >                     if (!waitForWritable(ws, ws.size() - 1, clientCtx.getConf().waitForWriteSetMs)) {
  890.                           op.allowFailFastOnUnwritableChannel();
  891.                       }

#299
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1759: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readExplicitLastConfirmed()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1757.       public long readExplicitLastConfirmed() throws InterruptedException, BKException {
  1758.           LastConfirmedCtx ctx = new LastConfirmedCtx();
  1759. >         asyncReadExplicitLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);
  1760.           synchronized (ctx) {
  1761.               while (!ctx.ready()) {

#300
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1515: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readLastAddConfirmedAndEntryAsync(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1513.                                                                                         boolean parallel) {
  1514.           FutureReadLastConfirmedAndEntry result = new FutureReadLastConfirmedAndEntry();
  1515. >         asyncReadLastConfirmedAndEntry(entryId, timeOutInMillis, parallel, result, null);
  1516.           return result;
  1517.       }

#301
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1503: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readLastAddConfirmedAsync()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1501.       public CompletableFuture<Long> readLastAddConfirmedAsync() {
  1502.           FutureReadLastConfirmed result = new FutureReadLastConfirmed();
  1503. >         asyncReadLastConfirmed(result, null);
  1504.           return result;
  1505.       }

#302
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1650: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readLastConfirmed()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1648.               throws InterruptedException, BKException {
  1649.           LastConfirmedCtx ctx = new LastConfirmedCtx();
  1650. >         asyncReadLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);
  1651.           synchronized (ctx) {
  1652.               while (!ctx.ready()) {

#303
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java:131: warning: Thread Safety Violation
  Unprotected write. Non-private method `LedgerRecoveryOp$1.readLastConfirmedDataComplete(...)` writes to field `this.this$0.metadataForRecovery` outside of synchronization.
 Reporting because this access may occur on a background thread.
  129.                               // keep a copy of ledger metadata before proceeding
  130.                               // ledger recovery
  131. >                             metadataForRecovery = lh.getLedgerMetadata();
  132.                               doRecoveryRead();
  133.                           } else if (rc == BKException.Code.TimeoutException) {

#304
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:862: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readLastEntry()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  860.           } else {
  861.               CompletableFuture<Enumeration<LedgerEntry>> result = new CompletableFuture<>();
  862. >             asyncReadEntries(lastEntryId, lastEntryId, new SyncReadCallback(result), null);
  863.   
  864.               return SyncCallbackUtils.waitForResult(result).nextElement();

#305
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:799: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readUnconfirmedAsync(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  797.           }
  798.   
  799. >         return readEntriesInternalAsync(firstEntry, lastEntry, false);
  800.       }
  801.   

#306
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:666: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readUnconfirmedEntries(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  664.           CompletableFuture<Enumeration<LedgerEntry>> result = new CompletableFuture<>();
  665.   
  666. >         asyncReadUnconfirmedEntries(firstEntry, lastEntry, new SyncReadCallback(result), null);
  667.   
  668.           return SyncCallbackUtils.waitForResult(result);

#307
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:273: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.recordReadErrorOnBookie(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  271.               // This will be idempotent when we have multiple read errors on the
  272.               // same bookie. The net result is that we just go to the next bookie
  273. >             stickyBookieIndex = clientCtx.getPlacementPolicy().getStickyReadBookieIndex(getLedgerMetadata(),
  274.                       Optional.of(bookieIndex));
  275.           }

#308
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:422: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZoneawareEnsemblePlacementPolicyImpl.replaceBookie(...)` reads without synchronization from `this.desiredNumZonesPerWriteQuorum`. Potentially races with write in method `ZoneawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  420.               throws BKNotEnoughBookiesException {
  421.           int bookieToReplaceIndex = currentEnsemble.indexOf(bookieToReplace);
  422. >         int desiredNumZonesPerWriteQuorumForThisEnsemble = (writeQuorumSize < desiredNumZonesPerWriteQuorum)
  423.                   ? writeQuorumSize : desiredNumZonesPerWriteQuorum;
  424.           List<BookieId> newEnsemble = new ArrayList<BookieId>(currentEnsemble);

#309
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java:202: warning: Thread Safety Violation
  Unprotected write. Non-private method `BenchThroughputLatency.run()` writes to field `this.throughput` outside of synchronization.
 Reporting because this access may occur on a background thread.
  200.               duration = System.currentTimeMillis() - start;
  201.           }
  202. >         throughput = sent * 1000 / getDuration();
  203.   
  204.           reporter.interrupt();

#310
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java:140: warning: Thread Safety Violation
  Unprotected write. Non-private method `BenchThroughputLatency.run()` writes to field `this.previous` outside of synchronization.
 Reporting because this access may occur on a background thread.
  138.       public void run() {
  139.           LOG.info("Running...");
  140. >         long start = previous = System.currentTimeMillis();
  141.   
  142.           int sent = 0;

#311
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java:180: warning: Thread Safety Violation
  Read/Write race. Non-private method `BenchThroughputLatency.run()` reads without synchronization from `this.bytes`. Potentially races with write in method `BenchThroughputLatency.setEntryData(...)`.
 Reporting because this access may occur on a background thread.
  178.               } else {
  179.                   long nanoTime = System.nanoTime();
  180. >                 lh[index].asyncAddEntry(bytes, this, new Context(sent, nanoTime));
  181.                   counter.incrementAndGet();
  182.               }

#312
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java:210: warning: Thread Safety Violation
  Read/Write race. Non-private method `BenchThroughputLatency.run()` reads without synchronization from `this.throughput`. Potentially races with write in method `BenchThroughputLatency.run()`.
 Reporting because this access may occur on a background thread.
  208.               Thread.currentThread().interrupt();
  209.           }
  210. >         LOG.info("Finished processing in ms: " + getDuration() + " tp = " + throughput);
  211.       }
  212.   

#313
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java:77: warning: Thread Safety Violation
  Read/Write race. Non-private method `ReadOnlyLedgerHandle$MetadataUpdater.safeRun()` indirectly reads without synchronization from `this.this$0.versionedMetadata`. Potentially races with write in method `ReadOnlyLedgerHandle$MetadataUpdater.safeRun()`.
 Reporting because this access may occur on a background thread.
  75.           public void safeRun() {
  76.               while (true) {
  77. >                 Versioned<LedgerMetadata> currentMetadata = getVersionedLedgerMetadata();
  78.                   Version.Occurred occurred = currentMetadata.getVersion().compare(newMetadata.getVersion());
  79.                   if (Version.Occurred.BEFORE == occurred) {

#314
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1820: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.sendAddSuccessCallbacks()` reads without synchronization from `this.changingEnsemble`. Potentially races with write in method `LedgerHandle.maybeHandleDelayedWriteBookieFailure()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1818.           PendingAddOp pendingAddOp;
  1819.   
  1820. >         while ((pendingAddOp = pendingAddOps.peek()) != null
  1821.                  && !changingEnsemble) {
  1822.               if (!pendingAddOp.completed) {

#315
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java:114: warning: Thread Safety Violation
  Read/Write race. Non-private method `PacketProcessorBase.sendResponse(...)` reads without synchronization from `this.enqueueNanos`. Potentially races with write in method `PacketProcessorBase.reset()`.
 Reporting because this access may occur on a background thread.
  112.                   requestProcessor.getRequestStats().getChannelWriteStats()
  113.                       .registerFailedEvent(MathUtils.elapsedNanos(writeNanos), TimeUnit.NANOSECONDS);
  114. >                 statsLogger.registerFailedEvent(MathUtils.elapsedNanos(enqueueNanos), TimeUnit.NANOSECONDS);
  115.                   if (response instanceof BookieProtocol.Response) {
  116.                       ((BookieProtocol.Response) response).release();

#316
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java:112: warning: Thread Safety Violation
  Read/Write race. Non-private method `PacketProcessorBase.sendResponse(...)` reads without synchronization from `this.requestProcessor`. Potentially races with write in method `PacketProcessorBase.reset()`.
 Reporting because this access may occur on a background thread.
  110.                   logger.warn("cannot write response to non-writable channel {} for request {}", channel,
  111.                       StringUtils.requestToString(request));
  112. >                 requestProcessor.getRequestStats().getChannelWriteStats()
  113.                       .registerFailedEvent(MathUtils.elapsedNanos(writeNanos), TimeUnit.NANOSECONDS);
  114.                   statsLogger.registerFailedEvent(MathUtils.elapsedNanos(enqueueNanos), TimeUnit.NANOSECONDS);

#317
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java:111: warning: Thread Safety Violation
  Read/Write race. Non-private method `PacketProcessorBase.sendResponse(...)` reads without synchronization from `this.request`. Potentially races with write in method `PacketProcessorBase.reset()`.
 Reporting because this access may occur on a background thread.
  109.               if (!channel.isWritable()) {
  110.                   logger.warn("cannot write response to non-writable channel {} for request {}", channel,
  111. >                     StringUtils.requestToString(request));
  112.                   requestProcessor.getRequestStats().getChannelWriteStats()
  113.                       .registerFailedEvent(MathUtils.elapsedNanos(writeNanos), TimeUnit.NANOSECONDS);

#318
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java:109: warning: Thread Safety Violation
  Read/Write race. Non-private method `PacketProcessorBase.sendResponse(...)` reads without synchronization from `this.channel`. Potentially races with write in method `PacketProcessorBase.reset()`.
 Reporting because this access may occur on a background thread.
  107.               }
  108.   
  109. >             if (!channel.isWritable()) {
  110.                   logger.warn("cannot write response to non-writable channel {} for request {}", channel,
  111.                       StringUtils.requestToString(request));

#319
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:108: warning: Thread Safety Violation
  Read/Write race. Non-private method `RangeRouter.setRanges(...)` reads without synchronization from `this.ranges`. Potentially races with write in method `RangeRouter.setRanges(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  106.           try {
  107.               // we only update the routing only when see new active ranges
  108. >             if ((this.ranges == null)
  109.                   || (ranges.getMaxRangeId() > this.ranges.getMaxRangeId())) {
  110.                   HashStreamRanges oldRanges = this.ranges;

#320
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:111: warning: Thread Safety Violation
  Unprotected write. Non-private method `RangeRouter.setRanges(...)` writes to field `this.ranges` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  109.                   || (ranges.getMaxRangeId() > this.ranges.getMaxRangeId())) {
  110.                   HashStreamRanges oldRanges = this.ranges;
  111. >                 this.ranges = ranges;
  112.                   return oldRanges;
  113.               } else {

#321
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataClientDriver.java:101: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKMetadataClientDriver.setSessionStateListener(...)` reads without synchronization from `this.zk`. Potentially races with write in method `ZKMetadataClientDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
   99.       @Override
  100.       public void setSessionStateListener(SessionStateListener sessionStateListener) {
  101. >         zk.register((event) -> {
  102.               // Check for expired connection.
  103.               if (event.getType().equals(EventType.None) && event.getState().equals(KeeperState.Expired)) {

#322
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java:242: warning: Thread Safety Violation
  Read/Write race. Non-private method `AuditorElector.shutdown()` reads without synchronization from `this.auditor`. Potentially races with write in method `AuditorElector.shutdown()`.
 Reporting because this access may occur on a background thread.
  240.           }
  241.   
  242. >         if (auditor != null) {
  243.               auditor.shutdown();
  244.               auditor = null;

#323
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java:244: warning: Thread Safety Violation
  Unprotected write. Non-private method `AuditorElector.shutdown()` writes to field `this.auditor` outside of synchronization.
 Reporting because this access may occur on a background thread.
  242.           if (auditor != null) {
  243.               auditor.shutdown();
  244. >             auditor = null;
  245.           }
  246.           if (ownBkc) {

#324
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/SingleDirectoryDbLedgerStorage.java:232: warning: Thread Safety Violation
  Read/Write race. Non-private method `SingleDirectoryDbLedgerStorage.shutdown()` indirectly reads without synchronization from `this.lastCheckpoint`. Potentially races with write in method `SingleDirectoryDbLedgerStorage.checkpoint(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  230.       public void shutdown() throws InterruptedException {
  231.           try {
  232. >             flush();
  233.   
  234.               gcThread.shutdown();

#325
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SnapshotMap.java:62: warning: Thread Safety Violation
  Read/Write race. Non-private method `SnapshotMap.snapshot()` reads without synchronization from container `this.updatesToMerge` via call to `Map.entrySet()`. Potentially races with write in method `SnapshotMap.remove(...)`.
 Reporting because this access may occur on a background thread.
  60.           }
  61.           // merging the updates to snapshot
  62. >         for (Map.Entry<K, V> entry : updatesToMerge.entrySet()) {
  63.               snapshot.put(entry.getKey(), entry.getValue());
  64.           }

#326
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java:159: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieServer.start()` indirectly reads without synchronization from `this.bookie.exitCode`. Potentially races with write in method `BookieServer.shutdown()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  157.           // fail fast, when bookie startup is not successful
  158.           if (!this.bookie.isRunning()) {
  159. >             exitCode = bookie.getExitCode();
  160.               this.requestProcessor.close();
  161.               return;

#327
stream/common/src/main/java/org/apache/bookkeeper/common/grpc/proxy/ProxyServerCallHandler.java:45: warning: Interface Not Thread Safe
  Unprotected call to method `ChannelFinder.findChannel(...)` of un-annotated interface `org.apache.bookkeeper.common.grpc.proxy.ChannelFinder`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.ServerCallHandler` is annotated `@ThreadSafe`.
  43.       @Override
  44.       public Listener<ReqT> startCall(ServerCall<ReqT, RespT> serverCall, Metadata headers) {
  45. >         Channel channel = finder.findChannel(serverCall, headers);
  46.           ClientCall<ReqT, RespT> clientCall = channel.newCall(
  47.               serverCall.getMethodDescriptor(), callOptions);

#328
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:145: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.toOpStatData()` reads without synchronization from `this.latencyBuckets.[_]`. Potentially races with write in method `BKStats$OpStats.updateLatency(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  143.               StringBuilder sb = new StringBuilder();
  144.               for (int i = 0; i < NUM_BUCKETS; i++) {
  145. >                 sb.append(latencyBuckets[i]);
  146.                   if (i != NUM_BUCKETS - 1) {
  147.                       sb.append(',');

#329
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:142: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.toOpStatData()` reads without synchronization from `this.numSuccessOps`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  140.   
  141.           public OpStatData toOpStatData() {
  142. >             double avgLatency = numSuccessOps > 0 ? totalLatency / numSuccessOps : 0.0f;
  143.               StringBuilder sb = new StringBuilder();
  144.               for (int i = 0; i < NUM_BUCKETS; i++) {

#330
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:151: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.toOpStatData()` reads without synchronization from `this.maxLatency`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  149.               }
  150.   
  151. >             return new OpStatData(maxLatency, minLatency, avgLatency, numSuccessOps, numFailedOps, sb.toString());
  152.           }
  153.   

#331
stream/distributedlog/core/src/main/java/org/apache/distributedlog/EntryPosition.java:60: warning: Thread Safety Violation
  Read/Write race. Non-private method `EntryPosition.toString()` reads without synchronization from `this.entryId`. Potentially races with write in method `EntryPosition.advance(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  58.       public String toString() {
  59.           StringBuilder sb = new StringBuilder();
  60. >         sb.append("(").append(lssn).append(", ").append(entryId).append(")");
  61.           return sb.toString();
  62.       }

#332
bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java:90: warning: Thread Safety Violation
  Read/Write race. Non-private method `InMemoryMetastoreTable$MetadataVersion.toString()` reads without synchronization from `this.version`. Potentially races with write in method `InMemoryMetastoreTable$MetadataVersion.incrementVersion()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  88.           @Override
  89.           public String toString() {
  90. >             return "version=" + version;
  91.           }
  92.   

#333
bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopologyImpl.java:833: warning: Thread Safety Violation
  Read/Write race. Non-private method `NetworkTopologyImpl.toString()` reads without synchronization from `this.numOfRacks`. Potentially races with write in method `NetworkTopologyImpl.remove(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  831.           StringBuilder tree = new StringBuilder();
  832.           tree.append("Number of racks: ");
  833. >         tree.append(numOfRacks);
  834.           tree.append("\n");
  835.           // print the number of leaves

#334
bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopologyImpl.java:842: warning: Thread Safety Violation
  Read/Write race. Non-private method `NetworkTopologyImpl.toString()` indirectly reads without synchronization from container `this.clusterMap.children` via call to `List.isEmpty()`. Potentially races with write in method `NetworkTopologyImpl.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  840.           // print nodes
  841.           for (int i = 0; i < numOfLeaves; i++) {
  842. >             tree.append(NodeBase.getPath(clusterMap.getLeaf(i, null)));
  843.               tree.append("\n");
  844.           }

#335
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java:412: warning: Thread Safety Violation
  Read/Write race. Non-private method `RoundRobinDistributionSchedule$RRQuorumCoverageSet.toString()` reads without synchronization from `this.covered.[_]`. Potentially races with write in method `RoundRobinDistributionSchedule$RRQuorumCoverageSet.addBookie(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  410.                   buffer.append(covered[i]).append(", ");
  411.               }
  412. >             buffer.append(covered[i]).append("]");
  413.               return buffer.toString();
  414.           }

#336
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1493: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.tryReadLastAddConfirmedAsync()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1491.       public CompletableFuture<Long> tryReadLastAddConfirmedAsync() {
  1492.           FutureReadLastConfirmed result = new FutureReadLastConfirmed();
  1493. >         asyncTryReadLastConfirmed(result, null);
  1494.           return result;
  1495.       }

#337
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1678: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.tryReadLastConfirmed()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1676.       public long tryReadLastConfirmed() throws InterruptedException, BKException {
  1677.           LastConfirmedCtx ctx = new LastConfirmedCtx();
  1678. >         asyncTryReadLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);
  1679.           synchronized (ctx) {
  1680.               while (!ctx.ready()) {

#338
bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:578: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.update(...)` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  576.       @Override
  577.       public void update(long duration, TimeUnit unit) {
  578. >         update(unit.toNanos(duration));
  579.       }
  580.   

#339
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/SingleDirectoryDbLedgerStorage.java:756: warning: Thread Safety Violation
  Read/Write race. Non-private method `SingleDirectoryDbLedgerStorage.updateEntriesLocations(...)` indirectly reads without synchronization from `this.lastCheckpoint`. Potentially races with write in method `SingleDirectoryDbLedgerStorage.checkpoint(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  754.       public void updateEntriesLocations(Iterable<EntryLocation> locations) throws IOException {
  755.           // Trigger a flush to have all the entries being compacted in the db storage
  756. >         flush();
  757.   
  758.           entryLocationIndex.updateLocations(locations);

#340
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:242: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.updateLastRevision(...)` reads without synchronization from `this.metaCfHandle`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  240.                   // update revision
  241.                   setLastRevision(revision);
  242. >                 batch.put(metaCfHandle, LAST_REVISION, lastRevisionBytes);
  243.               } catch (RocksDBException e) {
  244.                   throw new StateStoreRuntimeException(

#341
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:241: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.updateLastRevision(...)` indirectly writes to field `this.lastRevisionBytes.[_]` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  239.               try {
  240.                   // update revision
  241. >                 setLastRevision(revision);
  242.                   batch.put(metaCfHandle, LAST_REVISION, lastRevisionBytes);
  243.               } catch (RocksDBException e) {

#342
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/WeightedRandomSelectionImpl.java:102: warning: Thread Safety Violation
  Read/Write race. Non-private method `WeightedRandomSelectionImpl.updateMap(...)` reads without synchronization from `this.maxProbabilityMultiplier`. Potentially races with write in method `WeightedRandomSelectionImpl.setMaxProbabilityMultiplier(...)`.
 Reporting because this access may occur on a background thread.
  100.           }
  101.   
  102. >         double maxWeight = maxProbabilityMultiplier * medianWeight;
  103.           Map<T, Double> weightMap = new HashMap<T, Double>();
  104.           for (Map.Entry<T, WeightedObject> e : map.entrySet()) {

#343
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1256: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.waitForWritable(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1254.   
  1255.           final long startTime = MathUtils.nowInNano();
  1256. >         boolean writableResult = isWriteSetWritable(writeSet, allowedNonWritableCount);
  1257.   
  1258.           if (!writableResult && durationMs > 0) {

#344
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java:91: error: Arbitrary Code Execution Under lock
  Method `SettableFuture LedgerDescriptorImpl.fenceAndLogInJournal(Journal)` calls `boolean SettableFuture.set(Object)` under a lock; executed code may acquire arbitrary locks leading to potential deadlock.
  89.   
  90.       @Override
  91. >     synchronized SettableFuture<Boolean> fenceAndLogInJournal(Journal journal) throws IOException {
  92.           boolean success = this.setFenced();
  93.           if (success) {

Found 345 issues
                                                Issue Type(ISSUED_TYPE_ID): #
                          Thread Safety Violation(THREAD_SAFETY_VIOLATION): 210
                                        Null Dereference(NULL_DEREFERENCE): 90
                                              Resource Leak(RESOURCE_LEAK): 30
                      Interface Not Thread Safe(INTERFACE_NOT_THREAD_SAFE): 14
  Arbitrary Code Execution Under lock(ARBITRARY_CODE_EXECUTION_UNDER_LOCK): 1
