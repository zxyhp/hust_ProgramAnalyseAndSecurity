#0
tools/framework/src/main/java/org/apache/bookkeeper/tools/framework/CliCommandGroup.java:47: error: Null Dereference
  object returned by `newSpec.commands()` could be null and is dereferenced at line 47.
  45.           String path = newSpec.parent() + " " + newSpec.name();
  46.   
  47. >         for (Command<GlobalFlagsT> cmd : newSpec.commands()) {
  48.               if (cmd instanceof CliCommand) {
  49.                   CliCommand<GlobalFlagsT, GlobalFlagsT> cliCmd = (CliCommand<GlobalFlagsT, GlobalFlagsT>) cmd;

#1
circe-checksum/src/main/java/com/scurrilous/circe/utils/NativeUtils.java:36: error: Null Dereference
  object returned by `getProperty("os.name")` could be null and is dereferenced at line 36.
  34.   public class NativeUtils {
  35.   
  36. >     public static final String OS_NAME = System.getProperty("os.name").toLowerCase(Locale.US);
  37.   
  38.       /**

#2
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Shell.java:51: error: Null Dereference
  object returned by `getProperty("os.name")` could be null and is dereferenced at line 51.
  49.        */
  50.       public static final boolean WINDOWS = /* borrowed from Path.WINDOWS */
  51. >             System.getProperty("os.name").startsWith("Windows");
  52.   
  53.       private long interval; // refresh interval in msec

#3
stream/distributedlog/core/src/main/java/org/apache/distributedlog/feature/AbstractFeatureProvider.java:54: error: Null Dereference
  object `featureProviderClass` last assigned on line 47 could be null and is dereferenced at line 54.
  52.           Constructor<? extends FeatureProvider> constructor;
  53.           try {
  54. >             constructor = featureProviderClass.getDeclaredConstructor(
  55.                       String.class,
  56.                       DistributedLogConfiguration.class,

#4
native-io/src/main/java/org/apache/bookkeeper/common/util/nativeio/NativeUtils.java:63: error: Resource Leak
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 64 is not released after line 63.
**Note**: potential exception at line 69
  61.           int read;
  62.   
  63. >         try (InputStream input = NativeUtils.class.getResourceAsStream(path);
  64.                OutputStream out = new FileOutputStream(temp)) {
  65.               if (input == null) {

#5
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/KVCommandProcessor.java:57: error: Null Dereference
  object returned by `command.getReqCase()` could be null and is dereferenced at line 57.
  55.           }
  56.   
  57. >         switch (command.getReqCase()) {
  58.               case NOP_REQ:
  59.                   break;

#6
cpu-affinity/src/main/java/org/apache/bookkeeper/common/util/affinity/impl/NativeUtils.java:65: error: Resource Leak
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 66 is not released after line 65.
**Note**: potential exception at line 71
  63.           int read;
  64.   
  65. >         try (InputStream input = NativeUtils.class.getResourceAsStream(path);
  66.                   OutputStream out = new FileOutputStream(temp)) {
  67.               if (input == null) {

#7
cpu-affinity/src/main/java/org/apache/bookkeeper/common/util/affinity/impl/IsolatedProcessors.java:54: error: Null Dereference
  object returned by `trim(range)` could be null and is dereferenced at line 54.
  52.           SortedSet<Integer> processors = new TreeSet<>();
  53.   
  54. >         for (String part : StringUtils.trim(range).split(",")) {
  55.               if (part.contains("-")) {
  56.                   // This is a range, eg: 1-5 with both edges included

#8
bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/cli/commands/autorecovery/TriggerAuditCommand.java:59: error: Null Dereference
  object `admin.mFactory` last assigned on line 56 could be null and is dereferenced by call to `triggerAudit()` at line 59.
  57.   
  58.           try {
  59. >             admin.triggerAudit();
  60.           } finally {
  61.               if (admin != null) {

#9
cpu-affinity/src/main/java/org/apache/bookkeeper/common/util/affinity/impl/ProcessorsInfo.java:71: error: Null Dereference
  object `key` last assigned on line 68 could be null and is dereferenced at line 71.
  69.                   String value = StringUtils.trim(parts[1]);
  70.   
  71. >                 if (key.equals("core id")) {
  72.                       coreId = Integer.parseInt(value);
  73.                   } else if (key.equals("processor")) {

#10
bookkeeper-server/src/main/java/org/apache/bookkeeper/sasl/SASLClientProviderFactory.java:67: error: Null Dereference
  object `SASLClientProviderFactory.login` last assigned on line 66 could be null and is dereferenced at line 67.
  65.   
  66.               this.login = loginClient();
  67. >             this.subject = login.getSubject();
  68.               this.isKrbTicket = !subject.getPrivateCredentials(KerberosTicket.class).isEmpty();
  69.               boolean systemRole = CLIENT_ROLE_SYSTEM.equals(clientConfiguration.getClientRole());

#11
bookkeeper-server/src/main/java/org/apache/bookkeeper/sasl/SASLBookieAuthProviderFactory.java:83: error: Null Dereference
  object `SASLBookieAuthProviderFactory.login` last assigned on line 82 could be null and is dereferenced at line 83.
  81.   
  82.               this.login = loginServer();
  83. >             this.subject = login.getSubject();
  84.               this.isKrbTicket = !subject.getPrivateCredentials(KerberosTicket.class).isEmpty();
  85.               if (isKrbTicket) {

#12
bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/cli/commands/autorecovery/WhoIsAuditorCommand.java:80: error: Null Dereference
  object `bka.mFactory` last assigned on line 79 could be null and is dereferenced by call to `getCurrentAuditor()` at line 80.
  78.               @Cleanup
  79.               BookKeeperAdmin bka = new BookKeeperAdmin(clientConfiguration);
  80. >             bookieId = bka.getCurrentAuditor();
  81.           }
  82.           if (bookieId == null) {

#13
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/utils/NetUtils.java:79: error: Null Dereference
  object `endpointParts` last assigned on line 78 could be null and is dereferenced at line 79.
  77.       public static List<Endpoint> parseEndpoints(String endpointStr) {
  78.           String[] endpointParts = StringUtils.split(endpointStr, ',');
  79. >         checkArgument(endpointParts.length > 0,
  80.               "Invalid endpoint strings %s", endpointStr);
  81.           List<Endpoint> endpoints = Lists.newArrayListWithExpectedSize(endpointParts.length);

#14
tools/ledger/src/main/java/org/apache/bookkeeper/tools/cli/commands/bookieid/SearchReplaceBookieIdCommand.java:81: error: Resource Leak
  resource of type `org.apache.bookkeeper.client.BookKeeperAdmin` acquired to `admin` by call to `new()` at line 81 is not released after line 81.
**Note**: potential exception at line 85
  79.       @Override
  80.       protected void run(BookKeeper bk, Flags flags) throws Exception {
  81. >         try (BookKeeperAdmin admin = new BookKeeperAdmin((org.apache.bookkeeper.client.BookKeeper) bk)) {
  82.               LedgerManager ledgerManager = ((org.apache.bookkeeper.client.BookKeeper) bk).getLedgerManager();
  83.               long i = 0;

#15
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdUtils.java:84: error: Null Dereference
  object `keyParts` last assigned on line 83 could be null and is dereferenced at line 84.
  82.       static UUID parseLedgerKey(String ledgerKey) {
  83.           String[] keyParts = StringUtils.split(ledgerKey, '/');
  84. >         return UUID.fromString(keyParts[keyParts.length - 1]);
  85.       }
  86.   

#16
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BookKeeperClient.java:111: error: Null Dereference
  object `dnsResolverCls` last assigned on line 105 could be null and is dereferenced by call to `getDNSResolver(...)` at line 111.
  109.           }
  110.           final DNSToSwitchMapping dnsResolver =
  111. >                 NetUtils.getDNSResolver(dnsResolverCls, conf.getBkDNSResolverOverrides());
  112.   
  113.           try {

#17
bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/cli/commands/autorecovery/LostBookieRecoveryDelayCommand.java:104: error: Null Dereference
  object `admin.mFactory` last assigned on line 101 could be null and is dereferenced by call to `getLostBookieRecoveryDelay()` at line 104.
  102.           try {
  103.               if (getter) {
  104. >                 int lostBookieRecoveryDelay = admin.getLostBookieRecoveryDelay();
  105.                   LOG.info("LostBookieRecoveryDelay value in ZK: {}", lostBookieRecoveryDelay);
  106.               } else {

#18
bookkeeper-server/src/main/java/org/apache/bookkeeper/tools/cli/commands/autorecovery/LostBookieRecoveryDelayCommand.java:108: error: Null Dereference
  object `admin.mFactory` last assigned on line 101 could be null and is dereferenced by call to `setLostBookieRecoveryDelay(...)` at line 108.
  106.               } else {
  107.                   int lostBookieRecoveryDelay = flags.set;
  108. >                 admin.setLostBookieRecoveryDelay(lostBookieRecoveryDelay);
  109.                   LOG.info("Successfully set LostBookieRecoveryDelay value in ZK: {}",
  110.                           lostBookieRecoveryDelay);

#19
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/HardLink.java:89: error: Null Dereference
  object `osName` last assigned on line 88 could be null and is dereferenced at line 89.
  87.     private static OSType getOSType() {
  88.       String osName = System.getProperty("os.name");
  89. >     if (osName.contains("Windows") && (osName.contains("XP")
  90.               || osName.contains("2003")
  91.               || osName.contains("Vista")

#20
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java:96: error: Null Dereference
  object `metadataClientDriver` last assigned on line 95 could be null and is dereferenced at line 96.
  94.           this.bkc = Auditor.createBookKeeperClient(conf, statsLogger.scope(BookKeeperClientStats.CLIENT_SCOPE));
  95.           MetadataClientDriver metadataClientDriver = bkc.getMetadataClientDriver();
  96. >         metadataClientDriver.setSessionStateListener(() -> {
  97.               LOG.error("Client connection to the Metadata server has expired, so shutting down AutoRecoveryMain!");
  98.               // do not run "shutdown" in the main ZooKeeper client thread

#21
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/utils/NetUtils.java:96: error: Null Dereference
  object `endpointParts` last assigned on line 95 could be null and is dereferenced at line 96.
  94.       public static Endpoint parseEndpoint(String endpointStr) {
  95.           String[] endpointParts = StringUtils.split(endpointStr, ':');
  96. >         checkArgument(2 == endpointParts.length,
  97.               "Invalid endpoint string %s - It should be 'host:port'.", endpointStr);
  98.           String host = endpointParts[0];

#22
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataDriverBase.java:102: error: Null Dereference
  object `schemeParts` last assigned on line 101 could be null and is dereferenced at line 102.
  100.           checkNotNull(scheme, "Invalid metadata service : " + metadataServiceUri);
  101.           String[] schemeParts = StringUtils.split(scheme.toLowerCase(), '+');
  102. >         checkArgument(SCHEME.equals(schemeParts[0]), "Unknown metadata service scheme found : "
  103.               + schemeParts[0]);
  104.           Class<? extends LedgerManagerFactory> ledgerManagerFactoryClass;

#23
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/http/service/ClusterInfoService.java:103: error: Null Dereference
  object returned by `ClusterInfoService.bka.getAllBookies()` could be null and is dereferenced at line 103.
  101.       @SneakyThrows
  102.       private void fillBookiesInfo(ClusterInfo info) {
  103. >         int totalBookiesCount = bka.getAllBookies().size();
  104.           int writableBookiesCount = bka.getAvailableBookies().size();
  105.           int readonlyBookiesCount = bka.getReadOnlyBookies().size();

#24
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/http/service/ClusterInfoService.java:104: error: Null Dereference
  object returned by `ClusterInfoService.bka.getAvailableBookies()` could be null and is dereferenced at line 104.
  102.       private void fillBookiesInfo(ClusterInfo info) {
  103.           int totalBookiesCount = bka.getAllBookies().size();
  104. >         int writableBookiesCount = bka.getAvailableBookies().size();
  105.           int readonlyBookiesCount = bka.getReadOnlyBookies().size();
  106.           int unavailableBookiesCount = totalBookiesCount - writableBookiesCount - readonlyBookiesCount;

#25
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/http/service/ClusterInfoService.java:105: error: Null Dereference
  object returned by `ClusterInfoService.bka.getReadOnlyBookies()` could be null and is dereferenced at line 105.
  103.           int totalBookiesCount = bka.getAllBookies().size();
  104.           int writableBookiesCount = bka.getAvailableBookies().size();
  105. >         int readonlyBookiesCount = bka.getReadOnlyBookies().size();
  106.           int unavailableBookiesCount = totalBookiesCount - writableBookiesCount - readonlyBookiesCount;
  107.   

#26
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorTask.java:113: error: Null Dereference
  object `availableBkAddresses` last assigned on line 111 could be null and is dereferenced at line 113.
  111.           Collection<BookieId> availableBkAddresses = admin.getAvailableBookies();
  112.           Collection<BookieId> readOnlyBkAddresses = admin.getReadOnlyBookies();
  113. >         availableBkAddresses.addAll(readOnlyBkAddresses);
  114.   
  115.           List<String> availableBookies = new ArrayList<String>();

#27
stream/common/src/main/java/org/apache/bookkeeper/common/grpc/stats/ClientStats.java:115: error: Null Dereference
  object `serviceName` last assigned on line 114 could be null and is dereferenced at line 115.
  113.               String fullMethodName = methodDescriptor.getFullMethodName();
  114.               String serviceName = MethodDescriptor.extractFullServiceName(fullMethodName);
  115. >             String methodName = fullMethodName.substring(serviceName.length() + 1);
  116.   
  117.               MethodType type = methodDescriptor.getType();

#28
stream/common/src/main/java/org/apache/bookkeeper/common/grpc/stats/ServerStats.java:115: error: Null Dereference
  object `serviceName` last assigned on line 114 could be null and is dereferenced at line 115.
  113.               String fullMethodName = methodDescriptor.getFullMethodName();
  114.               String serviceName = MethodDescriptor.extractFullServiceName(fullMethodName);
  115. >             String methodName = fullMethodName.substring(serviceName.length() + 1);
  116.   
  117.               MethodType type = methodDescriptor.getType();

#29
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/subscription/ZKSubscriptionsStore.java:118: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `getLastCommitPositionFromZK()` at line 118 is not released after line 118.
  116.               CompletableFuture<Pair<String, DLSN>> future =
  117.                   // Get the last commit position from zookeeper
  118. >                 getSubscriber(subscriber).getLastCommitPositionFromZK().thenApply(
  119.                       dlsn -> Pair.of(subscriber, dlsn));
  120.               futures.add(future);

#30
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java:117: error: Null Dereference
  object returned by `PacketProcessorBaseV3.request.getHeader().getVersion()` could be null and is dereferenced at line 117.
  115.   
  116.       protected boolean isVersionCompatible() {
  117. >         return this.request.getHeader().getVersion().equals(ProtocolVersion.VERSION_THREE);
  118.       }
  119.   

#31
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java:122: error: Resource Leak
  resource of type `org.apache.bookkeeper.client.BookKeeper` acquired by call to `createBookKeeperClientThrowUnavailableException(...)` at line 125 is not released after line 122.
  120.                      StatsLogger statsLogger)
  121.               throws UnavailableException {
  122. >         this(
  123.                   bookieIdentifier,
  124.                   conf,

#32
stream/clients/java/all/src/main/java/org/apache/bookkeeper/clients/StorageClientImpl.java:138: error: Resource Leak
  resource of type `org.apache.bookkeeper.clients.impl.kv.PByteBufTableImpl` acquired by call to `PByteBufTableImpl(...)` at line 137 is not released after line 138.
  136.                       scheduler.chooseThread(props.getStreamId()),
  137.                       settings.backoffPolicy()
  138. >                 ).initialize();
  139.               }),
  140.               future

#33
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java:132: error: Null Dereference
  object `bk` last assigned on line 128 could be null and is dereferenced at line 132.
  130.               return FutureUtils.exception(e);
  131.           }
  132. >         bk.asyncDeleteLedger(segment.getLogSegmentId(), this, request);
  133.           return request.deletePromise;
  134.       }

#34
tests/integration-tests-utils/src/main/java/org/apache/bookkeeper/tests/integration/utils/DockerUtils.java:133: error: Resource Leak
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 139 is not released after line 133.
**Note**: potential exception at line 143
  131.           final int readBlockSize = 10000;
  132.   
  133. >         try (InputStream dockerStream = docker.copyArchiveFromContainerCmd(containerId, path).exec();
  134.                TarArchiveInputStream stream = new TarArchiveInputStream(dockerStream)) {
  135.               TarArchiveEntry entry = stream.getNextTarEntry();

#35
tests/integration-tests-utils/src/main/java/org/apache/bookkeeper/tests/integration/utils/DockerUtils.java:150: error: Resource Leak
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 139 is not released after line 150.
**Note**: potential exception at line 143
  148.                   entry = stream.getNextTarEntry();
  149.               }
  150. >         } catch (RuntimeException | IOException e) {
  151.               LOG.error("Error reading bk logs from container {}", containerId, e);
  152.           }

#36
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCCommandProcessor.java:144: error: Null Dereference
  object returned by `command.getReqCase()` could be null and is dereferenced at line 144.
  142.       public void applyCommand(long txid, ByteBuf cmdBuf, MVCCStoreImpl<byte[], byte[]> store) {
  143.           Command command = MVCCUtils.newCommand(cmdBuf);
  144. >         switch (command.getReqCase()) {
  145.               case NOP_REQ:
  146.                   return;

#37
stream/distributedlog/core/src/main/java/org/apache/bookkeeper/client/LedgerReader.java:150: error: Null Dereference
  object returned by `future(op)` could be null and is dereferenced at line 150.
  148.               private void readNext(long entryId) {
  149.                   PendingReadOp op = new PendingReadOp(lh, clientCtx, entryId, entryId, false);
  150. >                 op.future().whenComplete(this);
  151.                   op.submit();
  152.               }

#38
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCUtils.java:151: error: Null Dereference
  object returned by `protoOp.getRequestCase()` could be null and is dereferenced at line 151.
  149.   
  150.       public static Op<byte[], byte[]> toApiOp(RequestOp protoOp) {
  151. >         switch (protoOp.getRequestCase()) {
  152.               case REQUEST_PUT:
  153.                   return ProtoPutOpImpl.newPutOp(protoOp.getRequestPut());

#39
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerMetadataSerDe.java:187: error: Null Dereference
  object returned by `metadata.getDigestType()` could be null and is dereferenced by call to `apiToProtoDigestType(...)` at line 187.
  185.   
  186.   
  187. >             builder.setDigestType(apiToProtoDigestType(metadata.getDigestType()));
  188.   
  189.               serializePassword(metadata.getPassword(), builder);

#40
stream/distributedlog/core/src/main/java/org/apache/distributedlog/namespace/NamespaceDriverManager.java:168: error: Null Dereference
  object `schemeParts` last assigned on line 167 could be null and is dereferenced at line 168.
  166.           scheme = scheme.toLowerCase();
  167.           String[] schemeParts = StringUtils.split(scheme, '-');
  168. >         checkArgument(schemeParts.length > 0,
  169.                   "Invalid distributedlog scheme found : " + uri);
  170.           checkArgument(Objects.equal(DistributedLogConstants.SCHEME_PREFIX, schemeParts[0].toLowerCase()),

#41
stream/distributedlog/core/src/main/java/org/apache/distributedlog/auditor/DLAuditor.java:172: error: Null Dereference
  object returned by `bkc.get()` could be null and is dereferenced by call to `getLedgerManager(...)` at line 172.
  170.                                              final ExecutorService executorService)
  171.               throws IOException {
  172. >         LedgerManager lm = BookKeeperAccessor.getLedgerManager(bkc.get());
  173.   
  174.           final Set<Long> ledgers = new HashSet<Long>();

#42
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RegionAwareEnsemblePlacementPolicy.java:180: error: Null Dereference
  object returned by `newNode.getNetworkLocation()` could be null and is dereferenced at line 180.
  178.                           // refresh the rack info if its a known bookie
  179.                           BookieNode newNode = createBookieNode(bookieAddress);
  180. >                         if (!newNode.getNetworkLocation().equals(node.getNetworkLocation())) {
  181.                               topology.remove(node);
  182.                               topology.add(newNode);

#43
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/storage/GetStreamRequest.java:193: error: Null Dereference
  object returned by `getIdCase()` could be null and is dereferenced at line 193.
  191.       org.apache.bookkeeper.stream.proto.storage.GetStreamRequest other = (org.apache.bookkeeper.stream.proto.storage.GetStreamRequest) obj;
  192.   
  193. >     if (!getIdCase().equals(other.getIdCase())) return false;
  194.       switch (idCase_) {
  195.         case 1:

#44
stream/distributedlog/core/src/main/java/org/apache/bookkeeper/client/LedgerReader.java:200: error: Null Dereference
  object returned by `future(op)` could be null and is dereferenced at line 200.
  198.               long entryId = recoveryData.getLastAddConfirmed();
  199.               PendingReadOp op = new PendingReadOp(lh, clientCtx, entryId, entryId, false);
  200. >             op.future().whenComplete(readListener);
  201.               op.submit();
  202.           };

#45
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java:210: error: Null Dereference
  object `bk` last assigned on line 204 could be null and is dereferenced at line 210.
  208.           OpenReaderRequest request = new OpenReaderRequest(segment, startEntryId);
  209.           if (segment.isInProgress()) {
  210. >             bk.asyncOpenLedgerNoRecovery(
  211.                       segment.getLogSegmentId(),
  212.                       BookKeeper.DigestType.CRC32,

#46
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java:217: error: Null Dereference
  object `bk` last assigned on line 204 could be null and is dereferenced at line 217.
  215.                       request);
  216.           } else {
  217. >             bk.asyncOpenLedger(
  218.                       segment.getLogSegmentId(),
  219.                       BookKeeper.DigestType.CRC32,

#47
stream/server/src/main/java/org/apache/bookkeeper/stream/server/StorageServer.java:303: error: Resource Leak
  resource of type `org.apache.bookkeeper.stream.server.service.CuratorProviderService` acquired by call to `CuratorProviderService(...)` at line 303 is not released after line 303.
**Note**: potential exception at line 303
  301.           // Create the curator provider service
  302.           CuratorProviderService curatorProviderService = new CuratorProviderService(
  303. >             bkServerConf, dlConf, rootStatsLogger.scope("curator"));
  304.   
  305.           // Create the distributedlog namespace service

#48
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/SplitPolicy.java:229: error: Null Dereference
  object returned by `getPolicyCase()` could be null and is dereferenced at line 229.
  227.   
  228.       if (type_ != other.type_) return false;
  229. >     if (!getPolicyCase().equals(other.getPolicyCase())) return false;
  230.       switch (policyCase_) {
  231.         case 2:

#49
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java:248: error: Resource Leak
  resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 236 is not released after line 248.
**Note**: potential exception at line 237
  246.                           curMark.setLogMark(mark.getLogFileId(), mark.getLogFileOffset());
  247.                       }
  248. >                 } catch (IOException e) {
  249.                       LOG.error("Problems reading from " + file + " (this is okay if it is the first time starting this "
  250.                               + "bookie");

#50
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BookKeeperClient.java:239: error: Null Dereference
  object `bk` last assigned on line 234 could be null and is dereferenced at line 239.
  237.           }
  238.           final CompletableFuture<Void> promise = new CompletableFuture<Void>();
  239. >         bk.asyncDeleteLedger(lid, new AsyncCallback.DeleteCallback() {
  240.               @Override
  241.               public void deleteComplete(int rc, Object ctx) {

#51
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/RequestOp.java:241: error: Null Dereference
  object returned by `getRequestCase()` could be null and is dereferenced at line 241.
  239.       org.apache.bookkeeper.stream.proto.kv.rpc.RequestOp other = (org.apache.bookkeeper.stream.proto.kv.rpc.RequestOp) obj;
  240.   
  241. >     if (!getRequestCase().equals(other.getRequestCase())) return false;
  242.       switch (requestCase_) {
  243.         case 1:

#52
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/ResponseOp.java:241: error: Null Dereference
  object returned by `getResponseCase()` could be null and is dereferenced at line 241.
  239.       org.apache.bookkeeper.stream.proto.kv.rpc.ResponseOp other = (org.apache.bookkeeper.stream.proto.kv.rpc.ResponseOp) obj;
  240.   
  241. >     if (!getResponseCase().equals(other.getResponseCase())) return false;
  242.       switch (responseCase_) {
  243.         case 1:

#53
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java:282: error: Null Dereference
  object `bk` last assigned on line 259 could be null and is dereferenced at line 282.
  280.           };
  281.           if (segment.isInProgress() && !fence) {
  282. >             bk.asyncOpenLedgerNoRecovery(
  283.                       segment.getLogSegmentId(),
  284.                       BookKeeper.DigestType.CRC32,

#54
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java:289: error: Null Dereference
  object `bk` last assigned on line 259 could be null and is dereferenced at line 289.
  287.                       null);
  288.           } else {
  289. >             bk.asyncOpenLedger(
  290.                       segment.getLogSegmentId(),
  291.                       BookKeeper.DigestType.CRC32,

#55
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MetadataDrivers.java:265: error: Null Dereference
  object `schemeParts` last assigned on line 264 could be null and is dereferenced at line 265.
  263.           scheme = scheme.toLowerCase();
  264.           String[] schemeParts = StringUtils.split(scheme, '+');
  265. >         checkArgument(schemeParts.length > 0,
  266.                   "Invalid metadata service scheme found : " + uri);
  267.           return getClientDriver(schemeParts[0]);

#56
tests/integration-tests-utils/src/main/java/org/apache/bookkeeper/tests/integration/utils/MavenClassLoader.java:267: error: Resource Leak
  resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 267 is not released after line 267.
  265.   
  266.       private static File deCompressGZipFile(File gZippedFile, File tarFile) throws IOException {
  267. >         try (GZIPInputStream gZIPInputStream = new GZIPInputStream(new FileInputStream(gZippedFile));
  268.                FileOutputStream fos = new FileOutputStream(tarFile)) {
  269.               byte[] buffer = new byte[1024];

#57
tests/integration-tests-utils/src/main/java/org/apache/bookkeeper/tests/integration/utils/MavenClassLoader.java:267: error: Resource Leak
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 268 is not released after line 267.
**Note**: potential exception at line 272
  265.   
  266.       private static File deCompressGZipFile(File gZippedFile, File tarFile) throws IOException {
  267. >         try (GZIPInputStream gZIPInputStream = new GZIPInputStream(new FileInputStream(gZippedFile));
  268.                FileOutputStream fos = new FileOutputStream(tarFile)) {
  269.               byte[] buffer = new byte[1024];

#58
tests/integration-tests-utils/src/main/java/org/apache/bookkeeper/tests/integration/utils/MavenClassLoader.java:267: error: Resource Leak
  resource of type `java.util.zip.GZIPInputStream` acquired to `gZIPInputStream` by call to `GZIPInputStream(...)` at line 267 is not released after line 267.
**Note**: potential exception at line 268
  265.   
  266.       private static File deCompressGZipFile(File gZippedFile, File tarFile) throws IOException {
  267. >         try (GZIPInputStream gZIPInputStream = new GZIPInputStream(new FileInputStream(gZippedFile));
  268.                FileOutputStream fos = new FileOutputStream(tarFile)) {
  269.               byte[] buffer = new byte[1024];

#59
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:275: error: Null Dereference
  object `parts` last assigned on line 274 could be null and is dereferenced at line 275.
  273.   
  274.           String[] parts = StringUtils.split(NodeBase.normalize(defaultFaultDomain), NodeBase.PATH_SEPARATOR);
  275. >         if (parts.length != 2) {
  276.               LOG.error("provided defaultFaultDomain: {} is not valid", defaultFaultDomain);
  277.               throw new IllegalArgumentException("invalid defaultFaultDomain");

#60
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/EmbeddedServer.java:323: error: Resource Leak
  resource of type `org.apache.bookkeeper.common.component.AutoCloseableLifecycleComponent` acquired by call to `new()` at line 323 is not released after line 323.
  321.               }
  322.               LedgerManager ledgerManager = ledgerManagerFactory.newLedgerManager();
  323. >             serverBuilder.addComponent(new AutoCloseableLifecycleComponent("ledgerManager", ledgerManager));
  324.   
  325.               // 4. Build bookie

#61
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/EmbeddedServer.java:371: error: Resource Leak
  resource of type `org.apache.bookkeeper.common.component.AutoCloseableLifecycleComponent` acquired by call to `new()` at line 371 is not released after line 371.
  369.                   clientConfiguration.setClientRole(ClientConfiguration.CLIENT_ROLE_SYSTEM);
  370.                   BookKeeper bkc = BookKeeper.forConfig(clientConfiguration).statsLogger(clientStats).build();
  371. >                 serverBuilder.addComponent(new AutoCloseableLifecycleComponent("bkc", bkc));
  372.   
  373.                   BookieId bookieId = BookieImpl.getBookieId(conf.getServerConf());

#62
bookkeeper-server/src/main/java/org/apache/bookkeeper/server/EmbeddedServer.java:380: error: Resource Leak
  resource of type `org.apache.bookkeeper.common.component.RxSchedulerLifecycleComponent` acquired by call to `RxSchedulerLifecycleComponent(...)` at line 380 is not released after line 380.
  378.                                   .build());
  379.                   Scheduler rxScheduler = Schedulers.from(rxExecutor);
  380. >                 serverBuilder.addComponent(
  381.                           new RxSchedulerLifecycleComponent("rx-scheduler", conf, bookieStats,
  382.                                   rxScheduler, rxExecutor));

#63
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/KvUtils.java:282: error: Null Dereference
  object returned by `op.getResponseCase()` could be null and is dereferenced at line 282.
  280.           result.isSuccess(txnResponse.getSucceeded());
  281.           result.results(Lists.transform(txnResponse.getResponsesList(), op -> {
  282. >             switch (op.getResponseCase()) {
  283.                   case RESPONSE_PUT:
  284.                       return newPutResult(

#64
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java:313: error: Resource Leak
  resource of type `org.apache.bookkeeper.util.LocalBookKeeper` acquired by call to `new()` at line 305 is not released after line 313.
  311.                   if (zkDataDirFile.exists() && zkDataDirFile.isFile()) {
  312.                       throw new IOException("Unable to create zkDataDir, since there is a file at "
  313. >                             + zkDataDirFile.getAbsolutePath());
  314.                   }
  315.                   if (!zkDataDirFile.exists() && !zkDataDirFile.mkdirs()) {

#65
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java:316: error: Resource Leak
  resource of type `org.apache.bookkeeper.util.LocalBookKeeper` acquired by call to `new()` at line 305 is not released after line 316.
  314.                   }
  315.                   if (!zkDataDirFile.exists() && !zkDataDirFile.mkdirs()) {
  316. >                     throw new IOException("Unable to create zkDataDir - " + zkDataDirFile.getAbsolutePath());
  317.                   }
  318.               }

#66
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java:323: error: Resource Leak
  resource of type `org.apache.bookkeeper.util.LocalBookKeeper` acquired to `lb` by call to `new()` at line 305 is not released after line 323.
**Note**: potential exception at line 319
  321.           }
  322.   
  323. >         return lb;
  324.       }
  325.   

#67
stream/distributedlog/core/src/main/java/org/apache/distributedlog/auditor/DLAuditor.java:300: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `get()` at line 300 is not released after line 300.
  298.               String rootPath = uri.getPath() + "/" + allocationPath;
  299.               try {
  300. >                 List<String> pools = getZooKeeperClient(namespace).get().getChildren(rootPath, false);
  301.                   for (String pool : pools) {
  302.                       poolQueue.add(rootPath + "/" + pool);

#68
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MetadataDrivers.java:302: error: Null Dereference
  object `schemeParts` last assigned on line 301 could be null and is dereferenced at line 302.
  300.           scheme = scheme.toLowerCase();
  301.           String[] schemeParts = StringUtils.split(scheme, '+');
  302. >         checkArgument(schemeParts.length > 0,
  303.                   "Invalid metadata service scheme found : " + uri);
  304.           return getBookieDriver(schemeParts[0]);

#69
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java:317: error: Null Dereference
  object returned by `header.getOperation()` could be null and is dereferenced at line 317.
  315.               try {
  316.                   BookkeeperProtocol.BKPacketHeader header = r.getHeader();
  317. >                 switch (header.getOperation()) {
  318.                       case ADD_ENTRY:
  319.                           processAddRequestV3(r, requestHandler);

#70
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/MSLedgerManagerFactory.java:310: error: Null Dereference
  object returned by `key2LedgerId(e.getKey())` could be null and is dereferenced at line 310.
  308.           @Override
  309.           public void process(MSWatchedEvent e){
  310. >             long ledgerId = key2LedgerId(e.getKey());
  311.               switch(e.getType()) {
  312.               case CHANGED:

#71
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/kv/TableStoreImpl.java:310: error: Null Dereference
  object returned by `reqOp.getRequestCase()` could be null and is dereferenced at line 310.
  308.   
  309.       private Op<byte[], byte[]> buildTxnOp(RoutingHeader header, RequestOp reqOp) {
  310. >         switch (reqOp.getRequestCase()) {
  311.               case REQUEST_PUT:
  312.                   return buildPutOp(header, reqOp.getRequestPut());

#72
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/store/Command.java:321: error: Null Dereference
  object returned by `getReqCase()` could be null and is dereferenced at line 321.
  319.       org.apache.bookkeeper.stream.proto.kv.store.Command other = (org.apache.bookkeeper.stream.proto.kv.store.Command) obj;
  320.   
  321. >     if (!getReqCase().equals(other.getReqCase())) return false;
  322.       switch (reqCase_) {
  323.         case 1:

#73
stream/distributedlog/core/src/main/java/org/apache/distributedlog/auditor/DLAuditor.java:332: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `get()` at line 331 is not released after line 332.
  330.                       throws InterruptedException, ZooKeeperClient.ZooKeeperConnectionException, KeeperException {
  331.                   List<String> allocators = getZooKeeperClient(namespace).get()
  332. >                                         .getChildren(poolPath, false);
  333.                   for (String allocator : allocators) {
  334.                       String allocatorPath = poolPath + "/" + allocator;

#74
stream/distributedlog/core/src/main/java/org/apache/distributedlog/auditor/DLAuditor.java:335: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `get()` at line 335 is not released after line 335.
  333.                   for (String allocator : allocators) {
  334.                       String allocatorPath = poolPath + "/" + allocator;
  335. >                     byte[] data = getZooKeeperClient(namespace).get().getData(allocatorPath, false, new Stat());
  336.                       if (null != data && data.length > 0) {
  337.                           try {

#75
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java:371: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.AutoRecoveryService` acquired by call to `AutoRecoveryService(...)` at line 371 is not released after line 371.
**Note**: potential exception at line 371
  369.   
  370.           // 2. build AutoRecovery server
  371. >         AutoRecoveryService autoRecoveryService = new AutoRecoveryService(conf, rootStatsLogger);
  372.   
  373.           serverBuilder.addComponent(autoRecoveryService);

#76
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java:364: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.StatsProviderService` acquired by call to `StatsProviderService(...)` at line 364 is not released after line 364.
**Note**: potential exception at line 364
  362.   
  363.           // 1. build stats provider
  364. >         StatsProviderService statsProviderService = new StatsProviderService(conf);
  365.           StatsLogger rootStatsLogger = statsProviderService.getStatsProvider().getStatsLogger("");
  366.   

#77
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AutoRecoveryMain.java:388: error: Resource Leak
  resource of type `org.apache.bookkeeper.server.service.StatsProviderService` acquired to `statsProviderService` by call to `StatsProviderService(...)` at line 364 is not released after line 388.
**Note**: potential exception at line 371
  386.           }
  387.   
  388. >         return serverBuilder.build();
  389.       }
  390.   }

#78
stream/server/src/main/java/org/apache/bookkeeper/stream/server/StorageServer.java:399: error: Resource Leak
  resource of type `org.apache.bookkeeper.stream.storage.impl.cluster.ZkClusterMetadataStore` acquired by call to `new()` at line 395 is not released after line 399.
  397.                   regService.get(),
  398.                   new DefaultStorageContainerController(),
  399. >                 new ZkClusterControllerLeaderSelector(curatorProviderService.get(), ZK_METADATA_ROOT_PATH),
  400.                   storageConf),
  401.               rootStatsLogger.scope("cluster_controller"));

#79
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java:411: error: Null Dereference
  object `bookies` last assigned on line 410 could be null and is dereferenced at line 411.
  409.           Collection<BookieId> bookies;
  410.           bookies = bk.bookieWatcher.getBookies();
  411. >         bookies.addAll(bk.bookieWatcher.getReadOnlyBookies());
  412.           if (bookies.isEmpty()) {
  413.               return map;

#80
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:453: error: Null Dereference
  object `candidateNode` last assigned on line 452 could be null and is dereferenced at line 453.
  451.           for (int i = 0; i < ensembleSize; i++) {
  452.               BookieNode candidateNode = selectCandidateNode(bookiesToConsider);
  453. >             newEnsemble.set(i, candidateNode.getAddr());
  454.               bookiesToConsider.remove(candidateNode);
  455.           }

#81
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/storage/GetStreamRequest.java:448: error: Null Dereference
  object returned by `other.getIdCase()` could be null and is dereferenced at line 448.
  446.       public Builder mergeFrom(org.apache.bookkeeper.stream.proto.storage.GetStreamRequest other) {
  447.         if (other == org.apache.bookkeeper.stream.proto.storage.GetStreamRequest.getDefaultInstance()) return this;
  448. >       switch (other.getIdCase()) {
  449.           case STREAM_NAME: {
  450.             mergeStreamName(other.getStreamName());

#82
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:472: error: Null Dereference
  object returned by `selectCandidateNode(bookiesToConsider)` could be null and is dereferenced at line 472.
  470.               throw new BKNotEnoughBookiesException();
  471.           }
  472. >         BookieId candidateAddr = (selectCandidateNode(bookiesToConsider)).getAddr();
  473.           newEnsemble.set(bookieToReplaceIndex, candidateAddr);
  474.           return PlacementResult.of(candidateAddr,

#83
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexInMemPageMgr.java:512: error: Resource Leak
  resource of type `org.apache.bookkeeper.bookie.LedgerEntryPage` acquired to `lep` by call to `new()` at line 499 is not released after line 512.
**Note**: potential exception at line 500
  510.                       ledger, entry);
  511.               flushOneOrMoreLedgers(false);
  512. >         }
  513.       }
  514.   

#84
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/SplitPolicy.java:498: error: Null Dereference
  object returned by `other.getPolicyCase()` could be null and is dereferenced at line 498.
  496.           setTypeValue(other.getTypeValue());
  497.         }
  498. >       switch (other.getPolicyCase()) {
  499.           case FIXED_RANGE_POLICY: {
  500.             mergeFixedRangePolicy(other.getFixedRangePolicy());

#85
stream/distributedlog/core/src/main/java/org/apache/distributedlog/auditor/DLAuditor.java:510: error: Null Dereference
  object returned by `bkc.get()` could be null and is dereferenced by call to `getLedgerManager(...)` at line 510.
  508.           final AtomicLong numLedgers = new AtomicLong(0);
  509.   
  510. >         LedgerManager lm = BookKeeperAccessor.getLedgerManager(bkc.get());
  511.   
  512.           final CompletableFuture<Void> doneFuture = FutureUtils.createFuture();

#86
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java:536: error: Resource Leak
  resource of type `java.io.RandomAccessFile` acquired by call to `RandomAccessFile(...)` at line 521 is not released after line 536.
  534.           } finally {
  535.               newFc.force(true);
  536. >             newFc.close();
  537.           }
  538.           // delete old.idx

#87
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/RequestOp.java:520: error: Null Dereference
  object returned by `other.getRequestCase()` could be null and is dereferenced at line 520.
  518.       public Builder mergeFrom(org.apache.bookkeeper.stream.proto.kv.rpc.RequestOp other) {
  519.         if (other == org.apache.bookkeeper.stream.proto.kv.rpc.RequestOp.getDefaultInstance()) return this;
  520. >       switch (other.getRequestCase()) {
  521.           case REQUEST_RANGE: {
  522.             mergeRequestRange(other.getRequestRange());

#88
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/ResponseOp.java:520: error: Null Dereference
  object returned by `other.getResponseCase()` could be null and is dereferenced at line 520.
  518.       public Builder mergeFrom(org.apache.bookkeeper.stream.proto.kv.rpc.ResponseOp other) {
  519.         if (other == org.apache.bookkeeper.stream.proto.kv.rpc.ResponseOp.getDefaultInstance()) return this;
  520. >       switch (other.getResponseCase()) {
  521.           case RESPONSE_RANGE: {
  522.             mergeResponseRange(other.getResponseRange());

#89
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:557: error: Null Dereference
  object `bookiesToConsiderAfterExcludingZonesAndUDs` last assigned on line 546 could be null and is dereferenced at line 557.
  555.               }
  556.           }
  557. >         if (bookiesToConsiderAfterExcludingZonesAndUDs.isEmpty()) {
  558.               zonesToExclude = getZonesToExcludeToMaintainMinZones(currentEnsemble, bookieToReplaceIndex,
  559.                       writeQuorumSize);

#90
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:569: error: Null Dereference
  object returned by `selectCandidateNode(bookiesToConsiderAfterExcludingZonesAndUDs)` could be null and is dereferenced at line 569.
  567.           }
  568.   
  569. >         BookieId candidateAddr = selectCandidateNode(bookiesToConsiderAfterExcludingZonesAndUDs).getAddr();
  570.           newEnsemble.set(bookieToReplaceIndex, candidateAddr);
  571.           return candidateAddr;

#91
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationWorker.java:589: error: Null Dereference
  object `available` last assigned on line 587 could be null and is dereferenced at line 589.
  587.           Collection<BookieId> available = admin.getAvailableBookies();
  588.           for (BookieId b : finalEnsemble) {
  589. >             if (!available.contains(b)) {
  590.                   if (LOG.isDebugEnabled()) {
  591.                       LOG.debug("Bookie {} is missing from the list of Available Bookies. ledger {}:ensemble {}.",

#92
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java:585: error: Null Dereference
  object `availableBkAddresses` last assigned on line 583 could be null and is dereferenced at line 585.
  583.           Collection<BookieId> availableBkAddresses = admin.getAvailableBookies();
  584.           Collection<BookieId> readOnlyBkAddresses = admin.getReadOnlyBookies();
  585. >         availableBkAddresses.addAll(readOnlyBkAddresses);
  586.   
  587.           List<String> availableBookies = new ArrayList<String>();

#93
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/Compare.java:630: error: Null Dereference
  object returned by `getTargetUnionCase()` could be null and is dereferenced at line 630.
  628.       if (!getKey()
  629.           .equals(other.getKey())) return false;
  630. >     if (!getTargetUnionCase().equals(other.getTargetUnionCase())) return false;
  631.       switch (targetUnionCase_) {
  632.         case 4:

#94
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/store/Command.java:636: error: Null Dereference
  object returned by `other.getReqCase()` could be null and is dereferenced at line 636.
  634.       public Builder mergeFrom(org.apache.bookkeeper.stream.proto.kv.store.Command other) {
  635.         if (other == org.apache.bookkeeper.stream.proto.kv.store.Command.getDefaultInstance()) return this;
  636. >       switch (other.getReqCase()) {
  637.           case NOP_REQ: {
  638.             mergeNopReq(other.getNopReq());

#95
stream/statelib/target/generated-sources/protobuf/java/org/apache/bookkeeper/proto/statestore/kv/Command.java:636: error: Null Dereference
  object returned by `other.getReqCase()` could be null and is dereferenced at line 636.
  634.       public Builder mergeFrom(org.apache.bookkeeper.proto.statestore.kv.Command other) {
  635.         if (other == org.apache.bookkeeper.proto.statestore.kv.Command.getDefaultInstance()) return this;
  636. >       switch (other.getReqCase()) {
  637.           case NOP_REQ: {
  638.             mergeNopReq(other.getNopReq());

#96
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:653: error: Null Dereference
  object `realRange` last assigned on line 652 could be null and is dereferenced at line 653.
  651.               } else {
  652.                   Pair<byte[], byte[]> realRange = getRealRange(key, endKey);
  653. >                 endKey = realRange.getRight();
  654.                   ++endKey[endKey.length - 1];
  655.                   batch.deleteRange(realRange.getLeft(), endKey);

#97
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/HardLink.java:653: error: Null Dereference
  object returned by `getProperty("os.name")` could be null and is dereferenced at line 653.
  651.     public static String makeShellPath(File file) throws IOException {
  652.       String filename = file.getCanonicalPath();
  653. >     if (System.getProperty("os.name").startsWith("Windows")) {
  654.         BufferedReader r = null;
  655.         try {

#98
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:688: error: Null Dereference
  object `realRange` last assigned on line 687 could be null and is dereferenced at line 688.
  686.           } else {
  687.               Pair<byte[], byte[]> realRange = getRealRange(rawKey, rawEndKey);
  688. >             rawKey = realRange.getLeft();
  689.               rawEndKey = realRange.getRight();
  690.   

#99
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:706: error: Null Dereference
  object returned by `excludingUDsOfZonesToConsider.get(nodeLocation.getZone())` could be null and is dereferenced at line 706.
  704.           for (BookieNode bookieToConsider : bookiesToConsider) {
  705.               ZoneAwareNodeLocation nodeLocation = getZoneAwareNodeLocation(bookieToConsider);
  706. >             if (excludingUDsOfZonesToConsider.get(nodeLocation.getZone()).contains(nodeLocation.getUpgradeDomain())) {
  707.                   continue;
  708.               }

#100
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:759: error: Resource Leak
  resource of type `org.rocksdb.WriteBatch` acquired by call to `new()` at line 745 is not released after line 759.
**Note**: potential exception at line 747
  757.   
  758.               return txnResult;
  759. >         } catch (StateStoreRuntimeException e) {
  760.               results.forEach(Result::close);
  761.               throw e;

#101
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:753: error: Null Dereference
  object returned by `newNode.getNetworkLocation()` could be null and is dereferenced at line 753.
  751.                           // refresh the rack info if its a known bookie
  752.                           BookieNode newNode = createBookieNode(bookieAddress);
  753. >                         if (!newNode.getNetworkLocation().equals(node.getNetworkLocation())) {
  754.                               topology.remove(node);
  755.                               topology.add(newNode);

#102
stream/distributedlog/core/src/main/java/org/apache/distributedlog/admin/DistributedLogAdmin.java:787: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `delete(...)` at line 787 is not released after line 787.
  785.               }
  786.               String zkPath = getUri() + "/" + bkdlConfig.getACLRootPath() + "/" + stream;
  787. >             ZKAccessControl.delete(getZooKeeperClient(), zkPath);
  788.               return 0;
  789.           }

#103
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:791: error: Null Dereference
  object `record` could be null and is dereferenced at line 791.
  789.           switch (op.target()) {
  790.               case MOD:
  791. >                 cmp = record.compareModRev(op.revision());
  792.                   break;
  793.               case CREATE:

#104
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:794: error: Null Dereference
  object `record` could be null and is dereferenced at line 794.
  792.                   break;
  793.               case CREATE:
  794. >                 cmp = record.compareCreateRev(op.revision());
  795.                   break;
  796.               case VERSION:

#105
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:797: error: Null Dereference
  object `record` could be null and is dereferenced at line 797.
  795.                   break;
  796.               case VERSION:
  797. >                 cmp = record.compareVersion(op.revision());
  798.                   break;
  799.               case VALUE:

#106
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:799: error: Null Dereference
  object returned by `readEntriesInternalAsync(firstEntry,lastEntry,isRecoveryRead)` could be null and is dereferenced at line 799.
  797.           if (!clientCtx.isClientClosed()) {
  798.               readEntriesInternalAsync(firstEntry, lastEntry, isRecoveryRead)
  799. >                 .whenCompleteAsync(new FutureEventListener<LedgerEntries>() {
  800.                       @Override
  801.                       public void onSuccess(LedgerEntries entries) {

#107
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:919: error: Null Dereference
  object `numOfNodesInAZone` last assigned on line 918 could be null and is dereferenced at line 919.
  917.                           udsOfThisZoneInThisWriteSet.add(upgradeDomain);
  918.                           Integer numOfNodesInAZone = numOfBookiesInZones.get(zone);
  919. >                         numOfBookiesInZones.put(zone, (numOfNodesInAZone + 1));
  920.                       }
  921.                   }

#108
stream/distributedlog/core/src/main/java/org/apache/distributedlog/admin/DistributedLogAdmin.java:900: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `getZKAccessControl(...)` at line 900 is not released after line 900.
  898.               }
  899.               String zkPath = getZKPath(getUri().getPath() + "/" + bkdlConfig.getACLRootPath());
  900. >             ZKAccessControl accessControl = getZKAccessControl(getZooKeeperClient(), zkPath);
  901.               AccessControlEntry acl = accessControl.getAccessControlEntry();
  902.               acl.setDenyWrite(denyWrite);

#109
stream/distributedlog/core/src/main/java/org/apache/distributedlog/admin/DistributedLogAdmin.java:907: error: Resource Leak
  resource of type `org.apache.bookkeeper.zookeeper.ZooKeeperClient` acquired by call to `setZKAccessControl(...)` at line 907 is not released after line 907.
  905.               acl.setDenyAcquire(denyAcquire);
  906.               acl.setDenyRelease(denyRelease);
  907. >             setZKAccessControl(getZooKeeperClient(), accessControl);
  908.               return 0;
  909.           }

#110
stream/proto/target/generated-sources/protobuf/java/org/apache/bookkeeper/stream/proto/kv/rpc/Compare.java:926: error: Null Dereference
  object returned by `other.getTargetUnionCase()` could be null and is dereferenced at line 926.
  924.           setKey(other.getKey());
  925.         }
  926. >       switch (other.getTargetUnionCase()) {
  927.           case VERSION: {
  928.             setVersion(other.getVersion());

#111
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:965: error: Null Dereference
  object `udsOfThisZone` last assigned on line 964 could be null and is dereferenced at line 965.
  963.               if (numOfNodesInThisZone > 1) {
  964.                   Set<String> udsOfThisZone = nodesLocationInWriteSet.get(zone);
  965. >                 if (udsOfThisZone.size() < 2) {
  966.                       return false;
  967.                   }

#112
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/mvcc/MVCCStoreImpl.java:1007: error: Null Dereference
  object `realRange` last assigned on line 1006 could be null and is dereferenced at line 1007.
  1005.           }
  1006.           Pair<byte[], byte[]> realRange = getRealRange(rawKey, rawEndKey);
  1007. >         rawKey = realRange.getLeft();
  1008.           rawEndKey = realRange.getRight();
  1009.   

#113
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BKLogWriteHandler.java:1129: error: Null Dereference
  object `partialTruncate` last assigned on line 1101 could be null and is dereferenced by call to `setLogSegmentTruncationStatus(...)` at line 1129.
  1127.               }
  1128.           }
  1129. >         return setLogSegmentTruncationStatus(truncateList, partialTruncate, dlsn);
  1130.       }
  1131.   

#114
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java:1150: error: Null Dereference
  object `targetBookieAddresses` last assigned on line 1135 could be null and is dereferenced by call to `replicateLedgerFragment(...)` at line 1150.
  1148.               throw new BKException.BKLedgerRecoveryException();
  1149.           }
  1150. >         replicateLedgerFragment(lh, ledgerFragment, targetBookieAddresses, onReadEntryFailureCallback);
  1151.       }
  1152.   

#115
stream/distributedlog/core/src/main/java/org/apache/distributedlog/tools/DistributedLogTool.java:1276: error: Null Dereference
  object returned by `DistributedLogTool$DeleteLedgersCommand$1.this$0.getBookKeeperClient().get()` could be null and is dereferenced at line 1276.
  1274.                                   }
  1275.                                   try {
  1276. >                                     getBookKeeperClient().get().deleteLedger(ledger);
  1277.                                       int numLedgersDeleted = numLedgers.incrementAndGet();
  1278.                                       if (numLedgersDeleted % 1000 == 0) {

#116
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/DefaultEntryLogger.java:1295: error: Null Dereference
  object `compactingLogFile` last assigned on line 1294 could be null and is dereferenced at line 1295.
  1293.   
  1294.           File compactingLogFile = getCurCompactionLogFile();
  1295. >         long compactionLogId = fileName2LogId(compactingLogFile.getName());
  1296.           File compactedLogFile = compactedLogFileFromCompacting(compactingLogFile, logToCompact);
  1297.           File finalLogFile = new File(compactingLogFile.getParentFile(),

#117
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/DefaultEntryLogger.java:1299: error: Null Dereference
  object returned by `compactingLogFile.getName()` could be null and is dereferenced at line 1299.
  1297.           File finalLogFile = new File(compactingLogFile.getParentFile(),
  1298.                                        compactingLogFile.getName().substring(0,
  1299. >                                              compactingLogFile.getName().indexOf(".log") + 4));
  1300.           return new EntryLoggerCompactionEntryLog(
  1301.                   compactionLogId, logToCompact, compactingLogFile, compactedLogFile, finalLogFile);

#118
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java:1466: error: Null Dereference
  object `cmd.bka` last assigned on line 1465 could be null and is dereferenced by call to `apply(...)` at line 1466.
  1464.               CliFlags flags = new CliFlags();
  1465.               WhoIsAuditorCommand cmd = new WhoIsAuditorCommand();
  1466. >             boolean result = cmd.apply(bkConf, flags);
  1467.               return result ? 0 : -1;
  1468.           }

#119
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1586: error: Resource Leak
  resource of type `org.apache.bookkeeper.client.ReadLastConfirmedAndEntryOp$ParallelReadRequest` acquired by call to `initiate()` at line 1586 is not released after line 1586.
  1584.           new ReadLastConfirmedAndEntryOp(this, clientCtx, getCurrentEnsemble(), innercb, entryId - 1, timeOutInMillis)
  1585.               .parallelRead(parallel)
  1586. >             .initiate();
  1587.       }
  1588.   

#120
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1586: error: Resource Leak
  resource of type `org.apache.bookkeeper.client.ReadLastConfirmedAndEntryOp$SequenceReadRequest` acquired by call to `initiate()` at line 1586 is not released after line 1586.
  1584.           new ReadLastConfirmedAndEntryOp(this, clientCtx, getCurrentEnsemble(), innercb, entryId - 1, timeOutInMillis)
  1585.               .parallelRead(parallel)
  1586. >             .initiate();
  1587.       }
  1588.   

#121
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java:1585: error: Null Dereference
  object returned by `getAvailableBookies()` could be null and is dereferenced at line 1585.
  1583.               throws CompatibilityException, UnavailableException, KeeperException, InterruptedException, IOException,
  1584.               BKAuditException, TimeoutException, BKException {
  1585. >         if (getAvailableBookies().contains(bookieAddress) || getReadOnlyBookies().contains(bookieAddress)) {
  1586.               LOG.error("Bookie: {} is not shutdown yet", bookieAddress);
  1587.               throw BKException.create(BKException.Code.IllegalOpException);

#122
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java:1585: error: Null Dereference
  object returned by `getReadOnlyBookies()` could be null and is dereferenced at line 1585.
  1583.               throws CompatibilityException, UnavailableException, KeeperException, InterruptedException, IOException,
  1584.               BKAuditException, TimeoutException, BKException {
  1585. >         if (getAvailableBookies().contains(bookieAddress) || getReadOnlyBookies().contains(bookieAddress)) {
  1586.               LOG.error("Bookie: {} is not shutdown yet", bookieAddress);
  1587.               throw BKException.create(BKException.Code.IllegalOpException);

#123
stream/distributedlog/core/src/main/java/org/apache/distributedlog/tools/DistributedLogTool.java:1691: error: Null Dereference
  object returned by `bkc.get()` could be null and is dereferenced by call to `BookKeeperAdmin(...)` at line 1691.
  1689.                                            BookKeeperClient bkc,
  1690.                                            List<LogSegmentMetadata> segments) throws Exception {
  1691. >             BookKeeperAdmin bkAdmin = new BookKeeperAdmin(bkc.get());
  1692.               try {
  1693.                   MetadataUpdater metadataUpdater = LogSegmentMetadataStoreUpdater.createMetadataUpdater(

#124
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClientImpl.java:119: warning: Thread Safety Violation
  Unprotected write. Non-private method `BookieClientImpl(...)` indirectly mutates container `util.ReflectionUtils.constructorCache` via call to `Map.put(...)` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  117.           this.bookieAddressResolver = bookieAddressResolver;
  118.           this.registry = ExtensionRegistry.newInstance();
  119. >         this.authProviderFactory = AuthProviderFactoryFactory.newClientAuthProviderFactory(conf);
  120.   
  121.           this.statsLogger = statsLogger;

#125
bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopologyImpl.java:409: warning: Thread Safety Violation
  Read/Write race. Non-private method `NetworkTopologyImpl.add(...)` indirectly reads without synchronization from `this.numOfRacks`. Potentially races with write in method `NetworkTopologyImpl.remove(...)`.
 Reporting because this access may occur on a background thread.
  407.               return;
  408.           }
  409. >         String oldTopoStr = this.toString();
  410.           if (node instanceof InnerNode) {
  411.               throw new IllegalArgumentException("Not allow to add an inner node: " + NodeBase.getPath(node));

#126
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BKLogSegmentWriter.java:1189: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKLogSegmentWriter.addComplete(...)` reads without synchronization from `this.lastEntryId`. Potentially races with write in method `BKLogSegmentWriter.addComplete(...)`.
 Reporting because this access may occur on a background thread.
  1187.   
  1188.           // Sanity check to make sure we're receiving these callbacks in order.
  1189. >         if (entryId > -1 && lastEntryId >= entryId) {
  1190.               LOG.error("Log segment {} saw out of order entry {} lastEntryId {}",
  1191.                   fullyQualifiedLogSegment, entryId, lastEntryId);

#127
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BKLogSegmentWriter.java:1193: warning: Thread Safety Violation
  Unprotected write. Non-private method `BKLogSegmentWriter.addComplete(...)` writes to field `this.lastEntryId` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1191.                   fullyQualifiedLogSegment, entryId, lastEntryId);
  1192.           }
  1193. >         lastEntryId = entryId;
  1194.   
  1195.           assert (ctx instanceof BKTransmitPacket);

#128
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:913: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.addEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  911.        */
  912.       public long addEntry(byte[] data) throws InterruptedException, BKException {
  913. >         return addEntry(data, 0, data.length);
  914.       }
  915.   

#129
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:963: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.addEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  961.   
  962.           SyncAddCallback callback = new SyncAddCallback();
  963. >         asyncAddEntry(data, offset, length, callback, null);
  964.   
  965.           return SyncCallbackUtils.waitForResult(callback);

#130
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java:131: warning: Thread Safety Violation
  Unprotected write. Non-private method `PendingAddOp.allowFailFastOnUnwritableChannel()` writes to field `this.allowFailFast` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  129.   
  130.       PendingAddOp allowFailFastOnUnwritableChannel() {
  131. >         allowFailFast = true;
  132.           return this;
  133.       }

#131
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:922: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.appendAsync(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  920.       public CompletableFuture<Long> appendAsync(ByteBuf data) {
  921.           SyncAddCallback callback = new SyncAddCallback();
  922. >         asyncAddEntry(data, callback, null);
  923.           return callback;
  924.       }

#132
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicyImpl.java:1078: warning: Thread Safety Violation
  Read/Write race. Non-private method `RackawareEnsemblePlacementPolicyImpl.areAckedBookiesAdheringToPlacementPolicy(...)` reads without synchronization from `this.minNumRacksPerWriteQuorum`. Potentially races with write in method `RackawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  1076.                                                               int ackQuorumSize) {
  1077.           HashSet<String> rackCounter = new HashSet<>();
  1078. >         int minWriteQuorumNumRacksPerWriteQuorum = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);
  1079.   
  1080.           ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();

#133
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:977: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZoneawareEnsemblePlacementPolicyImpl.areAckedBookiesAdheringToPlacementPolicy(...)` reads without synchronization from `this.minNumZonesPerWriteQuorum`. Potentially races with write in method `ZoneawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  975.               int ackQuorumSize) {
  976.           HashSet<String> zonesOfAckedBookies = new HashSet<>();
  977. >         int minNumZonesPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumZonesPerWriteQuorum);
  978.           boolean areAckedBookiesAdheringToPlacementPolicy = false;
  979.           ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();

#134
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1055: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncAddEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1053.   
  1054.       public void asyncAddEntry(ByteBuf data, final AddCallback cb, final Object ctx) {
  1055. >         PendingAddOp op = PendingAddOp.create(this, clientCtx, getCurrentEnsemble(), data, writeFlags, cb, ctx);
  1056.           doAsyncAddEntry(op);
  1057.       }

#135
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1051: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncAddEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1049.           }
  1050.   
  1051. >         asyncAddEntry(Unpooled.wrappedBuffer(data, offset, length), cb, ctx);
  1052.       }
  1053.   

#136
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1003: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncAddEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1001.       public void asyncAddEntry(final byte[] data, final AddCallback cb,
  1002.                                 final Object ctx) {
  1003. >         asyncAddEntry(data, 0, data.length, cb, ctx);
  1004.       }
  1005.   

#137
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:692: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadEntries(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  690.           }
  691.   
  692. >         asyncReadEntriesInternal(firstEntry, lastEntry, cb, ctx, false);
  693.       }
  694.   

#138
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:798: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadEntriesInternal(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  796.                                     Object ctx, boolean isRecoveryRead) {
  797.           if (!clientCtx.isClientClosed()) {
  798. >             readEntriesInternalAsync(firstEntry, lastEntry, isRecoveryRead)
  799.                   .whenCompleteAsync(new FutureEventListener<LedgerEntries>() {
  800.                       @Override

#139
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1727: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadExplicitLastConfirmed(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1725.               }
  1726.           };
  1727. >         new PendingReadLacOp(this, clientCtx.getBookieClient(), getCurrentEnsemble(), innercb).initiate();
  1728.       }
  1729.   

#140
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1391: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadLastConfirmed(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1389.           if (clientCtx.getConf().useV2WireProtocol) {
  1390.               // in v2 protocol we don't support readLAC RPC
  1391. >             asyncReadPiggybackLastConfirmed(cb, ctx);
  1392.           } else {
  1393.               asyncReadExplicitLastConfirmed(cb, ctx);

#141
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1551: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadLastConfirmedAndEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1549.           }
  1550.           if (entryId <= lac) {
  1551. >             asyncReadEntries(entryId, entryId, new ReadCallback() {
  1552.                   @Override
  1553.                   public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {

#142
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:843: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadLastEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  841.               cb.readComplete(BKException.Code.NoSuchEntryException, this, null, ctx);
  842.           } else {
  843. >             asyncReadEntriesInternal(lastEntryId, lastEntryId, cb, ctx, false);
  844.           }
  845.       }

#143
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:731: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncReadUnconfirmedEntries(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  729.           }
  730.   
  731. >         asyncReadEntriesInternal(firstEntry, lastEntry, cb, ctx, false);
  732.       }
  733.   

#144
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1208: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncRecoveryAddEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1206.       void asyncRecoveryAddEntry(final byte[] data, final int offset, final int length,
  1207.                                  final AddCallback cb, final Object ctx) {
  1208. >         PendingAddOp op = PendingAddOp.create(this, clientCtx, getCurrentEnsemble(),
  1209.                                                 Unpooled.wrappedBuffer(data, offset, length),
  1210.                                                 writeFlags, cb, ctx)

#145
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1474: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.asyncTryReadLastConfirmed(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1472.               }
  1473.           };
  1474. >         new TryReadLastConfirmedOp(this, clientCtx.getBookieClient(), getCurrentEnsemble(),
  1475.                                      innercb, getLastAddConfirmed()).initiate();
  1476.       }

#146
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:155: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.checkStoreOpen()` reads without synchronization from `this.name`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  153.       protected void checkStoreOpen() {
  154.           if (closed) {
  155. >             throw new InvalidStateStoreException("State store " + name + " is already closed");
  156.           }
  157.           if (!isInitialized) {

#147
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/SingleDirectoryDbLedgerStorage.java:775: warning: Thread Safety Violation
  Read/Write race. Non-private method `SingleDirectoryDbLedgerStorage.checkpoint(...)` reads without synchronization from `this.checkpointSource`. Potentially races with write in method `SingleDirectoryDbLedgerStorage.setCheckpointSource(...)`.
 Reporting because this access may occur on a background thread.
  773.       @Override
  774.       public void checkpoint(Checkpoint checkpoint) throws IOException {
  775. >         Checkpoint thisCheckpoint = checkpointSource.newCheckpoint();
  776.           if (lastCheckpoint.compareTo(checkpoint) > 0) {
  777.               return;

#148
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/SingleDirectoryDbLedgerStorage.java:776: warning: Thread Safety Violation
  Read/Write race. Non-private method `SingleDirectoryDbLedgerStorage.checkpoint(...)` reads without synchronization from `this.lastCheckpoint`. Potentially races with write in method `SingleDirectoryDbLedgerStorage.checkpoint(...)`.
 Reporting because this access may occur on a background thread.
  774.       public void checkpoint(Checkpoint checkpoint) throws IOException {
  775.           Checkpoint thisCheckpoint = checkpointSource.newCheckpoint();
  776. >         if (lastCheckpoint.compareTo(checkpoint) > 0) {
  777.               return;
  778.           }

#149
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:385: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.close()` indirectly reads without synchronization from `this.allocator`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  383.               return;
  384.           }
  385. >         doClose();
  386.       }
  387.   

#150
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/directentrylogger/DirectReader.java:258: warning: Thread Safety Violation
  Unprotected write. Non-private method `DirectReader.close()` writes to field `this.closed` outside of synchronization.
 Reporting because this access may occur on a background thread.
  256.               int ret = nativeIO.close(fd);
  257.               checkState(ret == 0, "Close should throw exception on non-zero return (%d)", ret);
  258. >             closed = true;
  259.           } catch (NativeIOException ne) {
  260.               throw new IOException(exMsg(ne.getMessage())

#151
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/store/MVCCStoreFactoryImpl.java:284: warning: Thread Safety Violation
  Read/Write race. Non-private method `MVCCStoreFactoryImpl.close()` reads without synchronization from `this.checkpointStore`. Potentially races with write in method `MVCCStoreFactoryImpl.newStore(...)`.
 Reporting because this access may occur on a background thread.
  282.               log.info("Encountered issue on closing all the range stores opened by this range factory");
  283.           }
  284. >         if (null != checkpointStore) {
  285.               checkpointStore.close();
  286.               checkpointStore = null;

#152
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/store/MVCCStoreFactoryImpl.java:286: warning: Thread Safety Violation
  Unprotected write. Non-private method `MVCCStoreFactoryImpl.close()` writes to field `this.checkpointStore` outside of synchronization.
 Reporting because this access may occur on a background thread.
  284.           if (null != checkpointStore) {
  285.               checkpointStore.close();
  286. >             checkpointStore = null;
  287.           }
  288.   

#153
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataBookieDriver.java:73: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKMetadataBookieDriver.close()` indirectly reads without synchronization from `this.ownZKHandle`. Potentially races with write in method `ZKMetadataBookieDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  71.       @Override
  72.       public void close() {
  73. >         super.close();
  74.       }
  75.   }

#154
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataDriverBase.java:334: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKMetadataDriverBase.close()` reads without synchronization from `this.lmFactory`. Potentially races with write in method `ZKMetadataDriverBase.getLedgerManagerFactory()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  332.       @Override
  333.       public void close() {
  334. >         if (null != lmFactory) {
  335.               try {
  336.                   lmFactory.close();

#155
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataDriverBase.java:340: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKMetadataDriverBase.close()` writes to field `this.lmFactory` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  338.                   log.warn("Failed to close zookeeper based ledger manager", e);
  339.               }
  340. >             lmFactory = null;
  341.           }
  342.           if (ownZKHandle && null != zk) {

#156
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/journal/AbstractStateStoreWithJournal.java:462: warning: Thread Safety Violation
  Read/Write race. Non-private method `AbstractStateStoreWithJournal.closeAsync()` indirectly reads without synchronization from `this.name`. Potentially races with write in method `AbstractStateStoreWithJournal.init(...)`.
 Reporting because this access may occur on a background thread.
  460.           if (null != checkpointTask) {
  461.               if (!checkpointTask.cancel(true)) {
  462. >                 log.warn("Fail to cancel checkpoint task of state store {}", name());
  463.               }
  464.           }

#157
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/journal/AbstractStateStoreWithJournal.java:466: warning: Thread Safety Violation
  Read/Write race. Non-private method `AbstractStateStoreWithJournal.closeAsync()` reads without synchronization from `this.writeIOScheduler`. Potentially races with write in method `AbstractStateStoreWithJournal.init(...)`.
 Reporting because this access may occur on a background thread.
  464.           }
  465.           // wait until last checkpoint task completed
  466. >         writeIOScheduler.submit(() -> {
  467.               log.info("closing async state store {}", name);
  468.               FutureUtils.ensure(

#158
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:481: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.closeLocalDB()` reads without synchronization from `this.dataCfHandle`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  479.   
  480.           RocksUtils.close(metaCfHandle);
  481. >         RocksUtils.close(dataCfHandle);
  482.           RocksUtils.close(db);
  483.       }

#159
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:480: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.closeLocalDB()` reads without synchronization from `this.metaCfHandle`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  478.           }
  479.   
  480. >         RocksUtils.close(metaCfHandle);
  481.           RocksUtils.close(dataCfHandle);
  482.           RocksUtils.close(db);

#160
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:482: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.closeLocalDB()` reads without synchronization from `this.db`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  480.           RocksUtils.close(metaCfHandle);
  481.           RocksUtils.close(dataCfHandle);
  482. >         RocksUtils.close(db);
  483.       }
  484.   

#161
bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java:67: warning: Thread Safety Violation
  Read/Write race. Non-private method `InMemoryMetastoreTable$MetadataVersion.compare(...)` reads without synchronization from `this.version`. Potentially races with write in method `InMemoryMetastoreTable$MetadataVersion.incrementVersion()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  65.               }
  66.               MetadataVersion mv = (MetadataVersion) v;
  67. >             int res = version - mv.version;
  68.               if (res == 0) {
  69.                   return Occurred.CONCURRENTLY;

#162
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java:445: warning: Thread Safety Violation
  Unprotected write. Non-private method `PendingReadOp$SequenceReadRequest.complete(...)` indirectly writes to field `this.rc` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  443.           @Override
  444.           boolean complete(int bookieIndex, BookieId host, ByteBuf buffer) {
  445. >             boolean completed = super.complete(bookieIndex, host, buffer);
  446.               if (completed) {
  447.                   int numReplicasTried = getNextReplicaIndexToReadFrom();

#163
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedAndEntryOp.java:416: warning: Thread Safety Violation
  Unprotected write. Non-private method `ReadLastConfirmedAndEntryOp$SequenceReadRequest.complete(...)` indirectly writes to field `this.rc` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  414.           @Override
  415.           boolean complete(int bookieIndex, BookieId host, ByteBuf buffer, long entryId) {
  416. >             boolean completed = super.complete(bookieIndex, host, buffer, entryId);
  417.               if (completed) {
  418.                   int numReplicasTried = getNextReplicaIndexToReadFrom();

#164
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:843: warning: Thread Safety Violation
  Read/Write race. Non-private method `TopologyAwareEnsemblePlacementPolicy.convertBookieToNode(...)` reads without synchronization from container `this.knownBookies` via call to `Map.get(...)`. Potentially races with write in method `TopologyAwareEnsemblePlacementPolicy.onClusterChanged(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  841.   
  842.       protected BookieNode convertBookieToNode(BookieId addr) {
  843. >         BookieNode bn = knownBookies.get(addr);
  844.           if (null == bn) {
  845.               bn = createBookieNode(addr);

#165
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:837: warning: Thread Safety Violation
  Read/Write race. Non-private method `TopologyAwareEnsemblePlacementPolicy.convertBookiesToNodes(...)` indirectly reads without synchronization from container `this.knownBookies` via call to `Map.get(...)`. Potentially races with write in method `TopologyAwareEnsemblePlacementPolicy.onClusterChanged(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  835.           Set<Node> nodes = new HashSet<Node>();
  836.           for (BookieId addr : bookies) {
  837. >             nodes.add(convertBookieToNode(addr));
  838.           }
  839.           return nodes;

#166
stream/distributedlog/protocol/src/main/java/org/apache/distributedlog/EnvelopedRecordSetWriter.java:149: warning: Thread Safety Violation
  Read/Write race. Non-private method `EnvelopedRecordSetWriter.createBuffer()` reads without synchronization from `this.count`. Potentially races with write in method `EnvelopedRecordSetWriter.writeRecord(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  147.           compressedBuf.setInt(METADATA_OFFSET, metadata);
  148.           // update count
  149. >         compressedBuf.setInt(COUNT_OFFSET, count);
  150.           // update data len
  151.           compressedBuf.setInt(DECOMPRESSED_SIZE_OFFSET, dataLen);

#167
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:191: warning: Interface Not Thread Safe
  Unprotected call to method `DeleteOption.endKey()` of un-annotated interface `org.apache.bookkeeper.api.kv.options.DeleteOption`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  189.           pKey.retain();
  190.           lKey.retain();
  191. >         if (null != option.endKey()) {
  192.               option.endKey().retain();
  193.           }

#168
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:76: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  74.    * A {@link PTable} implementation using simple grpc calls.
  75.    */
  76. > @Slf4j
  77.   public class PByteBufSimpleTableImpl
  78.       extends AbstractStub<PByteBufSimpleTableImpl>

#169
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:163: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.minLatency`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  161.               OpStats diff = new OpStats();
  162.               diff.maxLatency = this.maxLatency > base.maxLatency ? this.maxLatency : base.maxLatency;
  163. >             diff.minLatency = this.minLatency > base.minLatency ? base.minLatency : this.minLatency;
  164.               diff.totalLatency = this.totalLatency - base.totalLatency;
  165.               diff.numSuccessOps = this.numSuccessOps - base.numSuccessOps;

#170
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:168: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.latencyBuckets.[_]`. Potentially races with write in method `BKStats$OpStats.updateLatency(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  166.               diff.numFailedOps = this.numFailedOps - base.numFailedOps;
  167.               for (int i = 0; i < NUM_BUCKETS; i++) {
  168. >                 diff.latencyBuckets[i] = this.latencyBuckets[i] - base.latencyBuckets[i];
  169.               }
  170.               return diff;

#171
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:162: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.maxLatency`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  160.           public OpStats diff(OpStats base) {
  161.               OpStats diff = new OpStats();
  162. >             diff.maxLatency = this.maxLatency > base.maxLatency ? this.maxLatency : base.maxLatency;
  163.               diff.minLatency = this.minLatency > base.minLatency ? base.minLatency : this.minLatency;
  164.               diff.totalLatency = this.totalLatency - base.totalLatency;

#172
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:166: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.numFailedOps`. Potentially races with write in method `BKStats$OpStats.incrementFailedOps()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  164.               diff.totalLatency = this.totalLatency - base.totalLatency;
  165.               diff.numSuccessOps = this.numSuccessOps - base.numSuccessOps;
  166. >             diff.numFailedOps = this.numFailedOps - base.numFailedOps;
  167.               for (int i = 0; i < NUM_BUCKETS; i++) {
  168.                   diff.latencyBuckets[i] = this.latencyBuckets[i] - base.latencyBuckets[i];

#173
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:165: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.numSuccessOps`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  163.               diff.minLatency = this.minLatency > base.minLatency ? base.minLatency : this.minLatency;
  164.               diff.totalLatency = this.totalLatency - base.totalLatency;
  165. >             diff.numSuccessOps = this.numSuccessOps - base.numSuccessOps;
  166.               diff.numFailedOps = this.numFailedOps - base.numFailedOps;
  167.               for (int i = 0; i < NUM_BUCKETS; i++) {

#174
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:164: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.diff(...)` reads without synchronization from `this.totalLatency`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  162.               diff.maxLatency = this.maxLatency > base.maxLatency ? this.maxLatency : base.maxLatency;
  163.               diff.minLatency = this.minLatency > base.minLatency ? base.minLatency : this.minLatency;
  164. >             diff.totalLatency = this.totalLatency - base.totalLatency;
  165.               diff.numSuccessOps = this.numSuccessOps - base.numSuccessOps;
  166.               diff.numFailedOps = this.numFailedOps - base.numFailedOps;

#175
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1358: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.doAsyncAddEntry(...)` indirectly reads with synchronization from `op.allowFailFast`. Potentially races with unsynchronized write in method `LedgerHandle.doAsyncAddEntry(...)`.
 Reporting because this access may occur on a background thread.
  1356.           }
  1357.   
  1358. >         op.initiate();
  1359.   
  1360.       }

#176
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1351: warning: Thread Safety Violation
  Unprotected write. Non-private method `LedgerHandle.doAsyncAddEntry(...)` indirectly writes to field `op.allowFailFast` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1349.               try {
  1350.                   if (!waitForWritable(ws, 0, clientCtx.getConf().waitForWriteSetMs)) {
  1351. >                     op.allowFailFastOnUnwritableChannel();
  1352.                   }
  1353.               } finally {

#177
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1348: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.doAsyncAddEntry(...)` indirectly reads without synchronization from `op.entryId`. Potentially races with write in method `LedgerHandle.doAsyncAddEntry(...)`.
 Reporting because this access may occur on a background thread.
  1346.   
  1347.           if (clientCtx.getConf().waitForWriteSetMs >= 0) {
  1348. >             DistributionSchedule.WriteSet ws = distributionSchedule.getWriteSet(op.getEntryId());
  1349.               try {
  1350.                   if (!waitForWritable(ws, 0, clientCtx.getConf().waitForWriteSetMs)) {

#178
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1350: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.doAsyncAddEntry(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1348.               DistributionSchedule.WriteSet ws = distributionSchedule.getWriteSet(op.getEntryId());
  1349.               try {
  1350. >                 if (!waitForWritable(ws, 0, clientCtx.getConf().waitForWriteSetMs)) {
  1351.                       op.allowFailFastOnUnwritableChannel();
  1352.                   }

#179
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandleAdv.java:278: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandleAdv.doAsyncAddEntry(...)` indirectly reads with synchronization from `op.allowFailFast`. Potentially races with unsynchronized write in method `LedgerHandleAdv.doAsyncAddEntry(...)`.
 Reporting because this access may occur on a background thread.
  276.           }
  277.   
  278. >         op.initiate();
  279.       }
  280.   

#180
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandleAdv.java:271: warning: Thread Safety Violation
  Unprotected write. Non-private method `LedgerHandleAdv.doAsyncAddEntry(...)` indirectly writes to field `op.allowFailFast` outside of synchronization.
 Reporting because this access may occur on a background thread.
  269.               try {
  270.                   if (!waitForWritable(ws, 0, clientCtx.getConf().waitForWriteSetMs)) {
  271. >                     op.allowFailFastOnUnwritableChannel();
  272.                   }
  273.               } finally {

#181
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandleAdv.java:268: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandleAdv.doAsyncAddEntry(...)` indirectly reads without synchronization from `op.entryId`. Potentially races with write in method `LedgerHandleAdv.doAsyncAddEntry(...)`.
 Reporting because this access may occur on a background thread.
  266.   
  267.           if (clientCtx.getConf().waitForWriteSetMs >= 0) {
  268. >             DistributionSchedule.WriteSet ws = distributionSchedule.getWriteSet(op.getEntryId());
  269.               try {
  270.                   if (!waitForWritable(ws, 0, clientCtx.getConf().waitForWriteSetMs)) {

#182
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java:126: warning: Thread Safety Violation
  Unprotected write. Non-private method `PendingAddOp.enableRecoveryAdd()` writes to field `this.isRecoveryAdd` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  124.        */
  125.       PendingAddOp enableRecoveryAdd() {
  126. >         isRecoveryAdd = true;
  127.           return this;
  128.       }

#183
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1919: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.ensembleChangeLoop(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1917.               LOG.info("{} reaches max allowed ensemble change number {}",
  1918.                        logContext, clientCtx.getConf().maxAllowedEnsembleChanges);
  1919. >             handleUnrecoverableErrorDuringAdd(WriteException);
  1920.               return;
  1921.           }

#184
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:535: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.enumerateLogsWithMetadataInNamespace()` reads without synchronization from `this.writerZKC`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  533.           String namespaceRootPath = namespace.getPath();
  534.           HashMap<String, byte[]> result = new HashMap<String, byte[]>();
  535. >         ZooKeeperClient zkc = writerZKC;
  536.           try {
  537.               ZooKeeper zk = Utils.sync(zkc, namespaceRootPath);

#185
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:533: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.enumerateLogsWithMetadataInNamespace()` reads without synchronization from `this.namespace`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  531.       public Map<String, byte[]> enumerateLogsWithMetadataInNamespace()
  532.           throws IOException, IllegalArgumentException {
  533. >         String namespaceRootPath = namespace.getPath();
  534.           HashMap<String, byte[]> result = new HashMap<String, byte[]>();
  535.           ZooKeeperClient zkc = writerZKC;

#186
bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java:83: warning: Thread Safety Violation
  Read/Write race. Non-private method `InMemoryMetastoreTable$MetadataVersion.equals(...)` reads without synchronization from `this.version`. Potentially races with write in method `InMemoryMetastoreTable$MetadataVersion.incrementVersion()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  81.               }
  82.               MetadataVersion v = (MetadataVersion) obj;
  83. >             return 0 == (version - v.version);
  84.           }
  85.   

#187
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java:429: warning: Thread Safety Violation
  Read/Write race. Non-private method `PendingAddOp.equals(...)` reads without synchronization from `this.entryId`. Potentially races with write in method `PendingAddOp.submitCallback(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  427.       public boolean equals(Object o) {
  428.          if (o instanceof PendingAddOp) {
  429. >            return (this.entryId == ((PendingAddOp) o).entryId);
  430.          }
  431.          return (this == o);

#188
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/SingleDirectoryDbLedgerStorage.java:899: warning: Thread Safety Violation
  Read/Write race. Non-private method `SingleDirectoryDbLedgerStorage.flush()` indirectly reads without synchronization from `this.lastCheckpoint`. Potentially races with write in method `SingleDirectoryDbLedgerStorage.checkpoint(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  897.       public void flush() throws IOException {
  898.           Checkpoint cp = checkpointSource.newCheckpoint();
  899. >         checkpoint(cp);
  900.           if (singleLedgerDirs) {
  901.               checkpointSource.checkpointComplete(cp, true);

#189
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BKLogSegmentWriter.java:1027: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKLogSegmentWriter.flushIfNeeded()` reads without synchronization from `this.outstandingBytes`. Potentially races with write in method `BKLogSegmentWriter.asyncWrite(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1025.       void flushIfNeeded() throws BKTransmitException, WriteException, InvalidEnvelopedEntryException,
  1026.               LockingException, FlushException {
  1027. >         if (outstandingBytes > transmissionThreshold) {
  1028.               // If flush delay is disabled, flush immediately, else schedule appropriately.
  1029.               if (0 == minDelayBetweenImmediateFlushMs) {

#190
stream/distributedlog/core/src/main/java/org/apache/distributedlog/BKLogSegmentWriter.java:990: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKLogSegmentWriter.flushIfNeededNoThrow()` indirectly reads without synchronization from `this.outstandingBytes`. Potentially races with write in method `BKLogSegmentWriter.asyncWrite(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  988.       void flushIfNeededNoThrow() {
  989.           try {
  990. >             flushIfNeeded();
  991.           } catch (IOException ioe) {
  992.               LOG.error("Encountered exception while flushing log records to stream {}",

#191
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1141: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.force()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1139.       public CompletableFuture<Void> force() {
  1140.           CompletableFuture<Void> result = new CompletableFuture<>();
  1141. >         ForceLedgerOp op = new ForceLedgerOp(this, clientCtx.getBookieClient(), getCurrentEnsemble(), result);
  1142.           boolean wasClosed = false;
  1143.           synchronized (this) {

#192
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:143: warning: Interface Not Thread Safe
  Unprotected call to method `RangeOption.endKey()` of un-annotated interface `org.apache.bookkeeper.api.kv.options.RangeOption`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  141.           pKey.retain();
  142.           lKey.retain();
  143. >         if (null != option.endKey()) {
  144.               option.endKey().retain();
  145.           }

#193
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVAsyncStore.java:72: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVAsyncStore.get(...)` indirectly reads without synchronization from `this.readIOScheduler`. Potentially races with write in method `RocksdbKVAsyncStore.init(...)`.
 Reporting because this access may occur on a background thread.
  70.           }
  71.   
  72. >         return executeReadIO(() -> {
  73.               byte[] keyBytes = keyCoder.encode(key);
  74.               byte[] valBytes = localStore.get(keyBytes);

#194
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:76: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  74.    * A {@link PTable} implementation using simple grpc calls.
  75.    */
  76. > @Slf4j
  77.   public class PByteBufSimpleTableImpl
  78.       extends AbstractStub<PByteBufSimpleTableImpl>

#195
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:490: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getAccessControlManager()` reads without synchronization from `this.namespace`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  488.                       throw new IOException("Invalid Access Control List Root Path : " + aclRootPath);
  489.                   }
  490. >                 String zkRootPath = namespace.getPath() + "/" + aclRootPath;
  491.                   LOG.info("Creating zk based access control manager @ {} for {}",
  492.                           zkRootPath, namespace);

#196
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:493: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getAccessControlManager()` reads without synchronization from `this.conf`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  491.                   LOG.info("Creating zk based access control manager @ {} for {}",
  492.                           zkRootPath, namespace);
  493. >                 accessControlManager = new ZKAccessControlManager(conf, readerZKC,
  494.                           zkRootPath, scheduler);
  495.                   LOG.info("Created zk based access control manager @ {} for {}",

#197
bookkeeper-http/servlet-http-server/src/main/java/org/apache/bookkeeper/http/servlet/BookieServletHttpServer.java:40: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieServletHttpServer.getBookieHttpServiceProvider()` reads without synchronization from `servlet.BookieServletHttpServer.bookieHttpServiceProvider`. Potentially races with write in method `BookieServletHttpServer.setHttpServiceProvider(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  38.   
  39.     public static HttpServiceProvider getBookieHttpServiceProvider(){
  40. >     return bookieHttpServiceProvider;
  41.     }
  42.     /**

#198
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:442: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.getCtime()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  440.        */
  441.       public long getCtime() {
  442. >         return getLedgerMetadata().getCtime();
  443.       }
  444.   

#199
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:2046: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.getCurrentEnsemble()` reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2044.           // thing until metadata is immutable. At that point, current ensemble
  2045.           // becomes a property of the LedgerHandle itself.
  2046. >         return LedgerMetadataUtils.getCurrentEnsemble(versionedMetadata.getValue());
  2047.       }
  2048.   

#200
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:379: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.getCustomMetadata()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  377.        */
  378.       public Map<String, byte[]> getCustomMetadata() {
  379. >         return getLedgerMetadata().getCustomMetadata();
  380.       }
  381.   

#201
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java:144: warning: Thread Safety Violation
  Read/Write race. Non-private method `PendingAddOp.getEntryId()` reads without synchronization from `this.entryId`. Potentially races with write in method `PendingAddOp.submitCallback(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  142.   
  143.       long getEntryId() {
  144. >         return this.entryId;
  145.       }
  146.   

#202
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieImpl.java:1265: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieImpl.getExitCode()` reads without synchronization from `this.exitCode`. Potentially races with write in method `BookieImpl.start()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1263.        */
  1264.       public int getExitCode() {
  1265. >         return exitCode;
  1266.       }
  1267.   

#203
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java:242: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieServer.getExitCode()` reads without synchronization from `this.exitCode`. Potentially races with write in method `BookieServer.shutdown()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  240.   
  241.       public int getExitCode() {
  242. >         return exitCode;
  243.       }
  244.   

#204
stats/bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:507: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getFifteenMinuteRate()` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  505.       @Override
  506.       public double getFifteenMinuteRate() {
  507. >         return getRate(15 * 60);
  508.       }
  509.   

#205
stats/bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:512: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getFiveMinuteRate()` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  510.       @Override
  511.       public double getFiveMinuteRate() {
  512. >         return getRate(5 * 60);
  513.       }
  514.   

#206
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataBookieDriver.java:29: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataBookieDriver.getLayoutManager()` indirectly reads without synchronization from `this.layoutManager`. Potentially races with write in method `EtcdMetadataBookieDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  27.    * Etcd based metadata bookie driver.
  28.    */
  29. > @Slf4j
  30.   public class EtcdMetadataBookieDriver extends EtcdMetadataDriverBase implements MetadataBookieDriver {
  31.   

#207
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:101: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataDriverBase.getLayoutManager()` reads without synchronization from `this.layoutManager`. Potentially races with write in method `EtcdMetadataDriverBase.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
   99.   
  100.       public LayoutManager getLayoutManager() {
  101. >         return layoutManager;
  102.       }
  103.   

#208
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:109: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataDriverBase.getLedgerManagerFactory()` reads with synchronization from `this.conf`. Potentially races with unsynchronized write in method `EtcdMetadataDriverBase.initialize(...)`.
 Reporting because this access may occur on a background thread.
  107.               try {
  108.                   lmFactory = new EtcdLedgerManagerFactory();
  109. >                 lmFactory.initialize(conf, layoutManager, EtcdLedgerManagerFactory.VERSION);
  110.               } catch (IOException ioe) {
  111.                   throw new MetadataException(

#209
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:349: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.getLedgerMetadata()` reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  347.       @Override
  348.       public LedgerMetadata getLedgerMetadata() {
  349. >         return versionedMetadata.getValue();
  350.       }
  351.   

#210
bookkeeper-http/servlet-http-server/src/main/java/org/apache/bookkeeper/http/servlet/BookieServletHttpServer.java:46: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieServletHttpServer.getListenPort()` reads without synchronization from `servlet.BookieServletHttpServer.listenPort`. Potentially races with write in method `BookieServletHttpServer.setPort(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  44.      **/
  45.     public static int getListenPort(){
  46. >     return listenPort;
  47.     }
  48.   

#211
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:427: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getLogMetadataStore()` reads without synchronization from `this.metadataStore`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  425.       @Override
  426.       public LogMetadataStore getLogMetadataStore() {
  427. >         return metadataStore;
  428.       }
  429.   

#212
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:444: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getLogSegmentEntryStore(...)` indirectly reads without synchronization from `this.failureInjector`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  442.               return getWriterEntryStore();
  443.           } else {
  444. >             return getReaderEntryStore();
  445.           }
  446.       }

#213
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:442: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getLogSegmentEntryStore(...)` indirectly reads without synchronization from `this.allocator`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  440.       public LogSegmentEntryStore getLogSegmentEntryStore(Role role) {
  441.           if (Role.WRITER == role) {
  442. >             return getWriterEntryStore();
  443.           } else {
  444.               return getReaderEntryStore();

#214
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:433: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getLogStreamMetadataStore(...)` reads without synchronization from `this.writerStreamMetadataStore`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  431.       public LogStreamMetadataStore getLogStreamMetadataStore(Role role) {
  432.           if (Role.WRITER == role) {
  433. >             return writerStreamMetadataStore;
  434.           } else {
  435.               return readerStreamMetadataStore;

#215
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:435: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getLogStreamMetadataStore(...)` reads without synchronization from `this.readerStreamMetadataStore`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  433.               return writerStreamMetadataStore;
  434.           } else {
  435. >             return readerStreamMetadataStore;
  436.           }
  437.       }

#216
stats/bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:517: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getMeanRate()` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  515.       @Override
  516.       public double getMeanRate() {
  517. >         return getRate(Integer.MAX_VALUE);
  518.       }
  519.   

#217
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:522: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getMetadataAccessor(...)` reads without synchronization from `this.conf`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  520.           checkState();
  521.           streamName = validateAndNormalizeName(streamName);
  522. >         return new ZKMetadataAccessor(
  523.                   streamName,
  524.                   conf,

#218
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:520: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getMetadataAccessor(...)` indirectly reads without synchronization from `this.namespace`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  518.               throw new UnsupportedOperationException();
  519.           }
  520. >         checkState();
  521.           streamName = validateAndNormalizeName(streamName);
  522.           return new ZKMetadataAccessor(

#219
stats/bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:522: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getOneMinuteRate()` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  520.       @Override
  521.       public double getOneMinuteRate() {
  522. >         return getRate(60);
  523.       }
  524.   

#220
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLoggerAllocator.java:248: warning: Thread Safety Violation
  Read/Write race. Non-private method `EntryLoggerAllocator.getPreallocationFuture()` reads without synchronization from `this.preallocation`. Potentially races with write in method `EntryLoggerAllocator.createNewLog(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  246.        */
  247.       Future<BufferedLogChannel> getPreallocationFuture(){
  248. >         return preallocation;
  249.       }
  250.   }

#221
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:62: warning: Thread Safety Violation
  Read/Write race. Non-private method `RangeRouter.getRange(...)` indirectly reads without synchronization from `this.ranges`. Potentially races with write in method `RangeRouter.setRanges(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  60.        */
  61.       public long getRange(@Nullable K key) {
  62. >         return getRangeProperties(key).getRangeId();
  63.       }
  64.   

#222
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:68: warning: Interface Not Thread Safe
  Unprotected call to method `HashRouter.getRoutingKey(...)` of un-annotated interface `org.apache.bookkeeper.common.router.HashRouter`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because the current class is annotated `@ThreadSafe`.
  66.           long routingKey;
  67.           if (null != key) {
  68. >             routingKey = keyRouter.getRoutingKey(key);
  69.           } else {
  70.               routingKey = ThreadLocalRandom.current().nextLong();

#223
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:74: warning: Thread Safety Violation
  Read/Write race. Non-private method `RangeRouter.getRangeProperties(...)` reads without synchronization from `this.ranges`. Potentially races with write in method `RangeRouter.setRanges(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  72.           HashStreamRanges rs;
  73.           long stamp = lock.tryOptimisticRead();
  74. >         rs = ranges;
  75.           if (!lock.validate(stamp)) {
  76.               stamp = lock.readLock();

#224
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:92: warning: Thread Safety Violation
  Read/Write race. Non-private method `RangeRouter.getRanges()` reads without synchronization from `this.ranges`. Potentially races with write in method `RangeRouter.setRanges(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  90.           HashStreamRanges rs;
  91.           long stamp = lock.tryOptimisticRead();
  92. >         rs = ranges;
  93.           if (!lock.validate(stamp)) {
  94.               stamp = lock.readLock();

#225
stats/bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:486: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getRate(...)` reads without synchronization from `this.meter.[_].[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  484.               for (int i = t; i > secFrom; i--) {
  485.                   // no need to synchronize for reading (meter (int) is written atomically)
  486. >                 sum += meter[h][(timeWindow + i) % timeWindow];
  487.               }
  488.           }

#226
stats/bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:480: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getRate(...)` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  478.       public double getRate(int seconds) {
  479.           seconds = Math.min(seconds, timeWindow - 2);
  480. >         int t = getNow(getHash()) - 1; // start from last completed second
  481.           int secFrom = t - seconds;
  482.           long sum = 0;

#227
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:512: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.getRawBytes(...)` reads without synchronization from `this.dataCfHandle`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  510.       protected byte[] getRawBytes(K key, byte[] keyBytes) {
  511.           try {
  512. >             return this.db.get(dataCfHandle, keyBytes);
  513.           } catch (RocksDBException e) {
  514.               throw new StateStoreRuntimeException("Error while getting value for key " + key + " from store " + name, e);

#228
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java:166: warning: Thread Safety Violation
  Read/Write race. Non-private method `FileInfo.getSizeSinceLastWrite()` reads without synchronization from `this.sizeSinceLastWrite`. Potentially races with write in method `FileInfo.setFenced()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  164.   
  165.       public long getSizeSinceLastWrite() {
  166. >         return sizeSinceLastWrite;
  167.       }
  168.   

#229
stats/bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:539: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getSnapshot()` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getOneMinuteRate()`.
 Reporting because this access may occur on a background thread.
  537.   
  538.           // get time and trigger housekeeping
  539. >         int now = getNow(0) - 1; // start from last completed second
  540.           int secFrom = now - (timeWindow - 2);
  541.   

#230
stats/bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:563: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.getSnapshot()` reads without synchronization from `this.buckets.[_].[_]`. Potentially races with write in method `FastTimer.getOneMinuteRate()`.
 Reporting because this access may occur on a background thread.
  561.               // no need to synchronize for reading (buckets (int) is written atomically)
  562.               for (int b = 0; b < numBuckets; b++) {
  563. >                 buckets[b] += this.buckets[b][t];
  564.               }
  565.           }

#231
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:506: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getSubscriptionsStore(...)` reads without synchronization from `this.conf`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  504.           return new ZKSubscriptionsStore(
  505.                   writerZKC,
  506. >                 LogMetadataForReader.getSubscribersPath(namespace, streamName, conf.getUnpartitionedStreamName()));
  507.       }
  508.   

#232
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java:219: warning: Thread Safety Violation
  Read/Write race. Non-private method `BenchThroughputLatency.getThroughput()` reads without synchronization from `this.throughput`. Potentially races with write in method `BenchThroughputLatency.run()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  217.       long throughput = -1;
  218.       public long getThroughput() {
  219. >         return throughput;
  220.       }
  221.   

#233
microbenchmarks/src/main/java/org/apache/bookkeeper/stats/codahale/TimerBenchmark.java:109: warning: Thread Safety Violation
  Read/Write race. Non-private method `TimerBenchmark$MyState.getTime()` reads without synchronization from `codahale.TimerBenchmark$MyState.times`. Potentially races with write in method `TimerBenchmark$MyState.doSetup()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  107.   
  108.           public long getTime() {
  109. >             return times[(timeIdx++) % times.length];
  110.           }
  111.   

#234
microbenchmarks/src/main/java/org/apache/bookkeeper/stats/codahale/TimerBenchmark.java:105: warning: Thread Safety Violation
  Read/Write race. Non-private method `TimerBenchmark$MyState.getTimer()` reads without synchronization from `codahale.TimerBenchmark$MyState.timers`. Potentially races with write in method `TimerBenchmark$MyState.doSetup()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  103.   
  104.           public OpStatsLogger getTimer() {
  105. >             return timers[(timerIdx++) % timers.length];
  106.           }
  107.   

#235
stream/distributedlog/core/src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java:417: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKNamespaceDriver.getUri()` reads without synchronization from `this.namespace`. Potentially races with write in method `BKNamespaceDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  415.       @Override
  416.       public URI getUri() {
  417. >         return namespace;
  418.       }
  419.   

#236
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:353: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.getVersionedLedgerMetadata()` reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  351.   
  352.       Versioned<LedgerMetadata> getVersionedLedgerMetadata() {
  353. >         return versionedMetadata;
  354.       }
  355.   

#237
bookkeeper-server/src/main/java/org/apache/bookkeeper/discover/ZKRegistrationClient.java:180: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKRegistrationClient.getWatchReadOnlyBookiesTask()` reads without synchronization from `this.watchReadOnlyBookiesTask`. Potentially races with write in method `ZKRegistrationClient.watchReadOnlyBookies(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  178.       @Getter(AccessLevel.PACKAGE)
  179.       private WatchTask watchWritableBookiesTask = null;
  180. >     @Getter(AccessLevel.PACKAGE)
  181.       private WatchTask watchReadOnlyBookiesTask = null;
  182.       private final ConcurrentHashMap<BookieId, Versioned<BookieServiceInfo>> bookieServiceInfoCache =

#238
bookkeeper-server/src/main/java/org/apache/bookkeeper/discover/ZKRegistrationClient.java:178: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKRegistrationClient.getWatchWritableBookiesTask()` reads without synchronization from `this.watchWritableBookiesTask`. Potentially races with write in method `ZKRegistrationClient.watchWritableBookies(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  176.       private final ZooKeeper zk;
  177.       private final ScheduledExecutorService scheduler;
  178. >     @Getter(AccessLevel.PACKAGE)
  179.       private WatchTask watchWritableBookiesTask = null;
  180.       @Getter(AccessLevel.PACKAGE)

#239
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1907: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.handleBookieFailure(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1905.           }
  1906.           if (triggerLoop) {
  1907. >             ensembleChangeLoop(origEnsemble, toReplace);
  1908.           }
  1909.       }

#240
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:722: warning: Thread Safety Violation
  Unprotected write. Non-private method `TopologyAwareEnsemblePlacementPolicy.handleBookiesThatJoined(...)` mutates container `this.historyBookies` via call to `Map.put(...)` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  720.                   topology.add(node);
  721.                   knownBookies.put(addr, node);
  722. >                 historyBookies.put(addr, node);
  723.                   if (this.isWeighted) {
  724.                       this.bookieInfoMap.putIfAbsent(node, new BookieInfo());

#241
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:721: warning: Thread Safety Violation
  Unprotected write. Non-private method `TopologyAwareEnsemblePlacementPolicy.handleBookiesThatJoined(...)` mutates container `this.knownBookies` via call to `Map.put(...)` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  719.                   BookieNode node = createBookieNode(addr);
  720.                   topology.add(node);
  721. >                 knownBookies.put(addr, node);
  722.                   historyBookies.put(addr, node);
  723.                   if (this.isWeighted) {

#242
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:724: warning: Thread Safety Violation
  Read/Write race. Non-private method `TopologyAwareEnsemblePlacementPolicy.handleBookiesThatJoined(...)` reads without synchronization from `this.bookieInfoMap`. Potentially races with write in method `TopologyAwareEnsemblePlacementPolicy.updateBookieInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  722.                   historyBookies.put(addr, node);
  723.                   if (this.isWeighted) {
  724. >                     this.bookieInfoMap.putIfAbsent(node, new BookieInfo());
  725.                   }
  726.   

#243
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:691: warning: Thread Safety Violation
  Read/Write race. Non-private method `TopologyAwareEnsemblePlacementPolicy.handleBookiesThatLeft(...)` reads without synchronization from `this.bookieInfoMap`. Potentially races with write in method `TopologyAwareEnsemblePlacementPolicy.updateBookieInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  689.                       topology.remove(node);
  690.                       if (this.isWeighted) {
  691. >                         this.bookieInfoMap.remove(node);
  692.                       }
  693.   

#244
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java:687: warning: Thread Safety Violation
  Unprotected write. Non-private method `TopologyAwareEnsemblePlacementPolicy.handleBookiesThatLeft(...)` mutates container `this.knownBookies` via call to `Map.remove(...)` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  685.           for (BookieId addr : leftBookies) {
  686.               try {
  687. >                 BookieNode node = knownBookies.remove(addr);
  688.                   if (null != node) {
  689.                       topology.remove(node);

#245
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1764: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.handleUnrecoverableErrorDuringAdd(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1762.       // close the ledger and send fails to all the adds in the pipeline
  1763.       void handleUnrecoverableErrorDuringAdd(int rc) {
  1764. >         if (getLedgerMetadata().getState() == LedgerMetadata.State.IN_RECOVERY) {
  1765.               // we should not close ledger if ledger is recovery mode
  1766.               // otherwise we may lose entry.

#246
bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java:93: warning: Thread Safety Violation
  Read/Write race. Non-private method `InMemoryMetastoreTable$MetadataVersion.hashCode()` reads without synchronization from `this.version`. Potentially races with write in method `InMemoryMetastoreTable$MetadataVersion.incrementVersion()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  91.           @Override
  92.           public int hashCode() {
  93. >             return version;
  94.           }
  95.       }

#247
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java:423: warning: Thread Safety Violation
  Read/Write race. Non-private method `PendingAddOp.hashCode()` reads without synchronization from `this.entryId`. Potentially races with write in method `PendingAddOp.submitCallback(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  421.       @Override
  422.       public int hashCode() {
  423. >         return (int) entryId;
  424.       }
  425.   

#248
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:217: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  215.           pKey.retain();
  216.           lKey.retain();
  217. >         return retryUtils.execute(() -> fromListenableFuture(
  218.               ClientCalls.futureUnaryCall(
  219.                   getChannel(pKey).newCall(getIncrementMethod(), getCallOptions()),

#249
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:76: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  74.    * A {@link PTable} implementation using simple grpc calls.
  75.    */
  76. > @Slf4j
  77.   public class PByteBufSimpleTableImpl
  78.       extends AbstractStub<PByteBufSimpleTableImpl>

#250
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:68: warning: Thread Safety Violation
  Unprotected write. Non-private method `EtcdMetadataDriverBase.initialize(...)` writes to field `this.statsLogger` outside of synchronization.
 Reporting because this access may occur on a background thread.
  66.           throws MetadataException {
  67.           this.conf = conf;
  68. >         this.statsLogger = statsLogger;
  69.   
  70.           final String metadataServiceUriStr;

#251
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:85: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataDriverBase.initialize(...)` reads without synchronization from `this.keyPrefix`. Potentially races with write in method `EtcdMetadataDriverBase.initialize(...)`.
 Reporting because this access may occur on a background thread.
  83.               .collect(Collectors.toList());
  84.   
  85. >         log.info("Initializing etcd metadata driver : etcd endpoints = {}, key scope = {}",
  86.               etcdEndpoints, keyPrefix);
  87.   

#252
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:78: warning: Thread Safety Violation
  Unprotected write. Non-private method `EtcdMetadataDriverBase.initialize(...)` writes to field `this.keyPrefix` outside of synchronization.
 Reporting because this access may occur on a background thread.
  76.           }
  77.           ServiceURI serviceURI = ServiceURI.create(metadataServiceUriStr);
  78. >         this.keyPrefix = serviceURI.getServicePath();
  79.   
  80.           List<String> etcdEndpoints = Lists.newArrayList(serviceURI.getServiceHosts())

#253
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:94: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataDriverBase.initialize(...)` reads without synchronization from `this.client`. Potentially races with write in method `EtcdMetadataDriverBase.close()`.
 Reporting because this access may occur on a background thread.
  92.           }
  93.   
  94. >         this.layoutManager = new EtcdLayoutManager(
  95.               client,
  96.               keyPrefix

#254
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataDriverBase.java:67: warning: Thread Safety Violation
  Unprotected write. Non-private method `EtcdMetadataDriverBase.initialize(...)` writes to field `this.conf` outside of synchronization.
 Reporting because this access may occur on a background thread.
  65.       protected void initialize(AbstractConfiguration<?> conf, StatsLogger statsLogger)
  66.           throws MetadataException {
  67. >         this.conf = conf;
  68.           this.statsLogger = statsLogger;
  69.   

#255
metadata-drivers/etcd/src/main/java/org/apache/bookkeeper/metadata/etcd/EtcdMetadataClientDriver.java:53: warning: Thread Safety Violation
  Read/Write race. Non-private method `EtcdMetadataClientDriver.initialize(...)` indirectly reads without synchronization from `this.client`. Potentially races with write in method `EtcdMetadataClientDriver.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  51.                                              Optional<Object> ctx)
  52.               throws MetadataException {
  53. >         super.initialize(conf, statsLogger);
  54.           this.conf = conf;
  55.           this.statsLogger = statsLogger;

#256
stream/common/src/main/java/org/apache/bookkeeper/common/grpc/stats/MonitoringClientInterceptor.java:78: warning: Interface Not Thread Safe
  Unprotected call to method `StatsLogger.scope(...)` of un-annotated interface `org.apache.bookkeeper.stats.StatsLogger`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.ClientInterceptor` is annotated `@ThreadSafe`.
  76.       public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(
  77.           MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) {
  78. >         ClientStats stats = getMethodStats(method);
  79.           return new MonitoringClientCall<>(
  80.               next.newCall(method, callOptions),

#257
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/routing/RoutingHeaderProxyInterceptor.java:167: warning: Interface Not Thread Safe
  Unprotected call to method `Logger.isTraceEnabled()` of un-annotated interface `org.slf4j.Logger`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.ClientInterceptor` is annotated `@ThreadSafe`.
  165.                                                                  CallOptions callOptions,
  166.                                                                  Channel next) {
  167. >         if (log.isTraceEnabled()) {
  168.               log.trace("Intercepting method {} : req marshaller = {}, resp marshaller = {}",
  169.                   method.getFullMethodName(),

#258
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/container/StorageContainerClientInterceptor.java:53: warning: Interface Not Thread Safe
  Unprotected call to method `Logger.isTraceEnabled()` of un-annotated interface `org.slf4j.Logger`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.ClientInterceptor` is annotated `@ThreadSafe`.
  51.                                                                  CallOptions callOptions,
  52.                                                                  Channel next) {
  53. >         if (log.isTraceEnabled()) {
  54.               log.trace("Intercepting method {} : req marshaller = {}, resp marshaller = {}",
  55.                   method.getFullMethodName(),

#259
stream/common/src/main/java/org/apache/bookkeeper/common/grpc/stats/MonitoringServerInterceptor.java:82: warning: Interface Not Thread Safe
  Unprotected call to method `StatsLogger.scope(...)` of un-annotated interface `org.apache.bookkeeper.stats.StatsLogger`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.ServerInterceptor` is annotated `@ThreadSafe`.
  80.                                                         ServerCallHandler<ReqT, RespT> next) {
  81.           MethodDescriptor<ReqT, RespT> method = call.getMethodDescriptor();
  82. >         ServerStats stats = getMethodStats(method);
  83.           ServerCall<ReqT, RespT> monitoringCall = new MonitoringServerCall<>(call, stats);
  84.           return new MonitoringServerCallListener<>(

#260
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/directentrylogger/DirectReader.java:268: warning: Thread Safety Violation
  Read/Write race. Non-private method `DirectReader.isClosed()` reads without synchronization from `this.closed`. Potentially races with write in method `DirectReader.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  266.       @Override
  267.       public boolean isClosed() {
  268. >         return closed;
  269.       }
  270.   

#261
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java:158: warning: Thread Safety Violation
  Read/Write race. Non-private method `FileInfo.isClosed()` reads without synchronization from `this.isClosed`. Potentially races with write in method `FileInfo.close(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  156.   
  157.       public boolean isClosed() {
  158. >         return isClosed;
  159.       }
  160.   

#262
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:508: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.isHandleWritable()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  506.   
  507.       boolean isHandleWritable() {
  508. >         return !getLedgerMetadata().isClosed() && handleState == HandleState.OPEN;
  509.       }
  510.   

#263
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java:265: warning: Thread Safety Violation
  Read/Write race. Non-private method `AuditorElector.isRunning()` reads without synchronization from `this.auditor`. Potentially races with write in method `AuditorElector.shutdown()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  263.        */
  264.       public boolean isRunning() {
  265. >         if (auditor != null) {
  266.               return auditor.isRunning();
  267.           }

#264
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/TransientLedgerInfo.java:142: warning: Thread Safety Violation
  Read/Write race. Non-private method `TransientLedgerInfo.isStale()` reads without synchronization from `this.lastAccessed`. Potentially races with write in method `TransientLedgerInfo.setLastAddConfirmed(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  140.       boolean isStale() {
  141.           return (lastAccessed + TimeUnit.MINUTES.toMillis(LEDGER_INFO_CACHING_TIME_MINUTES)) < System
  142. >                 .currentTimeMillis();
  143.       }
  144.   

#265
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClientImpl.java:629: warning: Thread Safety Violation
  Unprotected write. Non-private method `BookieClientImpl.main(...)` indirectly mutates container `util.ReflectionUtils.constructorCache` via call to `Map.put(...)` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  627.           ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(
  628.                   new DefaultThreadFactory("BookKeeperClientScheduler"));
  629. >         BookieClientImpl bc = new BookieClientImpl(new ClientConfiguration(), eventLoopGroup,
  630.                   null, executor, scheduler, NullStatsLogger.INSTANCE, BookieSocketAddress.LEGACY_BOOKIEID_RESOLVER);
  631.           BookieId addr = new BookieSocketAddress(args[0], Integer.parseInt(args[1])).toBookieId();

#266
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/directentrylogger/DirectReader.java:273: warning: Thread Safety Violation
  Read/Write race. Non-private method `DirectReader.maxOffset()` reads without synchronization from `this.maxOffset`. Potentially races with write in method `DirectReader.readLongAt(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  271.       @Override
  272.       public long maxOffset() {
  273. >         return maxOffset;
  274.       }
  275.   

#267
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java:157: warning: Thread Safety Violation
  Read/Write race. Non-private method `PendingAddOp.maybeTimeout()` reads without synchronization from `this.clientCtx`. Potentially races with write in method `PendingAddOp.submitCallback(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  155.   
  156.       boolean maybeTimeout() {
  157. >         if (MathUtils.elapsedNanos(requestTimeNanos) >= clientCtx.getConf().addEntryQuorumTimeoutNanos) {
  158.               timeoutQuorumWait();
  159.               return true;

#268
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java:81: warning: Thread Safety Violation
  Read/Write race. Non-private method `DefaultEnsemblePlacementPolicy.newEnsemble(...)` reads without synchronization from `this.isWeighted`. Potentially races with write in method `DefaultEnsemblePlacementPolicy.initialize(...)`.
 Reporting because this access may occur on a background thread.
  79.           }
  80.   
  81. >         if (isWeighted) {
  82.               // hold the readlock while selecting bookies. We don't want the list of bookies
  83.               // changing while we are creating the ensemble

#269
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RegionAwareEnsemblePlacementPolicy.java:294: warning: Thread Safety Violation
  Read/Write race. Non-private method `RegionAwareEnsemblePlacementPolicy.newEnsemble(...)` reads without synchronization from `this.disableDurabilityFeature`. Potentially races with write in method `RegionAwareEnsemblePlacementPolicy.initialize(...)`.
 Reporting because this access may occur on a background thread.
  292.               throws BKException.BKNotEnoughBookiesException {
  293.   
  294. >         int effectiveMinRegionsForDurability = disableDurabilityFeature.isAvailable() ? 1 : minRegionsForDurability;
  295.   
  296.           // All of these conditions indicate bad configuration

#270
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:337: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZoneawareEnsemblePlacementPolicyImpl.newEnsemble(...)` reads without synchronization from `this.enforceStrictZoneawarePlacement`. Potentially races with write in method `ZoneawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  335.               int ackQuorumSize, Map<String, byte[]> customMetadata, Set<BookieId> excludeBookies)
  336.               throws BKNotEnoughBookiesException {
  337. >         if (enforceStrictZoneawarePlacement) {
  338.               if (ensembleSize % writeQuorumSize != 0) {
  339.                   /*

#271
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:391: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZoneawareEnsemblePlacementPolicyImpl.newEnsemble(...)` reads without synchronization from `this.desiredNumZonesPerWriteQuorum`. Potentially races with write in method `ZoneawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  389.               }
  390.           }
  391. >         int desiredNumZonesPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, desiredNumZonesPerWriteQuorum);
  392.           List<BookieId> newEnsemble = new ArrayList<BookieId>(
  393.                   Collections.nCopies(ensembleSize, null));

#272
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:367: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZoneawareEnsemblePlacementPolicyImpl.newEnsemble(...)` reads without synchronization from `this.minNumZonesPerWriteQuorum`. Potentially races with write in method `ZoneawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  365.                           + " writeQuorumSize When StrictZoneawarePlacement is enabled");
  366.               }
  367. >             if (writeQuorumSize <= minNumZonesPerWriteQuorum) {
  368.                   /*
  369.                    * if we allow writeQuorumSize <= minNumZonesPerWriteQuorum,

#273
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/store/MVCCStoreFactoryImpl.java:196: warning: Thread Safety Violation
  Read/Write race. Non-private method `MVCCStoreFactoryImpl.newStore(...)` reads without synchronization from `this.checkpointStore`. Potentially races with write in method `MVCCStoreFactoryImpl.newStore(...)`.
 Reporting because this access may occur on a background thread.
  194.               normalizedName(rangeId));
  195.   
  196. >         if (null == checkpointStore) {
  197.               checkpointStore = checkpointStoreSupplier.get();
  198.           }

#274
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/store/MVCCStoreFactoryImpl.java:197: warning: Thread Safety Violation
  Unprotected write. Non-private method `MVCCStoreFactoryImpl.newStore(...)` writes to field `this.checkpointStore` outside of synchronization.
 Reporting because this access may occur on a background thread.
  195.   
  196.           if (null == checkpointStore) {
  197. >             checkpointStore = checkpointStoreSupplier.get();
  198.           }
  199.   

#275
bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java:523: warning: Thread Safety Violation
  Read/Write race. Non-private method `TLSContextFactory.newTLSHandler()` indirectly reads without synchronization from `this.allocator`. Potentially races with write in method `TLSContextFactory.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  521.       @Override
  522.       public SslHandler newTLSHandler() {
  523. >         return this.newTLSHandler(null, -1);
  524.       }
  525.   

#276
bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java:530: warning: Thread Safety Violation
  Read/Write race. Non-private method `TLSContextFactory.newTLSHandler(...)` reads without synchronization from `this.protocols`. Potentially races with write in method `TLSContextFactory.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  528.           SslHandler sslHandler = getSSLContext().newHandler(allocator, peer, port);
  529.   
  530. >         if (protocols != null && protocols.length != 0) {
  531.               sslHandler.engine().setEnabledProtocols(protocols);
  532.           }

#277
bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java:537: warning: Thread Safety Violation
  Read/Write race. Non-private method `TLSContextFactory.newTLSHandler(...)` reads without synchronization from `this.ciphers`. Potentially races with write in method `TLSContextFactory.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  535.           }
  536.   
  537. >         if (ciphers != null && ciphers.length != 0) {
  538.               sslHandler.engine().setEnabledCipherSuites(ciphers);
  539.           }

#278
bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java:544: warning: Thread Safety Violation
  Read/Write race. Non-private method `TLSContextFactory.newTLSHandler(...)` reads without synchronization from `this.config`. Potentially races with write in method `TLSContextFactory.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  542.           }
  543.   
  544. >         if (type == NodeType.Client && ((ClientConfiguration) config).getHostnameVerificationEnabled()) {
  545.               SSLParameters sslParameters = sslHandler.engine().getSSLParameters();
  546.               sslParameters.setEndpointIdentificationAlgorithm("HTTPS");

#279
bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java:528: warning: Thread Safety Violation
  Read/Write race. Non-private method `TLSContextFactory.newTLSHandler(...)` reads without synchronization from `this.allocator`. Potentially races with write in method `TLSContextFactory.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  526.       @Override
  527.       public SslHandler newTLSHandler(String peer, int port) {
  528. >         SslHandler sslHandler = getSSLContext().newHandler(allocator, peer, port);
  529.   
  530.           if (protocols != null && protocols.length != 0) {

#280
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java:187: warning: Thread Safety Violation
  Unprotected write. Non-private method `LedgerRecoveryOp.onEntryComplete(...)` indirectly writes to field `entry.data` outside of synchronization.
 Reporting because this access may occur on a background thread.
  185.           if (!promise.isDone() && !readDone && rc == BKException.Code.OK) {
  186.               readCount.incrementAndGet();
  187. >             byte[] data = entry.getEntry();
  188.   
  189.               /*

#281
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java:385: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieInfoReader.onExit()` reads without synchronization from `this.errorCnt`. Potentially races with write in method `BookieInfoReader.getReadWriteBookieInfo()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  383.       void onExit() {
  384.           bk.placementPolicy.updateBookieInfo(bookieInfoMap.getBookieMap());
  385. >         if (errorCnt > 0) {
  386.               if (LOG.isInfoEnabled()) {
  387.                   LOG.info("Rescheduling in {}s due to errors", conf.getGetBookieInfoIntervalSeconds());

#282
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java:391: warning: Thread Safety Violation
  Unprotected write. Non-private method `BookieInfoReader.onExit()` indirectly writes to field `this.instanceState.running` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  389.               instanceState.tryStartPartial();
  390.               submitTaskWithDelay(conf.getGetBookieInfoRetryIntervalSeconds());
  391. >         } else if (instanceState.completeUnlessQueued()) {
  392.               if (LOG.isInfoEnabled()) {
  393.                   LOG.info("Rescheduling, another scan is pending");

#283
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java:389: warning: Thread Safety Violation
  Unprotected write. Non-private method `BookieInfoReader.onExit()` indirectly writes to field `this.instanceState.queuedType` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  387.                   LOG.info("Rescheduling in {}s due to errors", conf.getGetBookieInfoIntervalSeconds());
  388.               }
  389. >             instanceState.tryStartPartial();
  390.               submitTaskWithDelay(conf.getGetBookieInfoRetryIntervalSeconds());
  391.           } else if (instanceState.completeUnlessQueued()) {

#284
stream/distributedlog/core/src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java:246: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKDistributedLock$3.onSuccess(...)` writes to field `this.this$0.lockWaiter` outside of synchronization.
 Reporting because this access may occur on a background thread.
  244.                       }
  245.                       tryLockFuture = null;
  246. >                     lockWaiter = waiter;
  247.                       waitForAcquire(waiter, acquirePromise);
  248.                   }

#285
stream/distributedlog/core/src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java:245: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKDistributedLock$3.onSuccess(...)` writes to field `this.this$0.tryLockFuture` outside of synchronization.
 Reporting because this access may occur on a background thread.
  243.                           }
  244.                       }
  245. >                     tryLockFuture = null;
  246.                       lockWaiter = waiter;
  247.                       waitForAcquire(waiter, acquirePromise);

#286
stream/distributedlog/core/src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java:200: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKDistributedLock$2.onSuccess(...)` indirectly writes to field `this.this$0.tryLockFuture` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  198.           lockFactory
  199.               .createLock(lockPath, lockContext)
  200. >             .whenCompleteAsync(new FutureEventListener<SessionLock>() {
  201.               @Override
  202.               public void onSuccess(SessionLock lock) {

#287
stream/distributedlog/core/src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java:232: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKDistributedLock$3.onSuccess(...)` indirectly writes to field `this.this$0.lockWaiter` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  230.           tryLockFuture = lock.asyncTryLock(lockTimeout, TimeUnit.MILLISECONDS);
  231.           tryLockFuture.whenCompleteAsync(
  232. >             new FutureEventListener<LockWaiter>() {
  233.                   @Override
  234.                   public void onSuccess(LockWaiter waiter) {

#288
stream/distributedlog/core/src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java:214: warning: Thread Safety Violation
  Unprotected write. Non-private method `ZKDistributedLock$2.onSuccess(...)` indirectly writes to field `this.this$0.tryLockFuture` outside of synchronization.
 Reporting because this access may occur on a background thread.
  212.                       internalLock.setLockListener(ZKDistributedLock.this);
  213.                   }
  214. >                 asyncTryLock(lock, acquirePromise, lockTimeout);
  215.               }
  216.   

#289
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:359: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openLocalDB(...)` indirectly reads without synchronization from `this.ttlSeconds`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  357.                                                                     ColumnFamilyOptions cfOpts)
  358.           throws StateStoreException {
  359. >         return openRocksdb(dir, options, cfOpts);
  360.       }
  361.   

#290
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:365: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.ttlSeconds`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  363.           File dir, DBOptions options, ColumnFamilyOptions cfOpts)
  364.           throws StateStoreException {
  365. >         final boolean haveTtl = ttlSeconds != 0;
  366.           final ColumnFamilyDescriptor metaDesc = new ColumnFamilyDescriptor(METADATA_CF, cfOpts);
  367.           final ColumnFamilyDescriptor dataDesc = new ColumnFamilyDescriptor(haveTtl ? DATA_TTL_CF : DATA_CF, cfOpts);

#291
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:338: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.writeOpts` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  336.           // initialize the write options
  337.   
  338. >         writeOpts = new WriteOptions();
  339.           writeOpts.setDisableWAL(true); // disable wal, since the source of truth will be on distributedlog
  340.   

#292
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:351: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.metaCfHandle` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  349.           Pair<RocksDB, List<ColumnFamilyHandle>> dbPair = openLocalDB(dbDir, dbOpts, cfOpts);
  350.           this.db = dbPair.getLeft();
  351. >         this.metaCfHandle = dbPair.getRight().get(0);
  352.           this.dataCfHandle = dbPair.getRight().get(1);
  353.       }

#293
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:349: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.dbDir`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  347.   
  348.           this.dbDir = spec.getLocalStateStoreDir();
  349. >         Pair<RocksDB, List<ColumnFamilyHandle>> dbPair = openLocalDB(dbDir, dbOpts, cfOpts);
  350.           this.db = dbPair.getLeft();
  351.           this.metaCfHandle = dbPair.getRight().get(0);

#294
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:322: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.dbOpts` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  320.           tableConfig.setChecksumType(DEFAULT_CHECKSUM_TYPE);
  321.   
  322. >         dbOpts = new DBOptions();
  323.           dbOpts.setCreateIfMissing(true);
  324.           dbOpts.setErrorIfExists(false);

#295
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:352: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.dataCfHandle` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  350.           this.db = dbPair.getLeft();
  351.           this.metaCfHandle = dbPair.getRight().get(0);
  352. >         this.dataCfHandle = dbPair.getRight().get(1);
  353.       }
  354.   

#296
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:350: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.db` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  348.           this.dbDir = spec.getLocalStateStoreDir();
  349.           Pair<RocksDB, List<ColumnFamilyHandle>> dbPair = openLocalDB(dbDir, dbOpts, cfOpts);
  350. >         this.db = dbPair.getLeft();
  351.           this.metaCfHandle = dbPair.getRight().get(0);
  352.           this.dataCfHandle = dbPair.getRight().get(1);

#297
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:348: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.dbDir` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  346.           // open the rocksdb
  347.   
  348. >         this.dbDir = spec.getLocalStateStoreDir();
  349.           Pair<RocksDB, List<ColumnFamilyHandle>> dbPair = openLocalDB(dbDir, dbOpts, cfOpts);
  350.           this.db = dbPair.getLeft();

#298
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:323: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.dbOpts`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  321.   
  322.           dbOpts = new DBOptions();
  323. >         dbOpts.setCreateIfMissing(true);
  324.           dbOpts.setErrorIfExists(false);
  325.           dbOpts.setInfoLogLevel(DEFAULT_LOG_LEVEL);

#299
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:344: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.flushOpts`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  342.   
  343.           flushOpts = new FlushOptions();
  344. >         flushOpts.setWaitForFlush(true);
  345.   
  346.           // open the rocksdb

#300
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:343: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.flushOpts` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  341.           // initialize the flush options
  342.   
  343. >         flushOpts = new FlushOptions();
  344.           flushOpts.setWaitForFlush(true);
  345.   

#301
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:330: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.cfOpts`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  328.   
  329.           cfOpts = new ColumnFamilyOptions();
  330. >         cfOpts.setTableFormatConfig(tableConfig);
  331.           cfOpts.setWriteBufferSize(WRITE_BUFFER_SIZE);
  332.           cfOpts.setCompressionType(DEFAULT_COMPRESSION_TYPE);

#302
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:339: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.openRocksdb(...)` reads without synchronization from `this.writeOpts`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  337.   
  338.           writeOpts = new WriteOptions();
  339. >         writeOpts.setDisableWAL(true); // disable wal, since the source of truth will be on distributedlog
  340.   
  341.           // initialize the flush options

#303
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:329: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.openRocksdb(...)` writes to field `this.cfOpts` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  327.           dbOpts.setCreateMissingColumnFamilies(true);
  328.   
  329. >         cfOpts = new ColumnFamilyOptions();
  330.           cfOpts.setTableFormatConfig(tableConfig);
  331.           cfOpts.setWriteBufferSize(WRITE_BUFFER_SIZE);

#304
stream/storage/impl/src/main/java/org/apache/bookkeeper/stream/storage/impl/store/MVCCStoreFactoryImpl.java:164: warning: Thread Safety Violation
  Unprotected write. Non-private method `MVCCStoreFactoryImpl.openStore(...)` indirectly writes to field `this.checkpointStore` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  162.           MVCCAsyncStore<byte[], byte[]> store = getStore(scId, streamId, rangeId);
  163.           if (null == store) {
  164. >             return newStore(scId, streamId, rangeId, ttlSeconds);
  165.           } else {
  166.               return FutureUtils.value(store);

#305
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java:138: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerChecker$LedgerFragmentCallback.operationComplete(...)` reads without synchronization from container `this.badBookies` via call to `Map.keySet()`. Potentially races with write in method `LedgerChecker$LedgerFragmentCallback.operationComplete(...)`.
 Reporting because this access may occur on a background thread.
  136.                       }
  137.                       cb.operationComplete(rcToReturn,
  138. >                             fragment.subset(badBookies.keySet()));
  139.                   }
  140.               }

#306
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java:98: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerChecker$LedgerFragmentCallback.operationComplete(...)` indirectly reads without synchronization from container `this.badBookies` via call to `Map.keySet()`. Potentially races with write in method `LedgerChecker$LedgerFragmentCallback.operationComplete(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
   96.        * This will collect the bad bookies inside a ledger fragment.
   97.        */
   98. >     private static class LedgerFragmentCallback implements GenericCallback<LedgerFragment> {
   99.   
  100.           private final LedgerFragment fragment;

#307
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchReadThroughputLatency.java:213: warning: Thread Safety Violation
  Unprotected write. Non-private method `BenchReadThroughputLatency$2.process(...)` indirectly mutates container `util.ReflectionUtils.constructorCache` via call to `Map.put(...)` outside of synchronization.
 Reporting because this access may occur on a background thread.
  211.                               if (event.getType() == Event.EventType.NodeCreated
  212.                                          && event.getPath().equals(nodepath)) {
  213. >                                 readLedger(conf, ledger.get(), passwd);
  214.                                   shutdownLatch.countDown();
  215.                               } else if (event.getType() == Event.EventType.NodeChildrenChanged) {

#308
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:170: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  168.           lKey.retain();
  169.           value.retain();
  170. >         return retryUtils.execute(() -> fromListenableFuture(
  171.               ClientCalls.futureUnaryCall(
  172.                   getChannel(pKey).newCall(getPutMethod(), getCallOptions()),

#309
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVAsyncStore.java:97: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVAsyncStore.put(...)` reads without synchronization from `this.writeIOScheduler`. Potentially races with write in method `RocksdbKVAsyncStore.init(...)`.
 Reporting because this access may occur on a background thread.
  95.               .setPutReq(KVUtils.newPutRequest(keyBytes, valBytes))
  96.               .build();
  97. >         return writeCommandReturnTxId(command).thenApplyAsync((revision) -> {
  98.               ByteBuf serializedBuf = KVUtils.serialize(valBytes, revision);
  99.               try {

#310
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVAsyncStore.java:91: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVAsyncStore.put(...)` reads without synchronization from `this.keyCoder`. Potentially races with write in method `RocksdbKVAsyncStore.init(...)`.
 Reporting because this access may occur on a background thread.
  89.           }
  90.   
  91. >         byte[] keyBytes = keyCoder.encode(key);
  92.           byte[] valBytes = valCoder.encode(value);
  93.   

#311
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVAsyncStore.java:92: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVAsyncStore.put(...)` reads without synchronization from `this.valCoder`. Potentially races with write in method `RocksdbKVAsyncStore.init(...)`.
 Reporting because this access may occur on a background thread.
  90.   
  91.           byte[] keyBytes = keyCoder.encode(key);
  92. >         byte[] valBytes = valCoder.encode(value);
  93.   
  94.           Command command = Command.newBuilder()

#312
stream/clients/java/kv/src/main/java/org/apache/bookkeeper/clients/impl/kv/PByteBufSimpleTableImpl.java:76: warning: Interface Not Thread Safe
  Unprotected call to method `Backoff$Policy.toBackoffs()` of un-annotated interface `org.apache.bookkeeper.common.util.Backoff$Policy`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.stub.AbstractStub` is annotated `@ThreadSafe`.
  74.    * A {@link PTable} implementation using simple grpc calls.
  75.    */
  76. > @Slf4j
  77.   public class PByteBufSimpleTableImpl
  78.       extends AbstractStub<PByteBufSimpleTableImpl>

#313
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:757: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readAsync(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  755.           }
  756.   
  757. >         return readEntriesInternalAsync(firstEntry, lastEntry, false);
  758.       }
  759.   

#314
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/directentrylogger/DirectReader.java:213: warning: Thread Safety Violation
  Read/Write race. Non-private method `DirectReader.readBlock(...)` indirectly reads without synchronization from `this.nativeBuffer.byteBuffer`. Potentially races with write in method `DirectReader.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  211.               while (true) {
  212.                   long readSize = blockSize - bufferOffset;
  213. >                 long pointerWithOffset = nativeBuffer.pointer(bufferOffset, readSize);
  214.                   bytesRead = nativeIO.pread(fd, pointerWithOffset,
  215.                                              readSize,

#315
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/directentrylogger/DirectReader.java:199: warning: Thread Safety Violation
  Read/Write race. Non-private method `DirectReader.readBlock(...)` reads without synchronization from `this.maxOffset`. Potentially races with write in method `DirectReader.readLongAt(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  197.           final long blockStart = offset & ~(blockSize - 1);
  198.   
  199. >         if (blockStart + blockSize > maxOffset) {
  200.               // Check if there's new data in the file
  201.               refreshMaxOffset();

#316
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/directentrylogger/DirectReader.java:245: warning: Thread Safety Violation
  Unprotected write. Non-private method `DirectReader.readBlock(...)` writes to field `this.currentBlock` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  243.           }
  244.           readBlockStats.registerSuccessfulEvent(System.nanoTime() - startNs, TimeUnit.NANOSECONDS);
  245. >         currentBlock = blockStart;
  246.           currentBlockEnd = blockStart + Math.min(blockSize, bytesAvailable);
  247.       }

#317
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/directentrylogger/DirectReader.java:246: warning: Thread Safety Violation
  Unprotected write. Non-private method `DirectReader.readBlock(...)` writes to field `this.currentBlockEnd` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  244.           readBlockStats.registerSuccessfulEvent(System.nanoTime() - startNs, TimeUnit.NANOSECONDS);
  245.           currentBlock = blockStart;
  246. >         currentBlockEnd = blockStart + Math.min(blockSize, bytesAvailable);
  247.       }
  248.   

#318
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:636: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readEntries(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  634.           CompletableFuture<Enumeration<LedgerEntry>> result = new CompletableFuture<>();
  635.   
  636. >         asyncReadEntries(firstEntry, lastEntry, new SyncReadCallback(result), null);
  637.   
  638.           return SyncCallbackUtils.waitForResult(result);

#319
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:882: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readEntriesInternalAsync(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  880.                   DistributionSchedule.WriteSet ws = distributionSchedule.getWriteSet(firstEntry);
  881.                   try {
  882. >                     if (!waitForWritable(ws, ws.size() - 1, clientCtx.getConf().waitForWriteSetMs)) {
  883.                           op.allowFailFastOnUnwritableChannel();
  884.                       }

#320
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1750: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readExplicitLastConfirmed()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1748.       public long readExplicitLastConfirmed() throws InterruptedException, BKException {
  1749.           LastConfirmedCtx ctx = new LastConfirmedCtx();
  1750. >         asyncReadExplicitLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);
  1751.           synchronized (ctx) {
  1752.               while (!ctx.ready()) {

#321
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1506: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readLastAddConfirmedAndEntryAsync(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1504.                                                                                         boolean parallel) {
  1505.           FutureReadLastConfirmedAndEntry result = new FutureReadLastConfirmedAndEntry();
  1506. >         asyncReadLastConfirmedAndEntry(entryId, timeOutInMillis, parallel, result, null);
  1507.           return result;
  1508.       }

#322
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1494: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readLastAddConfirmedAsync()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1492.       public CompletableFuture<Long> readLastAddConfirmedAsync() {
  1493.           FutureReadLastConfirmed result = new FutureReadLastConfirmed();
  1494. >         asyncReadLastConfirmed(result, null);
  1495.           return result;
  1496.       }

#323
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1641: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readLastConfirmed()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1639.               throws InterruptedException, BKException {
  1640.           LastConfirmedCtx ctx = new LastConfirmedCtx();
  1641. >         asyncReadLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);
  1642.           synchronized (ctx) {
  1643.               while (!ctx.ready()) {

#324
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java:130: warning: Thread Safety Violation
  Unprotected write. Non-private method `LedgerRecoveryOp$1.readLastConfirmedDataComplete(...)` writes to field `this.this$0.metadataForRecovery` outside of synchronization.
 Reporting because this access may occur on a background thread.
  128.                               // keep a copy of ledger metadata before proceeding
  129.                               // ledger recovery
  130. >                             metadataForRecovery = lh.getLedgerMetadata();
  131.                               doRecoveryRead();
  132.                           } else if (rc == BKException.Code.TimeoutException) {

#325
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:855: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readLastEntry()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  853.           } else {
  854.               CompletableFuture<Enumeration<LedgerEntry>> result = new CompletableFuture<>();
  855. >             asyncReadEntries(lastEntryId, lastEntryId, new SyncReadCallback(result), null);
  856.   
  857.               return SyncCallbackUtils.waitForResult(result).nextElement();

#326
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:792: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readUnconfirmedAsync(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  790.           }
  791.   
  792. >         return readEntriesInternalAsync(firstEntry, lastEntry, false);
  793.       }
  794.   

#327
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:659: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.readUnconfirmedEntries(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  657.           CompletableFuture<Enumeration<LedgerEntry>> result = new CompletableFuture<>();
  658.   
  659. >         asyncReadUnconfirmedEntries(firstEntry, lastEntry, new SyncReadCallback(result), null);
  660.   
  661.           return SyncCallbackUtils.waitForResult(result);

#328
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:271: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.recordReadErrorOnBookie(...)` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  269.               // This will be idempotent when we have multiple read errors on the
  270.               // same bookie. The net result is that we just go to the next bookie
  271. >             stickyBookieIndex = clientCtx.getPlacementPolicy().getStickyReadBookieIndex(getLedgerMetadata(),
  272.                       Optional.of(bookieIndex));
  273.           }

#329
bookkeeper-common/src/main/java/org/apache/bookkeeper/common/collections/BatchedArrayBlockingQueue.java:289: warning: Thread Safety Violation
  Read/Write race. Non-private method `BatchedArrayBlockingQueue.remainingCapacity()` reads without synchronization from `this.size`. Potentially races with write in method `BatchedArrayBlockingQueue.put(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  287.       @Override
  288.       public int remainingCapacity() {
  289. >         return capacity - size;
  290.       }
  291.   

#330
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ZoneawareEnsemblePlacementPolicyImpl.java:420: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZoneawareEnsemblePlacementPolicyImpl.replaceBookie(...)` reads without synchronization from `this.desiredNumZonesPerWriteQuorum`. Potentially races with write in method `ZoneawareEnsemblePlacementPolicyImpl.initialize(...)`.
 Reporting because this access may occur on a background thread.
  418.               throws BKNotEnoughBookiesException {
  419.           int bookieToReplaceIndex = currentEnsemble.indexOf(bookieToReplace);
  420. >         int desiredNumZonesPerWriteQuorumForThisEnsemble = (writeQuorumSize < desiredNumZonesPerWriteQuorum)
  421.                   ? writeQuorumSize : desiredNumZonesPerWriteQuorum;
  422.           List<BookieId> newEnsemble = new ArrayList<BookieId>(currentEnsemble);

#331
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java:206: warning: Thread Safety Violation
  Unprotected write. Non-private method `BenchThroughputLatency.run()` writes to field `this.throughput` outside of synchronization.
 Reporting because this access may occur on a background thread.
  204.               duration = System.currentTimeMillis() - start;
  205.           }
  206. >         throughput = sent * 1000 / getDuration();
  207.   
  208.           reporter.interrupt();

#332
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java:144: warning: Thread Safety Violation
  Unprotected write. Non-private method `BenchThroughputLatency.run()` writes to field `this.previous` outside of synchronization.
 Reporting because this access may occur on a background thread.
  142.       public void run() {
  143.           LOG.info("Running...");
  144. >         long start = previous = System.currentTimeMillis();
  145.   
  146.           int sent = 0;

#333
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java:184: warning: Thread Safety Violation
  Read/Write race. Non-private method `BenchThroughputLatency.run()` reads without synchronization from `this.bytes`. Potentially races with write in method `BenchThroughputLatency.setEntryData(...)`.
 Reporting because this access may occur on a background thread.
  182.               } else {
  183.                   long nanoTime = System.nanoTime();
  184. >                 lh[index].asyncAddEntry(bytes, this, new Context(sent, nanoTime));
  185.                   counter.incrementAndGet();
  186.               }

#334
bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchThroughputLatency.java:214: warning: Thread Safety Violation
  Read/Write race. Non-private method `BenchThroughputLatency.run()` reads without synchronization from `this.throughput`. Potentially races with write in method `BenchThroughputLatency.run()`.
 Reporting because this access may occur on a background thread.
  212.               Thread.currentThread().interrupt();
  213.           }
  214. >         LOG.info("Finished processing in ms: " + getDuration() + " tp = " + throughput);
  215.       }
  216.   

#335
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java:73: warning: Thread Safety Violation
  Read/Write race. Non-private method `ReadOnlyLedgerHandle$MetadataUpdater.run()` indirectly reads without synchronization from `this.this$0.versionedMetadata`. Potentially races with write in method `ReadOnlyLedgerHandle$MetadataUpdater.run()`.
 Reporting because this access may occur on a background thread.
  71.           public void run() {
  72.               while (true) {
  73. >                 Versioned<LedgerMetadata> currentMetadata = getVersionedLedgerMetadata();
  74.                   Version.Occurred occurred = currentMetadata.getVersion().compare(newMetadata.getVersion());
  75.                   if (Version.Occurred.BEFORE == occurred) {

#336
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1811: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.sendAddSuccessCallbacks()` reads without synchronization from `this.changingEnsemble`. Potentially races with write in method `LedgerHandle.maybeHandleDelayedWriteBookieFailure()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1809.           PendingAddOp pendingAddOp;
  1810.   
  1811. >         while ((pendingAddOp = pendingAddOps.peek()) != null
  1812.                  && !changingEnsemble) {
  1813.               if (!pendingAddOp.completed) {

#337
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java:390: warning: Thread Safety Violation
  Read/Write race. Non-private method `PendingAddOp.sendAddSuccessCallbacks()` reads without synchronization from `this.lh`. Potentially races with write in method `PendingAddOp.submitCallback(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  388.   
  389.       void sendAddSuccessCallbacks() {
  390. >         lh.sendAddSuccessCallbacks();
  391.       }
  392.   

#338
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java:114: warning: Thread Safety Violation
  Read/Write race. Non-private method `PacketProcessorBase.sendResponse(...)` reads without synchronization from `this.enqueueNanos`. Potentially races with write in method `PacketProcessorBase.reset()`.
 Reporting because this access may occur on a background thread.
  112.                   requestProcessor.getRequestStats().getChannelWriteStats()
  113.                       .registerFailedEvent(MathUtils.elapsedNanos(writeNanos), TimeUnit.NANOSECONDS);
  114. >                 statsLogger.registerFailedEvent(MathUtils.elapsedNanos(enqueueNanos), TimeUnit.NANOSECONDS);
  115.                   if (response instanceof BookieProtocol.Response) {
  116.                       ((BookieProtocol.Response) response).release();

#339
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java:112: warning: Thread Safety Violation
  Read/Write race. Non-private method `PacketProcessorBase.sendResponse(...)` reads without synchronization from `this.requestProcessor`. Potentially races with write in method `PacketProcessorBase.reset()`.
 Reporting because this access may occur on a background thread.
  110.                   logger.warn("cannot write response to non-writable channel {} for request {}", channel,
  111.                       StringUtils.requestToString(request));
  112. >                 requestProcessor.getRequestStats().getChannelWriteStats()
  113.                       .registerFailedEvent(MathUtils.elapsedNanos(writeNanos), TimeUnit.NANOSECONDS);
  114.                   statsLogger.registerFailedEvent(MathUtils.elapsedNanos(enqueueNanos), TimeUnit.NANOSECONDS);

#340
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java:87: warning: Thread Safety Violation
  Read/Write race. Non-private method `PacketProcessorBase.sendResponse(...)` reads without synchronization from `this.requestHandler`. Potentially races with write in method `PacketProcessorBase.reset()`.
 Reporting because this access may occur on a background thread.
  85.           final long timeOut = requestProcessor.getWaitTimeoutOnBackpressureMillis();
  86.   
  87. >         Channel channel = requestHandler.ctx().channel();
  88.   
  89.           if (timeOut >= 0 && !channel.isWritable()) {

#341
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java:111: warning: Thread Safety Violation
  Read/Write race. Non-private method `PacketProcessorBase.sendResponse(...)` reads without synchronization from `this.request`. Potentially races with write in method `PacketProcessorBase.reset()`.
 Reporting because this access may occur on a background thread.
  109.               if (!channel.isWritable()) {
  110.                   logger.warn("cannot write response to non-writable channel {} for request {}", channel,
  111. >                     StringUtils.requestToString(request));
  112.                   requestProcessor.getRequestStats().getChannelWriteStats()
  113.                       .registerFailedEvent(MathUtils.elapsedNanos(writeNanos), TimeUnit.NANOSECONDS);

#342
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java:136: warning: Thread Safety Violation
  Unprotected write. Non-private method `PendingAddOp.setEntryId(...)` writes to field `this.entryId` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  134.   
  135.       void setEntryId(long entryId) {
  136. >         this.entryId = entryId;
  137.       }
  138.   

#343
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java:140: warning: Thread Safety Violation
  Unprotected write. Non-private method `PendingAddOp.setLedgerLength(...)` writes to field `this.currentLedgerLength` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  138.   
  139.       void setLedgerLength(long ledgerLength) {
  140. >         this.currentLedgerLength = ledgerLength;
  141.       }
  142.   

#344
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:108: warning: Thread Safety Violation
  Read/Write race. Non-private method `RangeRouter.setRanges(...)` reads without synchronization from `this.ranges`. Potentially races with write in method `RangeRouter.setRanges(...)`.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  106.           try {
  107.               // we only update the routing only when see new active ranges
  108. >             if ((this.ranges == null)
  109.                   || (ranges.getMaxRangeId() > this.ranges.getMaxRangeId())) {
  110.                   HashStreamRanges oldRanges = this.ranges;

#345
stream/clients/java/base/src/main/java/org/apache/bookkeeper/clients/impl/routing/RangeRouter.java:111: warning: Thread Safety Violation
  Unprotected write. Non-private method `RangeRouter.setRanges(...)` writes to field `this.ranges` outside of synchronization.
 Reporting because the current class is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  109.                   || (ranges.getMaxRangeId() > this.ranges.getMaxRangeId())) {
  110.                   HashStreamRanges oldRanges = this.ranges;
  111. >                 this.ranges = ranges;
  112.                   return oldRanges;
  113.               } else {

#346
bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/zk/ZKMetadataClientDriver.java:99: warning: Thread Safety Violation
  Read/Write race. Non-private method `ZKMetadataClientDriver.setSessionStateListener(...)` reads without synchronization from `this.zk`. Potentially races with write in method `ZKMetadataClientDriver.initialize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
   97.       @Override
   98.       public void setSessionStateListener(SessionStateListener sessionStateListener) {
   99. >         zk.register((event) -> {
  100.               // Check for expired connection.
  101.               if (event.getType().equals(EventType.None) && event.getState().equals(KeeperState.Expired)) {

#347
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java:245: warning: Thread Safety Violation
  Read/Write race. Non-private method `AuditorElector.shutdown()` reads without synchronization from `this.auditor`. Potentially races with write in method `AuditorElector.shutdown()`.
 Reporting because this access may occur on a background thread.
  243.           }
  244.   
  245. >         if (auditor != null) {
  246.               auditor.shutdown();
  247.               auditor = null;

#348
bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/AuditorElector.java:247: warning: Thread Safety Violation
  Unprotected write. Non-private method `AuditorElector.shutdown()` writes to field `this.auditor` outside of synchronization.
 Reporting because this access may occur on a background thread.
  245.           if (auditor != null) {
  246.               auditor.shutdown();
  247. >             auditor = null;
  248.           }
  249.           if (ownBkc) {

#349
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieImpl.java:842: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieImpl.shutdown()` indirectly reads without synchronization from `this.exitCode`. Potentially races with write in method `BookieImpl.start()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  840.       // to shut down bookie gracefully
  841.       public int shutdown() {
  842. >         return shutdown(ExitCode.OK);
  843.       }
  844.       // internal shutdown method to let shutdown bookie gracefully

#350
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/storage/ldb/SingleDirectoryDbLedgerStorage.java:336: warning: Thread Safety Violation
  Read/Write race. Non-private method `SingleDirectoryDbLedgerStorage.shutdown()` indirectly reads without synchronization from `this.lastCheckpoint`. Potentially races with write in method `SingleDirectoryDbLedgerStorage.checkpoint(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  334.       public void shutdown() throws InterruptedException {
  335.           try {
  336. >             flush();
  337.   
  338.               gcThread.shutdown();

#351
bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieImpl.java:890: warning: Thread Safety Violation
  Read/Write race. Non-private method `BookieImpl.shutdown(...)` reads without synchronization from `this.exitCode`. Potentially races with write in method `BookieImpl.shutdown()`.
 Reporting because this access may occur on a background thread.
  888.               stateManager.close();
  889.           }
  890. >         return this.exitCode;
  891.       }
  892.   

#352
bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SnapshotMap.java:62: warning: Thread Safety Violation
  Read/Write race. Non-private method `SnapshotMap.snapshot()` reads without synchronization from container `this.updatesToMerge` via call to `Map.entrySet()`. Potentially races with write in method `SnapshotMap.remove(...)`.
 Reporting because this access may occur on a background thread.
  60.           }
  61.           // merging the updates to snapshot
  62. >         for (Map.Entry<K, V> entry : updatesToMerge.entrySet()) {
  63.               snapshot.put(entry.getKey(), entry.getValue());
  64.           }

#353
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java:128: warning: Thread Safety Violation
  Unprotected write. Non-private method `BookieServer.start()` writes to field `this.exitCode` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  126.           // fail fast, when bookie startup is not successful
  127.           if (!this.bookie.isRunning()) {
  128. >             exitCode = bookie.getExitCode();
  129.               this.requestProcessor.close();
  130.               return;

#354
stream/common/src/main/java/org/apache/bookkeeper/common/grpc/proxy/ProxyServerCallHandler.java:45: warning: Interface Not Thread Safe
  Unprotected call to method `ChannelFinder.findChannel(...)` of un-annotated interface `org.apache.bookkeeper.common.grpc.proxy.ChannelFinder`. Consider annotating the interface with `@ThreadSafe` or adding a lock.
 Reporting because a superclass `class io.grpc.ServerCallHandler` is annotated `@ThreadSafe`.
  43.       @Override
  44.       public Listener<ReqT> startCall(ServerCall<ReqT, RespT> serverCall, Metadata headers) {
  45. >         Channel channel = finder.findChannel(serverCall, headers);
  46.           ClientCall<ReqT, RespT> clientCall = channel.newCall(
  47.               serverCall.getMethodDescriptor(), callOptions);

#355
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:144: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.toOpStatData()` reads without synchronization from `this.latencyBuckets.[_]`. Potentially races with write in method `BKStats$OpStats.updateLatency(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  142.               StringBuilder sb = new StringBuilder();
  143.               for (int i = 0; i < NUM_BUCKETS; i++) {
  144. >                 sb.append(latencyBuckets[i]);
  145.                   if (i != NUM_BUCKETS - 1) {
  146.                       sb.append(',');

#356
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:141: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.toOpStatData()` reads without synchronization from `this.numSuccessOps`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  139.   
  140.           public OpStatData toOpStatData() {
  141. >             double avgLatency = numSuccessOps > 0 ? totalLatency / numSuccessOps : 0.0f;
  142.               StringBuilder sb = new StringBuilder();
  143.               for (int i = 0; i < NUM_BUCKETS; i++) {

#357
bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BKStats.java:150: warning: Thread Safety Violation
  Read/Write race. Non-private method `BKStats$OpStats.toOpStatData()` reads without synchronization from `this.maxLatency`. Potentially races with write in method `BKStats$OpStats.copyOf(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  148.               }
  149.   
  150. >             return new OpStatData(maxLatency, minLatency, avgLatency, numSuccessOps, numFailedOps, sb.toString());
  151.           }
  152.   

#358
stream/distributedlog/core/src/main/java/org/apache/distributedlog/EntryPosition.java:60: warning: Thread Safety Violation
  Read/Write race. Non-private method `EntryPosition.toString()` reads without synchronization from `this.entryId`. Potentially races with write in method `EntryPosition.advance(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  58.       public String toString() {
  59.           StringBuilder sb = new StringBuilder();
  60. >         sb.append("(").append(lssn).append(", ").append(entryId).append(")");
  61.           return sb.toString();
  62.       }

#359
bookkeeper-server/src/main/java/org/apache/bookkeeper/metastore/InMemoryMetastoreTable.java:88: warning: Thread Safety Violation
  Read/Write race. Non-private method `InMemoryMetastoreTable$MetadataVersion.toString()` reads without synchronization from `this.version`. Potentially races with write in method `InMemoryMetastoreTable$MetadataVersion.incrementVersion()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  86.           @Override
  87.           public String toString() {
  88. >             return "version=" + version;
  89.           }
  90.   

#360
bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopologyImpl.java:835: warning: Thread Safety Violation
  Read/Write race. Non-private method `NetworkTopologyImpl.toString()` reads without synchronization from `this.numOfRacks`. Potentially races with write in method `NetworkTopologyImpl.remove(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  833.           StringBuilder tree = new StringBuilder();
  834.           tree.append("Number of racks: ");
  835. >         tree.append(numOfRacks);
  836.           tree.append("\n");
  837.           // print the number of leaves

#361
bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopologyImpl.java:844: warning: Thread Safety Violation
  Read/Write race. Non-private method `NetworkTopologyImpl.toString()` indirectly reads without synchronization from container `this.clusterMap.children` via call to `List.isEmpty()`. Potentially races with write in method `NetworkTopologyImpl.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  842.           // print nodes
  843.           for (int i = 0; i < numOfLeaves; i++) {
  844. >             tree.append(NodeBase.getPath(clusterMap.getLeaf(i, null)));
  845.               tree.append("\n");
  846.           }

#362
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java:415: warning: Thread Safety Violation
  Read/Write race. Non-private method `PendingAddOp.toString()` reads without synchronization from `this.lh`. Potentially races with write in method `PendingAddOp.submitCallback(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  413.       public String toString() {
  414.           StringBuilder sb = new StringBuilder();
  415. >         sb.append("PendingAddOp(lid:").append(lh.ledgerId)
  416.             .append(", eid:").append(entryId).append(", completed:")
  417.             .append(completed).append(")");

#363
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java:417: warning: Thread Safety Violation
  Read/Write race. Non-private method `PendingAddOp.toString()` reads without synchronization from `this.completed`. Potentially races with write in method `PendingAddOp.submitCallback(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  415.           sb.append("PendingAddOp(lid:").append(lh.ledgerId)
  416.             .append(", eid:").append(entryId).append(", completed:")
  417. >           .append(completed).append(")");
  418.           return sb.toString();
  419.       }

#364
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java:416: warning: Thread Safety Violation
  Read/Write race. Non-private method `PendingAddOp.toString()` reads without synchronization from `this.entryId`. Potentially races with write in method `PendingAddOp.submitCallback(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  414.           StringBuilder sb = new StringBuilder();
  415.           sb.append("PendingAddOp(lid:").append(lh.ledgerId)
  416. >           .append(", eid:").append(entryId).append(", completed:")
  417.             .append(completed).append(")");
  418.           return sb.toString();

#365
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java:416: warning: Thread Safety Violation
  Read/Write race. Non-private method `RoundRobinDistributionSchedule$RRQuorumCoverageSet.toString()` reads without synchronization from `this.covered.[_]`. Potentially races with write in method `RoundRobinDistributionSchedule$RRQuorumCoverageSet.addBookie(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  414.                   buffer.append(covered[i]).append(", ");
  415.               }
  416. >             buffer.append(covered[i]).append("]");
  417.               return buffer.toString();
  418.           }

#366
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1484: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.tryReadLastAddConfirmedAsync()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1482.       public CompletableFuture<Long> tryReadLastAddConfirmedAsync() {
  1483.           FutureReadLastConfirmed result = new FutureReadLastConfirmed();
  1484. >         asyncTryReadLastConfirmed(result, null);
  1485.           return result;
  1486.       }

#367
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java:1669: warning: Thread Safety Violation
  Read/Write race. Non-private method `LedgerHandle.tryReadLastConfirmed()` indirectly reads without synchronization from `this.versionedMetadata`. Potentially races with write in method `LedgerHandle.setLedgerMetadata(...)`.
 Reporting because this access may occur on a background thread.
  1667.       public long tryReadLastConfirmed() throws InterruptedException, BKException {
  1668.           LastConfirmedCtx ctx = new LastConfirmedCtx();
  1669. >         asyncTryReadLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);
  1670.           synchronized (ctx) {
  1671.               while (!ctx.ready()) {

#368
stats/bookkeeper-stats-providers/codahale-metrics-provider/src/main/java/org/apache/bookkeeper/stats/codahale/FastTimer.java:577: warning: Thread Safety Violation
  Read/Write race. Non-private method `FastTimer.update(...)` indirectly reads without synchronization from `this.lastTime.[_]`. Potentially races with write in method `FastTimer.getSnapshot()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  575.       @Override
  576.       public void update(long duration, TimeUnit unit) {
  577. >         update(unit.toNanos(duration));
  578.       }
  579.   

#369
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:258: warning: Thread Safety Violation
  Read/Write race. Non-private method `RocksdbKVStore.updateLastRevision(...)` reads without synchronization from `this.metaCfHandle`. Potentially races with write in method `RocksdbKVStore.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  256.                   // update revision
  257.                   setLastRevision(revision);
  258. >                 batch.put(metaCfHandle, LAST_REVISION, lastRevisionBytes);
  259.               } catch (RocksDBException e) {
  260.                   throw new StateStoreRuntimeException(

#370
stream/statelib/src/main/java/org/apache/bookkeeper/statelib/impl/kv/RocksdbKVStore.java:257: warning: Thread Safety Violation
  Unprotected write. Non-private method `RocksdbKVStore.updateLastRevision(...)` indirectly writes to field `this.lastRevisionBytes.[_]` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  255.               try {
  256.                   // update revision
  257. >                 setLastRevision(revision);
  258.                   batch.put(metaCfHandle, LAST_REVISION, lastRevisionBytes);
  259.               } catch (RocksDBException e) {

#371
bookkeeper-server/src/main/java/org/apache/bookkeeper/client/WeightedRandomSelectionImpl.java:101: warning: Thread Safety Violation
  Read/Write race. Non-private method `WeightedRandomSelectionImpl.updateMap(...)` reads without synchronization from `this.maxProbabilityMultiplier`. Potentially races with write in method `WeightedRandomSelectionImpl.setMaxProbabilityMultiplier(...)`.
 Reporting because this access may occur on a background thread.
   99.           }
  100.   
  101. >         double maxWeight = maxProbabilityMultiplier * medianWeight;
  102.           Map<T, Double> weightMap = new HashMap<T, Double>();
  103.           for (Map.Entry<T, WeightedObject> e : map.entrySet()) {

Found 372 issues
                            Issue Type(ISSUED_TYPE_ID): #
      Thread Safety Violation(THREAD_SAFETY_VIOLATION): 234
                    Null Dereference(NULL_DEREFERENCE): 90
                          Resource Leak(RESOURCE_LEAK): 34
  Interface Not Thread Safe(INTERFACE_NOT_THREAD_SAFE): 14
